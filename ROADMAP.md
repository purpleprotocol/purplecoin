# Technical Roadmap
This document presents the technical roadmap of the Purplecoin project. Please note that these are subject to change before the release. The roadmap branches off a higher level with sub-sections describing a greater level of detail.

## Purplecoin Core

* [ ] Consensus layer
  - [x] Implement sector blocks
  - [x] Implement shard blocks
  - [x] Implement RSA accumulators
  - [x] Optimise hashing to primes
  - [x] Use multiple accumulators per block
  - [x] Benchmark accumulator code in order to determine optimum number of sectors and shards
  - [x] Implement difficulty calculation
  - [x] Green PoW implementation
  - [x] Update RandomX to GhostRider
  - [x] Sequence PoW algorithms
  - [ ] Choose minimum mainnet difficulty
  - [x] Determine ASIC friendly hash functions
  - [x] Aggregate outputs with same spend script and receiver in the same block
  - [ ] Implement canonical transaction ordering
  - [ ] Implement partially spendable outputs
  - [x] Block serialization
  - [x] Transaction serialization
  - [x] Script arguments serialization
  - [ ] Headers MMR implementation
  - [ ] Find a way to dynamically determine the minimum fee for acceptance into the mempool
  - [ ] Find the optimal number of maximum suspends a transaction is allowed to have. With a limit on suspends, nodes can execute the whole chain of transactions and pre-validate them in order to determine if they will all execute whenever they receive a transaction which hits the `Suspend` opcode. By placing the correct upper bound on suspendable transactions, we can run long computations on the blockchain while also mitigating DDOS vectors in the mempool. The idea is that on the first transaction in a chain of these, the whole computation would be run up to either the number of suspends or the limit on suspends to validate the whole chain. Further transactions wouldn't require validating the whole chain as the VM state proves it was validated via a sequence number included in the vm state binary blob via consensus.
  - [ ] Implement suspendable transactions i.e. transactions that execute over several blocks.
  - [ ] Implement optimal atomic asset exchange script and use it as a default script
  * [ ] Implement VM opcodes
    - [x] OP `0x00` Func - Start a function definition
    - [ ] OP `0x05` Suspend - Suspends execution of the VM and creates an opaque output with the hash of the current execution state i.e. stack frame + input_stack + output_stack. This output can be respent to resume execution by anyone who includes it in a new transaction along with another input to pay the transaction fees. The VM must be started with special flags to resume the execution of the opaque output which must receive as arguments in the new transaction the following things: the original spending script, and the VM state binary blob. 
    - [ ] OP `0x07` ChainId - Pushes the current `chain_id` onto the stack
    - [ ] OP `0x08` ChainHeight - Pushes the current `chain_height` onto the stack
    - [ ] OP `0x09` ChainTimestamp - Pushes the current timestamp of the chain onto the stack as a `Signed64`
    - [ ] OP `0x0a` IsCoinbase - Pushes `1` as an `Signed8` onto the stack if the current input is a coinbase otherwise pushes `0`
    - [ ] OP `0x0b` PrevBlockHash - Pushes the previous block hash onto the stack as a `Hash256`
    - [x] OP `0x0d` RandomHash160Var - Pushes a random `Hash160` onto the stack
    - [x] OP `0x0e` RandomHash256Var - Pushes a random `Hash256` onto the stack
    - [x] OP `0x0f` RandomHash512Var - Pushes a random `Hash512` onto the stack
    - [x] OP `0x10` RandomUnsigned8Var - Pushes a random `Unsigned8` onto the stack
    - [x] OP `0x11` RandomUnsigned16Var - Pushes a random `Unsigned16` onto the stack
    - [x] OP `0x12` RandomUnsigned32Var - Pushes a random `Unsigned32` onto the stack
    - [x] OP `0x13` RandomUnsigned64Var - Pushes a random `Unsigned64` onto the stack
    - [x] OP `0x14` RandomUnsigned128Var - Pushes a random `Unsigned128` onto the stack
    - [x] OP `0x15` RandomSigned8Var - Pushes a random `Signed8` onto the stack
    - [x] OP `0x16` RandomSigned16Var - Pushes a random `Signed16` onto the stack
    - [x] OP `0x17` RandomSigned32Var - Pushes a random `Signed32` onto the stack
    - [x] OP `0x18` RandomSigned64Var - Pushes a random `Signed64` onto the stack
    - [x] OP `0x19` RandomSigned128Var - Pushes a random `Signed128` onto the stack
    - [x] OP `0x20` Hash160Var - Pushes a `Hash160` onto the stack
    - [x] OP `0x21` Hash256Var - Pushes a `Hash256` onto the stack
    - [x] OP `0x22` Hash512Var - Pushes a `Hash512` onto the stack
    - [x] OP `0x23` Unsigned8Var - Pushes an `Unsigned8` onto the stack
    - [x] OP `0x24` Unsigned16Var - Pushes an `Unsigned16` onto the stack
    - [x] OP `0x25` Unsigned32Var - Pushes an `Unsigned32` onto the stack
    - [x] OP `0x26` Unsigned64Var - Pushes an `Unsigned64` onto the stack
    - [x] OP `0x27` Unsigned128Var - Pushes an `Unsigned128` onto the stack
    - [ ] OP `0x28` UnsignedBigVar - Pushes an `UnsignedBig` onto the stack
    - [x] OP `0x29` Signed8Var - Pushes a `Signed8` onto the stack
    - [x] OP `0x2a` Signed16Var - Pushes a `Signed16` onto the stack
    - [x] OP `0x2b` Signed32Var - Pushes a `Signed32` onto the stack
    - [x] OP `0x2c` Signed64Var - Pushes a `Signed64` onto the stack
    - [x] OP `0x2d` Signed128Var - Pushes a `Signed128` onto the stack
    - [ ] OP `0x2e` SignedBigVar - Pushes a `SignedBig` onto the stack
    - [x] OP `0x31` Hash160ArrayVar - Pushes a `Hash160Array` onto the stack
    - [x] OP `0x32` Hash256ArrayVar - Pushes a `Hash256Array` onto the stack
    - [x] OP `0x33` Hash512ArrayVar - Pushes a `Hash512Array` onto the stack
    - [x] OP `0x34` Unsigned8ArrayVar - Pushes a `Unsigned8Array` onto the stack
    - [x] OP `0x35` Unsigned16ArrayVar - Pushes a `Unsigned16Array` onto the stack
    - [x] OP `0x36` Unsigned32ArrayVar - Pushes a `Unsigned32Array` onto the stack
    - [x] OP `0x37` Unsigned64ArrayVar - Pushes a `Unsigned64` onto the stack
    - [x] OP `0x38` Unsigned128ArrayVar - Pushes a `Unsigned128Array` onto the stack
    - [ ] OP `0x39` UnsignedBigArrayVar - Pushes a `UnsignedBigArray` onto the stack
    - [x] OP `0x3a` Signed8ArrayVar - Pushes a `Signed8Array` onto the stack
    - [x] OP `0x3b` Signed16ArrayVar - Pushes a `Signed16Array` onto the stack
    - [x] OP `0x3c` Signed32ArrayVar - Pushes a `Signed32Array` onto the stack
    - [x] OP `0x3d` Signed64ArrayVar - Pushes a `Signed64Array` onto the stack
    - [x] OP `0x3e` Signed128ArrayVar - Pushes a `Signed128Array` onto the stack
    - [ ] OP `0x3f` SignedBigArrayVar - Pushes a `SignedBigArray` onto the stack
    - [x] OP `0x4a` ArrayLen - Pushes on top of the stack the len of the array currently on top of the stack
    - [x] OP `0x4b` GetType - Pushes on top of the stack the type code of the value currently on top of the stack as a `Unsigned8`
    - [x] OP `0x4f` ClearStack - Clears the stack
    - [x] OP `0x50` Add - Pops the two topmost items on the stack, performs addition and pushes the result on the stack
    - [x] OP `0x51` Sub - Pops the two topmost items on the stack, performs subtraction and pushes the result on the stack
    - [x] OP `0x52` Mult - Pops the two topmost items on the stack, performs multiplication and pushes the result on the stack
    - [x] OP `0x53` Div - Pops the two topmost items on the stack, performs division and pushes the result on the stack
    - [ ] OP `0x54` BitSHLeft - Pops the two topmost items on the stack, performs a left bit shift operation on the first operand and then pushes the result on the stack
    - [ ] OP `0x55` BitSHRight - Pops the two topmost items on the stack, performs a right bit shift operation on the first operand and then pushes the result on the stack
    - [ ] OP `0x56` BitXOR - Pops the two topmost items on the stack, performs bit exclusive OR on the operands and then pushes the result on the stack
    - [x] OP `0x57` Loop - Starts a loop block
    - [x] OP `0x58` Break - Breaks the current loop
    - [x] OP `0x59` BreakIf - Breaks the current loop if the topmost item on the stack is `1`
    - [x] OP `0x5a` BreakIfn - Breaks the current loop if the topmost item on the stack is not equal to `1`
    - [x] OP `0x5b` BreakIfEq - Breaks the current loop if the two topmost items on the stack are equal
    - [x] OP `0x5c` BreakIfNeq - Breaks the current loop if the two topmost items on the stack are not equal
    - [x] OP `0x5d` BreakIfLeq - Breaks the current loop if the topmost item on the stack is less or equal than the second
    - [x] OP `0x5e` BreakIfGeq - Breaks the current loop if the topmost item on the stack is greater or equal than the second
    - [x] OP `0x5f` BreakIfLt - Breaks the current loop if the topmost item on the stack is less than the second
    - [x] OP `0x60` BreakIfGt - Breaks the current loop if the topmost item on the stack is greater than the second
    - [x] OP `0x61` Continue - Moves to the next iteration of the current loop
    - [x] OP `0x62` ContinueIf - Moves to the next iteration of the current loop if the topmost item on the stack is equal to `1`
    - [x] OP `0x63` ContinueIfn - Moves to the next iteration of the current loop if the topmost item on the stack is not equal to `1`
    - [x] OP `0x64` ContinueIfEq - Moves to the next iteration of the current loop if the two topmost items on the stack are equal
    - [x] OP `0x66` ContinueIfNeq - Moves to the next iteration of the current loop if the two topmost items on the stack are not equal
    - [x] OP `0x66` ContinueIfLeq - Moves to the next iteration of the current loop if the topmost item on the stack is less or equal than the second
    - [x] OP `0x67` ContinueIfGeq - Moves to the next iteration of the current loop if the topmost item on the stack is greater or equal than the second
    - [x] OP `0x68` ContinueIfLt - Moves to the next iteration of the current loop if the topmost item on the stack is less than the second
    - [x] OP `0x69` ContinueIfGt - Moves to the next iteration of the current loop if the topmost item on the stack is greater than the second
    - [x] OP `0x6a` Depth - Pushes the depth of the current frame onto the stack as an `Unsigned16`
    - [x] OP `0x6b` IfDup - If the topmost item on the stack is not `0`, duplicate it
    - [x] OP `0x6c` Drop - Removes the topmost item on the stack
    - [x] OP `0x6d` Dup - Duplicates the topmost item on the stack
    - [x] OP `0x6e` Nip - Removes the second item on the stack
    - [x] OP `0x6f` Over - Duplicates the second item on the stack
    - [x] OP `0x70` Pick - Duplicates the `n`th item on the stack
    - [x] OP `0x71` Roll - The `n`th item on the stack is moved to the top
    - [x] OP `0x72` Rot - The three topmost items on the stack are rotated to the left
    - [x] OP `0x73` Swap - The two topmost items on the stack are swaped
    - [x] OP `0x74` Tuck - The topmost item on the stack is copied and inserted before the second-to-top item
    - [x] OP `0x75` Drop2 - Removes the first two topmost items on the stack
    - [x] OP `0x76` Dup2 - Duplicates the first two topmost items on the stack
    - [x] OP `0x77` Dup3 - Duplicates the first three topmost items on the stack
    - [x] OP `0x78` Over2 - Duplicates the third and fourth items on the stack
    - [x] OP `0x79` Rot2 - The fifth and sixth topmost items on the stack are moved to the top
    - [x] OP `0x7a` Swap2 - Swaps the topmost pairs of terms on top of the stack
    - [x] OP `0x7b` Size - Pushes the size in bytes of the topmost item on the stack
    - [ ] OP `0x7c` Substr - Splits the given array at position n and pushes both arrays to the top of the stack
    - [ ] OP `0x7d` BitOR -  Pops the two topmost items on the stack, performs bit OR on the operands and then pushes the result on the stack
    - [ ] OP `0x7e` BitInvert - Inverts all bits of the topmost item on the stack
    - [ ] OP `0x7f` DupAll - Duplicates the whole stack
    - [ ] OP `0x80` IsUTF8 - Pushes `1` on top of the stack if the given `Unsigned8Array` is a valid UTF8 byte sequence
    - [x] OP `0x82` Add1 - Adds `1` to the topmost item on the stack
    - [x] OP `0x83` Sub1 - Subtracts `1` from the topmost item on the stack
    - [x] OP `0x84` Min - Returns the minimum of the two topmost items on the stack
    - [x] OP `0x85` Max - Returns the maximum of the two topmost items on the stack
    - [ ] OP `0x86` Within - Pushes `1` on top of the stack if the topmost item on the stack is between the second and the third.
    - [ ] OP `0x87` BoolAnd - And control operator
    - [ ] OP `0x88` BoolOr - Or control operator
    - [ ] OP `0x89` Negate - If the topmost item on the stack is `1`, turns it into a `0`. If the topmost item on the stack is anything but `1` it turns it into a `1`
    - [ ] OP `0x8a` Abs - Returns the absolute value of the topmost item on the stack
    - [ ] OP `0x8b` PushPrevScriptOuts - Pushes previous spend script outs on top of the stack up to `n`
    - [ ] OP `0x8c` PushPrevScriptOutsLen - Pushes the length of previous spend script outs on top of the stack
    - [ ] OP `0x8e` PushExecCount - Pushes the current amount of opcodes that have been executed to the top of the stack
    - [ ] OP `0x8f` FlushToScriptOuts - Flushes the terms on the current frame to the script outputs stack
    - [x] OP `0x90` PopToScriptOuts - Pops the topmost item on the stack and pushes it to the script outputs stack
    - [x] OP `0x91` PickToScriptOuts - Duplicates the `n`th item on the stack and pushes it to the script outputs stack
    - [ ] OP `0x92` TrapIf - Traps if
    - [ ] OP `0x93` TrapIfEq - Traps if the two topmost items on the stack are equal
    - [ ] OP `0x94` TrapIfNeq - Traps if the two topmost items onf the stack are not equal
    - [ ] OP `0x95` TrapIfLeq - Traps if the first item on the stack is less than the second
    - [ ] OP `0x96` TrapIfGeq - Traps if the second item on the stack is greater or equal than the second
    - [ ] OP `0x97` TrapIfGt - Traps if the first item on the stack is greater than the second
    - [ ] OP `0x98` TrapIfLt - Traps if the first item on the stack lesser than the second
    - [ ] OP `0x99` TrapIfNeqType - Pops the first item on the stack and traps if its type not equal to the given type id
    - [ ] OP `0x9a` ToHex - Converts the topmost item on the stack to hexadecimal
    - [ ] OP `0x9b` FromHex - Parses the topmost item on the stack from hexadecimal
    - [ ] OP `0xa0` VerifyEd25519 - Takes the given public key and signature, and pushes them along with the current output's binary format to the Ed25519 signature verification stack and stops script execution.
    - [ ] OP `0xa1` VerifyEd25519Inline - Takes the given public key, signature, and message and verifies with Ed25519. Pushes `1` on top of the stack if verification is successful.
    - [ ] OP `0xa2` VerifyEcdsa - Takes the given public key, signature, and the binary format of the current output, verifies and stops script execution. Can be used for compatibility with Bitcoin/Ethereum or any other blockchain using ECDSA.
    - [ ] OP `0xa3` VerifyEcdsaInline - Takes the given public key, signature, and message and verifies with ecdsa. Pushes `1` on top of the stack if verification is successful.
    - [ ] OP `0xa4` VerifyBIP340 - Takes the given public key and signature, and pushes them along with the current output's binary format to the BIP340 signature verification stack and stops script execution. For direct compatibility with Bitcoin Taproot.
    - [ ] OP `0xa5` VerifyBIP340Inline - Takes the given public key, signature, and message and verifies according to BIP340. Pushes `1` on top of the stack if verification is successful. For direct compatibility with Bitcoin Taproot.
    - [ ] OP `0xae` CallBody - Interprets the top `Unsigned8Array` on the stack as a Func body and executes it
    - [x] OP `0xaf` Call - Calls the function with the given index.
    - [ ] OP `0xb0` Concat - Concats the two topmost items on the stack
    - [ ] OP `0xb1` Eq - Pushes `1` on top of the stack if the two topmost items on the stack are equal
    - [ ] OP `0xb2` Neq - Pushes `1` on top of the stack if the two topmost items on the stack are not equal
    - [ ] OP `0xb3` If - If control operator
    - [ ] OP `0xb4` Ifn - If not control operator
    - [ ] OP `0xb5` Else - Else control operator
    - [x] OP `0xb6` End - Ends the current block
    - [x] OP `0xb7` Verify - Pushes the current output's binary format to the signature verification stack and stops script execution
    - [x] OP `0xb8` ReturnFunc - Returns from the current function and moves the terms on the current frame to the parent frame. Behaves the same as `Return` if called from the main function
    - [ ] OP `0xb9` Return - Stops script execution and succeeds if the topmost item on the stack is `1`
    - [ ] OP `0xba` EqVerify - Pushes the current output's binary format to the signature verification stack and stops script execution if the two topmost items on the stack are equal
    - [x] OP `0xbb` Lt - Pushes `1` on top of the stack if the topmost item on the stack is less than the second item on stack
    - [x] OP `0xbc` Gt - Pushes `1` on top of the stack if the topmost item on the stack is greater than the second item on stack
    - [x] OP `0xbd` Leq - Pushes `1` on top of the stack if the topmost item on the stack is less or equal than the second item on stack
    - [x] OP `0xbe` Geq - Pushes `1` on top of the stack if the topmost item on the stack is greater or equal than the second item on stack
    - [ ] OP `0xbf` IfLt - If less than control operator
    - [ ] OP `0xc0` IfGt - If greater than control operator
    - [ ] OP `0xc1` IfLeq - If less or equal control operator
    - [ ] OP `0xc2` IfGeq - If greater or equal control operator
    - [ ] OP `0xc3` IfEq - If equal control operator
    - [ ] OP `0xc4` IfNeq - If not equal control operator
    - [ ] OP `0xc5` LtVerify - Pushes the current output's binary format to the signature verification stack and stops script execution if the topmost item on the stack is less than the second item on the stack
    - [ ] OP `0xc6` GtVerify - Pushes the current output's binary format to the signature verification stack and stops script execution if the topmost item on the stack is greater than the second item on the stack
    - [ ] OP `0xc7` LeqVerify - Pushes the current output's binary format to the signature verification stack and stops script execution if the topmost item on the stack is less or equal than the second item on the stack
    - [ ] OP `0xc8` GeqVerify - Pushes the current output's binary format to the signature verification stack and stops script execution if the topmost item on the stack is greater or equal than the second item on the stack
    - [ ] OP `0xc9` NeqVerify - Pushes the current output's binary format to the signature verification stack and stops script execution if the two topmost items on the stack are not equal
    - [ ] OP `0xca` CastTo - Casts the topmost item on the stack to the type id which is the second item on the stack
    - [x] OP `0xcf` PushOut - Pushes a new output to the output stack. The following arguments are poped from the stack: `out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [x] OP `0xd0` PushOutVerify - Pushes a new output to the output stack and calls Verify. The following arguments are popped from the stack: `out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [x] OP `0xd1` PushCoinbaseOut - Pushes a coinbase output to the output stack. Only valid in the coinbase input. The following arguments are popped from the stack: `out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [ ] OP `0xd2` PushColouredCoinbaseOut - Pushes a coloured coinbase output to the output stack. Only valid in the asset emission script. The following arguments are popped from the stack: `out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160` where `out_address` is the first 20 bytes of a coloured address.
    - [ ] OP `0xd3` PushCoinbaseOutNoSpendAddress - Pushes a coinbase output to the output stack without an explicit spend address. Only valid in the coinbase input. The following arguments are popped from the stack: `out_amount = Signed128, out_script_hash = Hash160`
    - [ ] OP `0xd4` PushColouredCoinbaseOutNoSpendAddress - Pushes a coloured coinbase output to the output stack without an explicit spend address. Only valid in the asset emission script. The following arguments are popped from the stack: `out_amount = Signed128, out_script_hash = Hash160`
    - [ ] OP `0xd5` PushOutIf - Pushes a new output to the output stack if the first item on the stack is equal to 1. The following arguments are poped from the stack: `condition = <any_integer_type>, out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [ ] OP `0xd6` PushOutIfEq - Pushes a new output to the output stack if the topmost items on the stack are equal. The following arguments are poped from the stack: `value1 = <any_type>, value2 = <any_type>, out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [ ] OP `0xd7` PushOutIfNeq - Pushes a new output to the output stack if the topmost items on the stack are not equal. The following arguments are poped from the stack: `value1 = <any_type>, value2 = <any_type>, out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [ ] OP `0xd8` PushOutIfLt - Pushes a new output to the output stack if the topmost item on the stack is less than the second item on the stack. The following arguments are poped from the stack: `value1 = <any_type>, value2 = <any_type>, out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [ ] OP `0xd9` PushOutIfGt - Pushes a new output to the output stack if the topmost item on the stack is greater than the second item on the stack. The following arguments are poped from the stack: `value1 = <any_type>, value2 = <any_type>, out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [ ] OP `0xda` PushOutIfLeq - Pushes a new output to the output stack if the topmost item on the stack is less or equal than the second item on the stack. The following arguments are poped from the stack: `value1 = <any_type>, value2 = <any_type>, out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [ ] OP `0xdb` PushOutIfGeq - Pushes a new output to the output stack if the topmost item on the stack is greater or equal than the second item on the stack. The following arguments are poped from the stack: `value1 = <any_type>, value2 = <any_type>, out_amount = Signed128, out_address = Hash160, out_script_hash = Hash160`
    - [ ] OP `0xe9` GhostRider256 - Pops the topmost item on the stack, hashes it with GhostRider and then pushes the result to the stack.
    - [ ] OP `0xea` Fugue256 - Pops the topmost item on the stack, hashes it with Fugue256 and then pushes the result to the stack.
    - [ ] OP `0xeb` JH256 - Pops the topmost item on the stack, hashes it with JH256 and then pushes the result to the stack.
    - [x] OP `0xec` Blake2s256 - Pops the topmost item on the stack, hashes it with Blake2s256 and then pushes the result to the stack.
    - [x] OP `0xed` Trap - Breaks script execution and returns an implicit error.
    - [x] OP `0xee` Sha256 - Pops the topmost item on the stack, hashes it with Sha256 and then pushes the result to the stack.
    - [x] OP `0xef` Sha512 - Pops the topmost item on the stack, hashes it with Sha512 and then pushes the result to the stack.
    - [x] OP `0xf0` Keccak256 - Pops the topmost item on the stack, hashes it with Keccak256 and then pushes the result to the stack.
    - [x] OP `0xf1` Keccak512 - Pops the topmost item on the stack, hashes it with Keccak512 and then pushes the result to the stack.
    - [x] OP `0xf2` Blake2b256 - Pops the topmost item on the stack, hashes it with Blake2b256 and then pushes the result to the stack.
    - [x] OP `0xf3` Blake2b512 - Pops the topmost item on the stack, hashes it with Blake2b512 and then pushes the result to the stack.
    - [ ] OP `0xf4` Blake3_160 - Pops the topmost item on the stack, hashes it with Blake3_160 and then pushes the result to the stack.
    - [x] OP `0xf5` Blake3_256 - Pops the topmost item on the stack, hashes it with Blake3_256 and then pushes the result to the stack.
    - [x] OP `0xf6` Blake3_512 - Pops the topmost item on the stack, hashes it with Blake3_512 and then
    - [ ] OP `0xf7` Blake3_256_160 - Pops the topmost item on the stack, hashes it with Blake3_256, then hashes the resulting hash with Blake3_160 and then pushes the result to the stack.
    - [ ] OP `0xf8` Blake3_256Keyed - Pops the topmost item on the stack, hashes it with Blake3_256 keyed with the current shard key and then pushes the result to the stack.
    - [ ] OP `0xf9` Blake3_512Keyed - Pops the following from the stack: `value_to_hash = <any_type>, key = Unsigned8Array` and hashes the value it with Blake3_512 keyed and then pushes the result to the stack.
    - [ ] OP `0xfa` Blake3_160Keyed - Pops the following from the stack: `value_to_hash = <any_type>, key = Unsigned8Array` and hashes the value it with Blake3_160 keyed and then pushes the result to the stack.
    - [ ] OP `0xfb` Blake3_160Internal - Pops the topmost item on the stack, hashes it with Blake3_160 keyed with the current shard key, and then pushes the result to the stack.
    - [x] OP `0xfc` Blake3_256Internal - Pops the topmost item on the stack, hashes it with Blake3_256 keyed with the current shard key, and then pushes the result to the stack.
    - [x] OP `0xfd` Blake3_512Internal - Pops the topmost item on the stack, hashes it with Blake3_512 keyed with the current shard key, and then pushes the result to the stack.
    - [ ] OP `0xfe` Blake3_256_160Internal - Pops the topmost item on the stack, hashes it with Blake3_256 keyed with the current shard key, and then pushes the result to the stack.
    - [x] OP `0xff` Nop - Does nothing
* [ ] Network layer
  - [ ] Sector networking
    - [x] Seed nodes DNS resolution
    - [ ] Header synchronization
    - [ ] Peer discovery via Kademlia DHT
  	- [ ] Implement base header propagation
    - [ ] Implement graphene propagation
  - [ ] Public Bridge DHT
    - [ ] Query outputs via Kademlia
    - [ ] Query headers via Kademlia
  - [ ] Private Bridge protocol
    - [ ] Query private bridges
    - [ ] Import private bridges from certificates
  - [ ] Cluster mode
    - [ ] Clustered block validation consensus
      - [ ] AP mode
      - [ ] CP mode
      - [ ] Hybrid CP mode in the same datacenter but AP across datacenters
    - [ ] Shard distribution on a hash ring
    - [ ] Shard re-distribution on the hash ring when adding/removing nodes
    - [ ] Shard simple replication
    - [ ] Shard datacenter replication
    - [ ] UTXO/Witness set simple replication
    - [ ] UTXO/Witness set datacenter replication
    - [ ] Wallet simple replication
    - [ ] Wallet datacenter replication
  - [ ] Asset Exchange
    - [ ] Quote mempool
    - [ ] Asset exchange peer discovery via Kademlia DHT
* [ ] Node
  - [ ] RPC
    - [x] RPC over HTTP/JSON
    - [ ] RPC over WS/JSON
    - [ ] RPC over WS/Binary
    - [ ] RPC over TCP/JSON
    - [ ] RPC over TCP/Binary
    - [ ] RPC Commands
      - [ ] GetBlockchainInfo
      - [ ] GetBlockHash
      - [ ] GetBlockStats
      - [ ] GetHeight
      - [ ] GetShardInfo
      - [ ] GetMempoolInfo
      - [ ] GetRawMempoolShard
      - [ ] GetRawMempool
      - [ ] PreciousBlock
      - [ ] PruneShard
      - [ ] Generate
      - [ ] GenerateToDescriptor
      - [ ] GenerateToAddress
      - [ ] GenerateShare
      - [ ] GenerateShareToDescriptor
      - [ ] GenerateShareToAddress
      - [ ] SubmitBlock
      - [ ] SubmitShareBlock
      - [ ] GetNetworkInfo
      - [ ] GetPeerInfo
      - [ ] AddNode
      - [ ] ListBanned
      - [ ] SetNetworkActive
      - [ ] GetNodeInfo
      - [ ] Stop
      - [ ] Uptime
      - [ ] ValidateAddress
      - [ ] SignMessageWithPrivKey
      - [ ] VerifyMessage
      - [ ] VerifyAddress
      - [ ] GenerateWallet
      - [ ] BackupWallet
      - [ ] BackupWalletS3
      - [ ] SendRawTx
      - [ ] QueryOutput
  - [ ] Mempool
    - [x] Base Implenentation
    - [ ] Sharded mempool
* [ ] Wallet
  - [x] Hierarchical Deterministic Wallet
  - [ ] Multi-Sig Hierarchical Deterministic Wallet
  - [ ] Backup wallet
  - [ ] Backup wallet to AWS S3
  - [ ] Backup wallet to Google Cloud Storage
  - [ ] Restore wallet from file
  - [ ] Restore wallet from AWS S3
  - [ ] Restore wallet from Google Cloud Storage
* [ ] GUI
  - [x] Onboarding screen
  - [x] Render XPU balances
  - [ ] Render XPU transaction history
  - [ ] Render alternative asset balances
  - [ ] Render alternative asset transaction histories
  - [ ] Render wallet addresses
  - [x] Create wallet
  - [ ] Import wallet
    - [ ] Import wallet from encrypted private key with secure window to enter the decryption key
    - [ ] Import wallet from unencrypted private key with secure window
    - [ ] Import wallet from file
  - [ ] Create new wallet address
    - [ ] Render address as QR Code
  - [ ] Send interface
    - [ ] Send via QR Code
  - [ ] Receive interface
    - [ ] Receive via QR Code
  - [ ] Multi-Sig interface
  - [ ] Asset exchange interface
    - [ ] Price chart
    - [ ] Trading interface
    - [ ] Market orders
    - [ ] Limit orders
