// Copyright (c) 2022 Octavian Oncescu
// Copyright (c) 2022-2023 The Purplecoin Core developers
// Licensed under the Apache License, Version 2.0 see LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0 or the MIT license, see
// LICENSE-MIT or http://opensource.org/licenses/MIT

use crate::consensus::*;
use crate::primitives::Hash256;
use crate::primitives::{Address, Hash160, Input, Output};
use crate::vm::internal::{Float32Wrapper, Float64Wrapper, VmTerm, EMPTY_VEC_HEAP_SIZE};
use crate::vm::opcodes::OP;
use crate::vm::sig_verification::{
    verify_single_bip340, verify_single_ecdsa, verify_single_ed25519, verify_single_schnor,
    VerificationStack,
};
use crate::vm::SigVerificationErr;
use bincode::{Decode, Encode};
use bitvec::prelude::*;
use ibig::ops::Abs;
use ibig::{ibig, ubig, IBig, UBig};
use num_traits::{FromPrimitive, ToPrimitive};
use rand::prelude::*;
use rand_pcg::Pcg64;
use rand_seeder::Seeder;
use rust_decimal::{Decimal, RoundingStrategy};
use rust_decimal_macros::dec;
use schnorrkel::cert::AdaptorCertPublic;
use schnorrkel::{signing_context, PublicKey};
use simdutf8::basic::from_utf8;
use std::collections::HashMap;
use std::mem;
use std::rc::Rc;

use super::bifs;

#[derive(PartialEq, Debug, Clone)]
pub enum ScriptEntry {
    Opcode(OP),
    Byte(u8),
}

#[derive(Debug, Clone)]
pub struct Frame {
    /// Stack storing the terms on the current frame
    pub stack: Vec<VmTerm>,

    /// Instruction pointer
    pub i_ptr: usize,

    /// The index of the script on the script stack. This is `None` if the current script is the main script
    pub script_idx: Option<usize>,

    /// Func index. This is `None` if the current function is the main function
    pub func_idx: Option<usize>,

    /// Some((start_ip, end_ip)) if the current frame is a loop start_ip is the
    /// instruction pointer at the beginning of the loop and end_ip at the end.
    pub is_loop: Option<(usize, usize)>,

    /// An array of (start_ip, end_ip) marking the start and the end of the
    /// control operator blocks that are currently executed
    pub is_control_op: Vec<(usize, usize)>,

    /// Script executor
    pub executor: ScriptExecutor,
}

impl Frame {
    #[must_use]
    pub fn new(script_idx: Option<usize>, func_idx: Option<usize>) -> Self {
        Self {
            stack: Vec::with_capacity(STACK_SIZE),
            i_ptr: 0,
            func_idx,
            script_idx,
            executor: ScriptExecutor::new(),
            is_loop: None,
            is_control_op: vec![],
        }
    }
}

#[derive(Debug, Clone)]
pub struct VmFlags {
    /// Chain id
    pub chain_id: u8,

    /// Chain height
    pub chain_height: u64,

    /// Chain timestamp (last block)
    pub chain_timestamp: i64,

    /// Whether or not to build a stacktrace
    pub build_stacktrace: bool,

    /// Whether or not to validate output amounts based on inputs
    pub validate_output_amounts: bool,

    /// Whether we are processing a coinbase input or not
    pub is_coinbase: bool,

    /// The previous block hash
    pub prev_block_hash: [u8; 32],

    /// The binary format of the current input
    pub in_binary: Vec<u8>,

    /// Previous output script outputs
    pub spent_out: Option<Output>,

    /// Whether the transaction is allowed to fail at block
    /// inclusion time or not.
    pub can_fail: bool,
}

impl Default for VmFlags {
    fn default() -> Self {
        Self {
            chain_id: 0,
            chain_height: 0,
            chain_timestamp: 0,
            build_stacktrace: true,
            validate_output_amounts: false,
            is_coinbase: false,
            prev_block_hash: [0; 32],
            in_binary: vec![],
            spent_out: None,
            can_fail: false,
        }
    }
}

#[derive(PartialEq, Debug, Clone, Default)]
pub struct Script {
    /// Main script
    pub script: Vec<ScriptEntry>,

    /// Other functions in the script
    pub functions: Vec<Vec<ScriptEntry>>,

    /// For each argument, a boolean denoting whether the argument is malleable or not.
    ///
    /// A malleable argument is not signed by the spender.
    pub malleable_args: BitVec,
}

macro_rules! check_top_stack_val {
    ($exp:expr, $frame:expr, $frame_stack:expr, $structt:expr, $flags:expr) => {
        if $exp == &1 {
            return Ok(ExecutionResult::Ok).into();
        } else {
            let mut stack_trace = StackTrace::default();

            if $flags.build_stacktrace {
                stack_trace.trace.push(
                    (
                        $frame.i_ptr,
                        $frame.func_idx,
                        $structt.script[$frame.i_ptr].clone(),
                    )
                        .into(),
                );
                stack_trace.top_frame_stack.extend_from_slice(&$frame.stack);
                stack_trace.extend_from_frame_stack(&$frame_stack, &$structt);
            }

            return Err((ExecutionResult::Invalid, stack_trace)).into();
        }
    };
}

macro_rules! check_bit {
    ($val:expr, $pos:expr) => {
        $val & (1 << $pos) == 1
    };
}

macro_rules! set_bit {
    ($val:expr, $pos:expr, $to_set:expr) => {{
        (($val & (1 << $pos)) | ($to_set << $pos))
    }};
}

macro_rules! var_load {
    ($frame:expr, $script:expr, $sum:ident, $type:ty, $step:expr) => {
        $frame.i_ptr += 1;
        if let ScriptEntry::Byte(byte) = $script[$frame.i_ptr] {
            $sum += (byte as $type);
        } else {
            unreachable!()
        }
    };

    ($frame:expr, $script:expr, $sum:ident, $type:ty, $step:expr, $($tail:expr), +) => {
        var_load!($frame, $script, $sum, $type, $($tail), +);

        $frame.i_ptr += 1;
        if let ScriptEntry::Byte(byte) = $script[$frame.i_ptr] {
            $sum += (byte as $type) << $step;
        } else {
            unreachable!()
        }
    };
}

macro_rules! var_load_from_array {
    ($frame:expr, $script:expr, $arr:ident, $step:expr) => {
        $frame.i_ptr += 1;
        if let ScriptEntry::Byte(byte) = $script[$frame.i_ptr] {
            $arr[$step] = byte;
        } else {
            unreachable!()
        }
    };

    ($frame:expr, $script:expr, $arr:ident, $step:expr, $($tail:expr), +) => {
        var_load_from_array!($frame, $script, $arr, $($tail), +);

        $frame.i_ptr += 1;
        if let ScriptEntry::Byte(byte) = $script[$frame.i_ptr] {
            $arr[$step] = byte;
        } else {
            unreachable!()
        }
    };
}

macro_rules! bitvec_from_bools {
    () => {{
        BitVec::new()
    }};

    ($($a:expr),+ $(,)?) => {{
        let mut buf = BitVec::new();
        $(
            buf.push($a);
        )+
        buf
    }};
}

impl Script {
    #[must_use]
    pub fn new_coinbase() -> Script {
        Script {
            script: vec![
                ScriptEntry::Byte(0x05), // 5 arguments are pushed onto the stack: out_amount, out_address, out_script_hash, coinbase_height, extra_nonce
                ScriptEntry::Opcode(OP::PushCoinbaseOut),
            ],
            malleable_args: bitvec_from_bools![false, false, false, false, false],
            ..Script::default()
        }
    }

    #[must_use]
    pub fn new_coinbase_without_spending_address() -> Script {
        Script {
            script: vec![
                ScriptEntry::Byte(0x04), // 4 arguments are pushed onto the stack: out_amount, out_script_hash, coinbase_height, extra_nonce
                ScriptEntry::Opcode(OP::PushCoinbaseOutNoSpendAddress),
            ],
            malleable_args: bitvec_from_bools![false, false, false, false],
            ..Script::default()
        }
    }

    #[must_use]
    pub fn new_simple_spend() -> Script {
        Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOutVerify),
            ],
            malleable_args: bitvec_from_bools![false, false, false],
            ..Script::default()
        }
    }

    /// Utility to populate `malleable_args` field in tests.
    #[cfg(test)]
    pub fn populate_malleable_args_field(&mut self) {
        if self.malleable_args.is_empty() {
            assert!(!self.script.is_empty());
            if let ScriptEntry::Byte(byte) = self.script[0] {
                let num = byte as usize;
                self.malleable_args = (0..num).map(|_| false).collect();
            } else {
                unreachable!();
            }
        }
    }

    #[must_use]
    pub fn args_len(&self) -> usize {
        self.malleable_args.len()
    }

    pub fn execute(
        &self,
        args: &[VmTerm],
        input_stack: &[Input],
        output_stack: &mut Vec<Output>,
        output_stack_idx_map: &mut HashMap<(Address, Hash160), u16>,
        verification_stack: &mut VerificationStack,
        seed: [u8; 32],
        key: &str,
        network_name: &str,
        flags: VmFlags,
    ) -> VmResult {
        // The length of the inputs must match the length defined in the script
        if args.len() != self.args_len() {
            return Err((
                ExecutionResult::InvalidArgsLen,
                StackTrace {
                    trace: vec![(0_usize, None, self.script[0].clone()).into()],
                    top_frame_stack: vec![],
                },
            ))
            .into();
        }

        // Seed RNG
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        // Initialize internals
        let mut memory_size = 0;
        let mut exec_count = 0;
        let mut frame_stack: Vec<Frame> = Vec::with_capacity(MAX_FRAMES);
        let mut script_storage = HashMap::with_capacity(MAX_SCRIPTS - 1);
        let mut script_stack: Vec<Rc<Script>> = Vec::with_capacity(MAX_SCRIPTS);
        let mut frame = Frame::new(None, None);
        let mut script_outputs = vec![];

        // Push args on the first frame
        for a in args.iter().rev().cloned() {
            memory_size += a.size();
            frame.stack.push(a);
        }
        frame_stack.push(frame);

        let inputs_hashes = input_stack
            .iter()
            .fold(vec![], |mut acc: Vec<u8>, i: &Input| {
                acc.extend_from_slice(i.hash().unwrap().as_bytes());
                acc
            });
        let inputs_hash = Hash160::hash_from_slice(inputs_hashes, key);

        let ops_with_ends = [
            ScriptEntry::Opcode(OP::Loop),
            ScriptEntry::Opcode(OP::If),
            ScriptEntry::Opcode(OP::Ifn),
            ScriptEntry::Opcode(OP::IfLt),
            ScriptEntry::Opcode(OP::IfGt),
            ScriptEntry::Opcode(OP::IfLeq),
            ScriptEntry::Opcode(OP::IfGeq),
            ScriptEntry::Opcode(OP::IfEq),
            ScriptEntry::Opcode(OP::IfNeq),
        ];

        loop {
            let mut new_frame = None;
            let mut new_script = None;
            let mut pop_frame = false;
            let mut set_ip = None;
            let fs_len = frame_stack.len();

            if let Some(frame) = frame_stack.last_mut() {
                let f = match (frame.script_idx, frame.func_idx) {
                    (None, None) => &self.script,
                    (None, Some(func_idx)) => &self.functions[func_idx],
                    (Some(script_idx), Some(func_idx)) => {
                        &script_stack[script_idx].functions[func_idx]
                    }
                    (Some(script_idx), None) => &script_stack[script_idx].script,
                };

                if frame.i_ptr >= f.len() {
                    pop_frame = true;
                } else {
                    let i = &f[frame.i_ptr];
                    exec_count += 1;
                    // Execute opcode
                    frame.executor.push_op(
                        &flags,
                        i,
                        frame.i_ptr,
                        frame.func_idx,
                        &inputs_hash,
                        &mut memory_size,
                        &mut frame.stack,
                        verification_stack,
                        input_stack,
                        output_stack,
                        output_stack_idx_map,
                        &mut script_outputs,
                        key,
                        network_name,
                        &mut exec_count,
                        &script_storage,
                        &script_stack,
                    );

                    // Check for new frames or if we should pop one
                    match &frame.executor.state {
                        ScriptExecutorState::NewLoopFrame => {
                            let mut nf = frame.clone();

                            nf.i_ptr += 1;

                            let start_i = nf.i_ptr;
                            let mut end_i = nf.i_ptr + 1;

                            // Used to mark the finding of a new if / loop
                            let mut other = 0;

                            // Find end instruction idx
                            loop {
                                if ops_with_ends.contains(&self.script[end_i]) {
                                    // Means we got to another operand that requires a closing OP
                                    other += 1;
                                    end_i += 1;
                                    continue;
                                }

                                if let ScriptEntry::Opcode(OP::End) = self.script[end_i] {
                                    if other > 0 {
                                        other -= 1;
                                        end_i += 1;
                                        continue;
                                    }

                                    break;
                                }

                                end_i += 1;
                            }

                            nf.is_loop = Some((start_i, end_i));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            nf.executor.state = ScriptExecutorState::ExpectingInitialOP;

                            for t in &nf.stack {
                                memory_size += t.size();
                            }

                            new_frame = Some(nf);
                        }

                        ScriptExecutorState::NewCallBodyFrame(script_hash, script) => {
                            let script_hash = script_hash.clone();
                            let script_clone = script.clone();

                            // Load the script and push script ref to the script stack
                            script_storage.insert(script_hash.clone(), script_clone.clone());
                            new_script = Some(script_clone);

                            // Create new frame
                            let mut nf = Frame::new(Some(script_stack.len()), None);

                            // Push required amount of args from the parent frame
                            let args_len = script.args_len();
                            if frame.stack.len() < args_len {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::NotEnoughTerms,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                for _ in 0..args_len {
                                    nf.stack.push(frame.stack.pop().unwrap());
                                }

                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                new_frame = Some(nf);
                            }
                        }

                        ScriptExecutorState::NewCallBodyFrameCached(script) => {
                            // Push script ref to the script stack
                            new_script = Some(script.clone());

                            // Create new frame
                            let mut nf = Frame::new(Some(script_stack.len()), None);

                            // Push required amount of args from the parent frame
                            let args_len = script.args_len();
                            if frame.stack.len() < args_len {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::NotEnoughTerms,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                for _ in 0..args_len {
                                    nf.stack.push(frame.stack.pop().unwrap());
                                }

                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                new_frame = Some(nf);
                            }
                        }

                        ScriptExecutorState::BreakLoop => {
                            if let Some((_, end_i)) = frame.is_loop {
                                set_ip = Some(end_i);
                                pop_frame = true;
                            } else {
                                unreachable!()
                            }
                        }

                        ScriptExecutorState::ContinueLoop => {
                            if let Some((start_i, _)) = frame.is_loop {
                                frame.i_ptr = start_i;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            } else {
                                unreachable!()
                            }
                        }

                        ScriptExecutorState::ReturnFunc => {
                            pop_frame = true;
                        }

                        ScriptExecutorState::EndBlock => {
                            let len = frame.is_control_op.len();
                            let mut was_if = false;

                            if len > 0 {
                                // This means we are inside at least one if,
                                // so we have to check if it's the over
                                // of the loop or the over of the if block.
                                let (_, end_i) = frame.is_control_op[len - 1];

                                if end_i == frame.i_ptr {
                                    // We reached the end of the last if
                                    was_if = true;
                                    frame.is_control_op.pop();
                                    frame.i_ptr += 1;
                                    frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                }
                            }

                            if !was_if {
                                if let Some((start_i, _)) = frame.is_loop {
                                    frame.i_ptr = start_i;
                                    frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                } else {
                                    pop_frame = true;
                                }
                            }
                        }

                        ScriptExecutorState::ControlOperator(opt) => match opt {
                            Some(true) => {
                                let start_i = frame.i_ptr;
                                let mut end_i = frame.i_ptr + 1;

                                // Used to mark the finding of a new if / loop
                                let mut other = 0;

                                loop {
                                    if ops_with_ends.contains(&self.script[end_i]) {
                                        // Means we got to another operand that requires a closing OP
                                        other += 1;
                                        end_i += 1;
                                        continue;
                                    }

                                    if let ScriptEntry::Opcode(OP::End) = self.script[end_i] {
                                        if other > 0 {
                                            other -= 1;
                                            end_i += 1;
                                            continue;
                                        }

                                        break;
                                    }

                                    end_i += 1;
                                }

                                frame.is_control_op.push((start_i, end_i));
                                frame.i_ptr += 1;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            }
                            Some(false) => {
                                let start_i = frame.i_ptr;
                                let mut end_i = frame.i_ptr + 1;
                                let mut next_i = 0;

                                // Used to mark the finding of a new if / loop
                                let mut other = 0;

                                loop {
                                    if ops_with_ends.contains(&self.script[end_i]) {
                                        // Means we got to another operand that requires a closing OP
                                        other += 1;
                                        end_i += 1;
                                        continue;
                                    }

                                    if let ScriptEntry::Opcode(OP::Else) = self.script[end_i] {
                                        if other > 0 {
                                            // We hit an Else, but not from the current if
                                            end_i += 1;
                                            continue;
                                        }

                                        // Mark the position of the Else statement
                                        // so the script will continue the execution from here
                                        next_i = end_i;
                                    }

                                    if let ScriptEntry::Opcode(OP::End) = self.script[end_i] {
                                        if other > 0 {
                                            other -= 1;
                                            end_i += 1;
                                            continue;
                                        }

                                        break;
                                    }

                                    end_i += 1;
                                }

                                frame.is_control_op.push((start_i, end_i));
                                frame.i_ptr = if next_i == 0 { end_i } else { next_i + 1 };
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            }
                            None => {
                                let (_, end_i) = frame.is_control_op.pop().unwrap();

                                frame.i_ptr = end_i + 1;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            }
                        },

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomHash160Var) => {
                            frame.stack.push(VmTerm::Hash160(rng.gen::<[u8; 20]>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 20;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomHash256Var) => {
                            frame.stack.push(VmTerm::Hash256(rng.gen::<[u8; 32]>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 32;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomHash512Var) => {
                            let mut res = [0; 64];

                            res[..32].copy_from_slice(&rng.gen::<[u8; 32]>());
                            res[32..64].copy_from_slice(&rng.gen::<[u8; 32]>());

                            frame.stack.push(VmTerm::Hash512(res));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 64;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned8Var) => {
                            frame.stack.push(VmTerm::Unsigned8(rng.gen::<u8>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 1;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned16Var) => {
                            frame.stack.push(VmTerm::Unsigned16(rng.gen::<u16>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 2;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned32Var) => {
                            frame.stack.push(VmTerm::Unsigned32(rng.gen::<u32>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 4;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned64Var) => {
                            frame.stack.push(VmTerm::Unsigned64(rng.gen::<u64>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 8;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned128Var) => {
                            frame.stack.push(VmTerm::Unsigned128(rng.gen::<u128>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 16;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned8Var) => {
                            frame.stack.push(VmTerm::Signed8(rng.gen::<i8>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 1;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned16Var) => {
                            frame.stack.push(VmTerm::Signed16(rng.gen::<i16>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 2;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned32Var) => {
                            frame.stack.push(VmTerm::Signed32(rng.gen::<i32>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 4;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned64Var) => {
                            frame.stack.push(VmTerm::Signed64(rng.gen::<i64>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 8;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned128Var) => {
                            frame.stack.push(VmTerm::Signed128(rng.gen::<i128>()));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 16;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomFloat32Var) => {
                            frame
                                .stack
                                .push(VmTerm::Float32(Float32Wrapper(rng.gen::<f32>())));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 4;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomFloat64Var) => {
                            frame
                                .stack
                                .push(VmTerm::Float64(Float64Wrapper(rng.gen::<f64>())));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 8;
                        }

                        ScriptExecutorState::ExpectingRandomTerm(OP::RandomDecimalVar) => {
                            frame
                                .stack
                                .push(VmTerm::Decimal(Decimal::deserialize(rng.gen::<[u8; 16]>())));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 16;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Call) => {
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                let func_idx = *byte as usize;
                                let funcs_ptr = match frame.script_idx {
                                    Some(script_idx) => &script_stack[script_idx].functions,
                                    None => &self.functions,
                                };

                                if func_idx >= funcs_ptr.len() {
                                    frame.executor.state = ScriptExecutorState::Error(
                                        ExecutionResult::IndexOutOfBounds,
                                        (
                                            frame.i_ptr,
                                            frame.func_idx,
                                            i.clone(),
                                            frame.stack.as_slice(),
                                        )
                                            .into(),
                                    );
                                } else {
                                    let func = &funcs_ptr[func_idx];
                                    let mut nf = Frame::new(frame.script_idx, Some(func_idx));
                                    let args_len = &func[0];

                                    if let ScriptEntry::Byte(args_len) = args_len {
                                        if frame.stack.len() < *args_len as usize {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::NotEnoughTerms,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        } else {
                                            for _ in 0..*args_len {
                                                nf.stack.push(frame.stack.pop().unwrap());
                                            }
                                        }
                                    }

                                    if !matches!(
                                        frame.executor.state,
                                        ScriptExecutorState::Error(_, _)
                                    ) {
                                        frame.executor.state =
                                            ScriptExecutorState::ExpectingInitialOP;
                                        new_frame = Some(nf);
                                    }
                                }
                            } else {
                                unreachable!()
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::TrapIfNeqType) => {
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                let e = frame.stack.pop().unwrap();
                                memory_size -= e.size();

                                if e.get_type() == *byte {
                                    frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                    frame.i_ptr += 1;
                                } else {
                                    frame.executor.state = ScriptExecutorState::Error(
                                        ExecutionResult::Panic,
                                        (
                                            frame.i_ptr,
                                            frame.func_idx,
                                            i.clone(),
                                            frame.stack.as_slice(),
                                        )
                                            .into(),
                                    );
                                }
                            } else {
                                unreachable!()
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash160Var) => {
                            let mut arr: [u8; 20] = [0; 20];

                            for i in 0..20 {
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    arr[i] = *byte;
                                } else {
                                    unreachable!()
                                }
                            }

                            frame.stack.push(VmTerm::Hash160(arr));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 20;
                            exec_count += 20;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash256Var) => {
                            let mut arr: [u8; 32] = [0; 32];

                            for i in 0..32 {
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    arr[i] = *byte;
                                } else {
                                    unreachable!()
                                }
                            }

                            frame.stack.push(VmTerm::Hash256(arr));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 32;
                            exec_count += 32;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash512Var) => {
                            let mut arr: [u8; 64] = [0; 64];

                            for i in 0..64 {
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    arr[i] = *byte;
                                } else {
                                    unreachable!()
                                }
                            }

                            frame.stack.push(VmTerm::Hash512(arr));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 64;
                            exec_count += 64;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned8Var) => {
                            frame.i_ptr += 1;

                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                frame.stack.push(VmTerm::Unsigned8(*byte));
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                                memory_size += 1;
                                exec_count += 1;
                            } else {
                                unreachable!()
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned16Var) => {
                            let mut sum: u16 = 0;

                            var_load!(frame, f, sum, u16, 8, 0);

                            frame.stack.push(VmTerm::Unsigned16(sum));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 2;
                            exec_count += 2;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned32Var) => {
                            let mut sum: u32 = 0;

                            var_load!(frame, f, sum, u32, 24, 16, 8, 0);

                            frame.stack.push(VmTerm::Unsigned32(sum));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 4;
                            exec_count += 4;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned64Var) => {
                            let mut sum: u64 = 0;

                            var_load!(frame, f, sum, u64, 56, 48, 40, 32, 24, 16, 8, 0);

                            frame.stack.push(VmTerm::Unsigned64(sum));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 8;
                            exec_count += 8;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned128Var) => {
                            let mut sum: u128 = 0;

                            var_load!(
                                frame, f, sum, u128, 120, 112, 104, 96, 88, 80, 72, 64, 56, 48, 40,
                                32, 24, 16, 8, 0
                            );

                            frame.stack.push(VmTerm::Unsigned128(sum));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 16;
                            exec_count += 16;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::UnsignedBigVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut vec: Vec<u8> = Vec::with_capacity(len as usize);
                            for _ in 0..len {
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    vec.push(*byte);
                                } else {
                                    unreachable!()
                                }
                            }

                            let term = crate::codec::decode::<VmTerm>(&vec).unwrap();
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed8Var) => {
                            frame.i_ptr += 1;

                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                let byte = unsafe { mem::transmute::<u8, i8>(*byte) };
                                frame.stack.push(VmTerm::Signed8(byte));
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                                memory_size += 1;
                                exec_count += 1;
                            } else {
                                unreachable!()
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed16Var) => {
                            let mut sum: u16 = 0;

                            var_load!(frame, f, sum, u16, 8, 0);

                            let sum = unsafe { mem::transmute::<u16, i16>(sum) };
                            frame.stack.push(VmTerm::Signed16(sum));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 2;
                            exec_count += 2;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed32Var) => {
                            let mut sum: u32 = 0;

                            var_load!(frame, f, sum, u32, 24, 16, 8, 0);

                            let sum = unsafe { mem::transmute::<u32, i32>(sum) };
                            frame.stack.push(VmTerm::Signed32(sum));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 4;
                            exec_count += 4;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed64Var) => {
                            let mut sum: u64 = 0;

                            var_load!(frame, f, sum, u64, 56, 48, 40, 32, 24, 16, 8, 0);

                            let sum = unsafe { mem::transmute::<u64, i64>(sum) };
                            frame.stack.push(VmTerm::Signed64(sum));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 8;
                            exec_count += 8;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed128Var) => {
                            let mut sum: u128 = 0;

                            var_load!(
                                frame, f, sum, u128, 120, 112, 104, 96, 88, 80, 72, 64, 56, 48, 40,
                                32, 24, 16, 8, 0
                            );

                            let sum = unsafe { mem::transmute::<u128, i128>(sum) };
                            frame.stack.push(VmTerm::Signed128(sum));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 16;
                            exec_count += 16;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::SignedBigVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut vec: Vec<u8> = Vec::with_capacity(len as usize);
                            for _ in 0..len {
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    vec.push(*byte);
                                } else {
                                    unreachable!()
                                }
                            }

                            let term = crate::codec::decode::<VmTerm>(&vec).unwrap();
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Float32Var) => {
                            let mut arr: [u8; 4] = [0; 4];

                            var_load_from_array!(frame, f, arr, 3, 2, 1, 0);

                            frame
                                .stack
                                .push(VmTerm::Float32(Float32Wrapper(f32::from_le_bytes(arr))));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 4;
                            exec_count += 4;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Float64Var) => {
                            let mut arr: [u8; 8] = [0; 8];

                            var_load_from_array!(frame, f, arr, 7, 6, 5, 4, 3, 2, 1, 0);

                            frame
                                .stack
                                .push(VmTerm::Float64(Float64Wrapper(f64::from_le_bytes(arr))));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 8;
                            exec_count += 8;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::DecimalVar) => {
                            let mut arr: [u8; 16] = [0; 16];

                            var_load_from_array!(
                                frame, f, arr, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
                            );

                            frame.stack.push(VmTerm::Decimal(Decimal::deserialize(arr)));
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                            memory_size += 16;
                            exec_count += 16;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash160ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<[u8; 20]> = Vec::new();
                            for _ in 0..len {
                                let mut hash_arr: [u8; 20] = [0; 20];

                                for i in 0..20 {
                                    frame.i_ptr += 1;
                                    if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                        hash_arr[i] = *byte;
                                    } else {
                                        unreachable!()
                                    }
                                }

                                arr.push(hash_arr);
                            }

                            let term = VmTerm::Hash160Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash256ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<[u8; 32]> = Vec::new();
                            for _ in 0..len {
                                let mut hash_arr: [u8; 32] = [0; 32];

                                for i in 0..32 {
                                    frame.i_ptr += 1;
                                    if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                        hash_arr[i] = *byte;
                                    } else {
                                        unreachable!()
                                    }
                                }

                                arr.push(hash_arr);
                            }

                            let term = VmTerm::Hash256Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash512ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<[u8; 64]> = Vec::new();
                            for _ in 0..len {
                                let mut hash_arr: [u8; 64] = [0; 64];

                                for i in 0..64 {
                                    frame.i_ptr += 1;
                                    if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                        hash_arr[i] = *byte;
                                    } else {
                                        unreachable!()
                                    }
                                }

                                arr.push(hash_arr);
                            }

                            let term = VmTerm::Hash512Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned8ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<u8> = Vec::new();
                            for _ in 0..len {
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    arr.push(*byte);
                                } else {
                                    unreachable!()
                                }
                            }

                            let term = VmTerm::Unsigned8Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned16ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<u16> = Vec::new();
                            for _ in 0..len {
                                let mut sum: u16 = 0;

                                var_load!(frame, f, sum, u16, 8, 0);

                                arr.push(sum);
                            }

                            let term = VmTerm::Unsigned16Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned32ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<u32> = Vec::new();
                            for _ in 0..len {
                                let mut sum: u32 = 0;

                                var_load!(frame, f, sum, u32, 24, 16, 8, 0);

                                arr.push(sum);
                            }

                            let term = VmTerm::Unsigned32Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned64ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<u64> = Vec::new();
                            for _ in 0..len {
                                let mut sum: u64 = 0;

                                var_load!(frame, f, sum, u64, 56, 48, 40, 32, 24, 16, 8, 0);

                                arr.push(sum);
                            }

                            let term = VmTerm::Unsigned64Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(
                            OP::Unsigned128ArrayVar,
                        ) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<u128> = Vec::new();
                            for _ in 0..len {
                                let mut sum: u128 = 0;

                                var_load!(
                                    frame, f, sum, u128, 120, 112, 104, 96, 88, 80, 72, 64, 56, 48,
                                    40, 32, 24, 16, 8, 0
                                );

                                arr.push(sum);
                            }

                            let term = VmTerm::Unsigned128Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(
                            OP::UnsignedBigArrayVar,
                        ) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<UBig> = Vec::with_capacity(len as usize);
                            for _ in 0..len {
                                let mut term_len: u16 = 0;

                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    term_len += u16::from(*byte);
                                } else {
                                    unreachable!()
                                }
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    term_len += u16::from(*byte) << 8;
                                } else {
                                    unreachable!()
                                }

                                let mut term: Vec<u8> = Vec::with_capacity(term_len as usize);
                                for _ in 0..term_len {
                                    frame.i_ptr += 1;
                                    if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                        term.push(*byte);
                                    } else {
                                        unreachable!()
                                    }
                                }

                                if let VmTerm::UnsignedBig(val) =
                                    crate::codec::decode::<VmTerm>(&term).unwrap()
                                {
                                    arr.push(val);
                                } else {
                                    unreachable!()
                                }
                            }

                            let term = VmTerm::UnsignedBigArray(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2 * (len as u64 + 1);
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed8ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<i8> = Vec::new();
                            for _ in 0..len {
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    let byte = unsafe { mem::transmute::<u8, i8>(*byte) };
                                    arr.push(byte);
                                } else {
                                    unreachable!()
                                }
                            }

                            let term = VmTerm::Signed8Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed16ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<i16> = Vec::new();
                            for _ in 0..len {
                                let mut sum: u16 = 0;

                                var_load!(frame, f, sum, u16, 8, 0);

                                let sum = unsafe { mem::transmute::<u16, i16>(sum) };
                                arr.push(sum);
                            }

                            let term = VmTerm::Signed16Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed32ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<i32> = Vec::new();
                            for _ in 0..len {
                                let mut sum: u32 = 0;

                                var_load!(frame, f, sum, u32, 24, 16, 8, 0);

                                let sum = unsafe { mem::transmute::<u32, i32>(sum) };
                                arr.push(sum);
                            }

                            let term = VmTerm::Signed32Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed64ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<i64> = Vec::new();
                            for _ in 0..len {
                                let mut sum: u64 = 0;

                                var_load!(frame, f, sum, u64, 56, 48, 40, 32, 24, 16, 8, 0);

                                let sum = unsafe { mem::transmute::<u64, i64>(sum) };
                                arr.push(sum);
                            }

                            let term = VmTerm::Signed64Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed128ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<i128> = Vec::new();
                            for _ in 0..len {
                                let mut sum: u128 = 0;

                                var_load!(
                                    frame, f, sum, u128, 120, 112, 104, 96, 88, 80, 72, 64, 56, 48,
                                    40, 32, 24, 16, 8, 0
                                );

                                let sum = unsafe { mem::transmute::<u128, i128>(sum) };
                                arr.push(sum);
                            }

                            let term = VmTerm::Signed128Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::SignedBigArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<IBig> = Vec::with_capacity(len as usize);
                            for _ in 0..len {
                                let mut term_len: u16 = 0;

                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    term_len += u16::from(*byte);
                                } else {
                                    unreachable!()
                                }
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    term_len += u16::from(*byte) << 8;
                                } else {
                                    unreachable!()
                                }

                                let mut term: Vec<u8> = Vec::with_capacity(term_len as usize);
                                for _ in 0..term_len {
                                    frame.i_ptr += 1;
                                    if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                        term.push(*byte);
                                    } else {
                                        unreachable!()
                                    }
                                }

                                if let VmTerm::SignedBig(val) =
                                    crate::codec::decode::<VmTerm>(&term).unwrap()
                                {
                                    arr.push(val);
                                } else {
                                    unreachable!()
                                }
                            }

                            let term = VmTerm::SignedBigArray(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2 * (len as u64 + 1);
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Float32ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<Float32Wrapper> = Vec::new();
                            for _ in 0..len {
                                let mut f_arr: [u8; 4] = [0; 4];

                                var_load_from_array!(frame, f, f_arr, 3, 2, 1, 0);

                                arr.push(Float32Wrapper(f32::from_le_bytes(f_arr)));
                            }

                            let term = VmTerm::Float32Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Float64ArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<Float64Wrapper> = Vec::new();
                            for _ in 0..len {
                                let mut f_arr: [u8; 8] = [0; 8];

                                var_load_from_array!(frame, f, f_arr, 7, 6, 5, 4, 3, 2, 1, 0);

                                arr.push(Float64Wrapper(f64::from_le_bytes(f_arr)));
                            }

                            let term = VmTerm::Float64Array(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::DecimalArrayVar) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let mut arr: Vec<Decimal> = Vec::new();
                            for _ in 0..len {
                                let mut d_arr: [u8; 16] = [0; 16];

                                var_load_from_array!(
                                    frame, f, d_arr, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3,
                                    2, 1, 0
                                );

                                arr.push(Decimal::deserialize(d_arr));
                            }

                            let term = VmTerm::DecimalArray(arr);
                            memory_size += term.size();
                            exec_count += term.size() as u64 + 2;
                            frame.stack.push(term);
                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Substr) => {
                            let mut len: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                len += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let arr = frame.stack.pop().unwrap();
                            let mid = len as usize;

                            if mid > arr.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let (left, right) = arr.split_at_unchecked(mid);
                                frame.stack.push(left);
                                frame.stack.push(right);

                                // The items size is already added to the memory_size of the VM,
                                // we only have to add the HEAP_SIZE for the second vector
                                memory_size += crate::vm::internal::EMPTY_VEC_HEAP_SIZE;
                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::InputScriptArgsLen) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= input_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let input = &input_stack[idx as usize];
                                frame
                                    .stack
                                    .push(VmTerm::Unsigned16(input.script_args.len() as u16));
                                memory_size += 2;
                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(
                            OP::SpillInputScriptArgs,
                        ) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= input_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let input = &input_stack[idx as usize];
                                for t in input.script_args.iter().rev() {
                                    frame.stack.push(t.clone());
                                    memory_size += t.size();
                                }
                                exec_count += input.script_args.len() as u64 + 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::SpillScriptOuts) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= output_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let output = &output_stack[idx as usize];
                                for t in output.script_outs.iter().rev() {
                                    frame.stack.push(t.clone());
                                    memory_size += t.size();
                                }
                                exec_count += output.script_outs.len() as u64;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(
                            OP::GetOutScriptOutsLen,
                        ) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= output_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let output = &output_stack[idx as usize];
                                frame
                                    .stack
                                    .push(VmTerm::Unsigned16(output.script_outs.len() as u16));
                                memory_size += 2;
                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(
                            OP::GetSpentOutScriptOut,
                        ) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let script_outs =
                                flags.spent_out.as_ref().map(|o| &o.script_outs).unwrap();

                            if idx as usize >= script_outs.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let term = &script_outs[idx as usize];
                                frame.stack.push(term.clone());
                                memory_size += term.size();
                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(
                            OP::GetInputScriptArgAt,
                        ) => {
                            let mut idx1: u16 = 0;
                            let mut idx2: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx1 += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx1 += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx2 += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx2 += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx1 as usize >= input_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let input = &input_stack[idx1 as usize];

                                if idx2 as usize >= input.script_args.len() {
                                    frame.executor.state = ScriptExecutorState::Error(
                                        ExecutionResult::IndexOutOfBounds,
                                        (
                                            frame.i_ptr,
                                            frame.func_idx,
                                            i.clone(),
                                            frame.stack.as_slice(),
                                        )
                                            .into(),
                                    );
                                } else {
                                    let term = &input.script_args[idx2 as usize];

                                    frame.stack.push(term.clone());
                                    memory_size += term.size();
                                    exec_count += 4;
                                    frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                    frame.i_ptr += 1;
                                }
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutScriptOut) => {
                            let mut idx1: u16 = 0;
                            let mut idx2: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx1 += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx1 += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx2 += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx2 += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx1 as usize >= output_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let output = &output_stack[idx1 as usize];

                                if idx2 as usize >= output.script_outs.len() {
                                    frame.executor.state = ScriptExecutorState::Error(
                                        ExecutionResult::IndexOutOfBounds,
                                        (
                                            frame.i_ptr,
                                            frame.func_idx,
                                            i.clone(),
                                            frame.stack.as_slice(),
                                        )
                                            .into(),
                                    );
                                } else {
                                    let term = &output.script_outs[idx2 as usize];

                                    frame.stack.push(term.clone());
                                    memory_size += term.size();
                                    exec_count += 4;
                                    frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                    frame.i_ptr += 1;
                                }
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutScriptHash) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= output_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let output = &output_stack[idx as usize];
                                let script_hash = output.script_hash.0;

                                frame.stack.push(VmTerm::Hash160(script_hash));
                                memory_size += 20;
                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutAmount) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= output_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let output = &output_stack[idx as usize];
                                let amount = output.amount;

                                frame.stack.push(VmTerm::Signed128(amount));
                                memory_size += 16;
                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::IsColouredOut) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= output_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let output = &output_stack[idx as usize];

                                if output.is_coloured() {
                                    frame.stack.push(VmTerm::Unsigned8(1));
                                    memory_size += 1;
                                } else {
                                    frame.stack.push(VmTerm::Unsigned8(0));
                                    memory_size += 1;
                                }

                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::ColourHash) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= output_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let output = &output_stack[idx as usize];

                                if let Some(address) = output.coloured_address.as_ref() {
                                    frame.stack.push(VmTerm::Hash160(address.colour_hash));
                                    memory_size += 20;
                                } else {
                                    frame.stack.push(VmTerm::Hash160([0; 20]));
                                    memory_size += 20;
                                }

                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutReceiver) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            if idx as usize >= output_stack.len() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::IndexOutOfBounds,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let output = &output_stack[idx as usize];

                                if let Some(receiver) = &output.coloured_address {
                                    let term = VmTerm::Unsigned8Array(receiver.address.to_vec());
                                    memory_size += term.size();
                                    frame.stack.push(term);
                                } else if let Some(receiver) = &output.address {
                                    let term = VmTerm::Unsigned8Array(receiver.0.to_vec());
                                    memory_size += term.size();
                                    frame.stack.push(term);
                                } else {
                                    // Push 0 as empty array
                                    frame.stack.push(VmTerm::Unsigned8Array(vec![]));
                                    memory_size += EMPTY_VEC_HEAP_SIZE;
                                }

                                exec_count += 2;
                                frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                frame.i_ptr += 1;
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::PushPrevScriptOuts) => {
                            let mut idx: u16 = 0;

                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte);
                            } else {
                                unreachable!()
                            }
                            frame.i_ptr += 1;
                            if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                idx += u16::from(*byte) << 8;
                            } else {
                                unreachable!()
                            }

                            let script_outs =
                                flags.spent_out.as_ref().map(|o| &o.script_outs).unwrap();
                            let terms = script_outs.iter().take(idx as usize).cloned();

                            exec_count += terms.len() as u64 + 2;

                            for t in terms {
                                memory_size += t.size();
                                frame.stack.push(t);
                            }

                            frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                            frame.i_ptr += 1;
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::CastTo) => {
                            frame.i_ptr += 1;
                            let type_id = if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                *byte
                            } else {
                                unreachable!()
                            };

                            // Pre-check type id
                            if type_id > 0x23_u8 || frame.stack.is_empty() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::InvalidArgs,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        frame.stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let top = frame.stack.pop().unwrap();
                                memory_size -= top.size();
                                exec_count += 1;

                                match (top, type_id) {
                                    // U8 casts
                                    //
                                    // Cast u8 to u8
                                    (VmTerm::Unsigned8(v), 0x03) => {
                                        frame.stack.push(VmTerm::Unsigned8(v));
                                        memory_size += 1;
                                    }
                                    // Cast u8 to u16
                                    (VmTerm::Unsigned8(v), 0x04) => {
                                        frame.stack.push(VmTerm::Unsigned16(u16::from(v)));
                                        memory_size += 2;
                                    }
                                    // Cast u8 to u32
                                    (VmTerm::Unsigned8(v), 0x05) => {
                                        frame.stack.push(VmTerm::Unsigned32(u32::from(v)));
                                        memory_size += 4;
                                    }
                                    // Cast u8 to u64
                                    (VmTerm::Unsigned8(v), 0x06) => {
                                        frame.stack.push(VmTerm::Unsigned64(u64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast u8 to u128
                                    (VmTerm::Unsigned8(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(u128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast u8 to ubig
                                    (VmTerm::Unsigned8(v), 0x08) => {
                                        let term = VmTerm::UnsignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u8 to i8
                                    (VmTerm::Unsigned8(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u8 to i16
                                    (VmTerm::Unsigned8(v), 0x0a) => {
                                        frame.stack.push(VmTerm::Signed16(i16::from(v)));
                                        memory_size += 2;
                                    }
                                    // Cast u8 to i32
                                    (VmTerm::Unsigned8(v), 0x0b) => {
                                        frame.stack.push(VmTerm::Signed32(i32::from(v)));
                                        memory_size += 4;
                                    }
                                    // Cast u8 to i64
                                    (VmTerm::Unsigned8(v), 0x0c) => {
                                        frame.stack.push(VmTerm::Signed64(i64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast u8 to i128
                                    (VmTerm::Unsigned8(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(i128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast u8 to ibig
                                    (VmTerm::Unsigned8(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u8 to f32
                                    (VmTerm::Unsigned8(v), 0x0f) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float32(Float32Wrapper(f32::from(v))));
                                        memory_size += 4;
                                    }
                                    // Cast u8 to f64
                                    (VmTerm::Unsigned8(v), 0x10) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float64(Float64Wrapper(f64::from(v))));
                                        memory_size += 8;
                                    }
                                    // Cast u8 to Decimal
                                    (VmTerm::Unsigned8(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u8 to u8 array
                                    (VmTerm::Unsigned8(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // U16 casts
                                    //
                                    // Cast u16 to u8.
                                    (VmTerm::Unsigned16(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u16 to u16
                                    (VmTerm::Unsigned16(v), 0x04) => {
                                        frame.stack.push(VmTerm::Unsigned16(v));
                                        memory_size += 2;
                                    }
                                    // Cast u16 to u32
                                    (VmTerm::Unsigned16(v), 0x05) => {
                                        frame.stack.push(VmTerm::Unsigned32(u32::from(v)));
                                        memory_size += 4;
                                    }
                                    // Cast u16 to u64
                                    (VmTerm::Unsigned16(v), 0x06) => {
                                        frame.stack.push(VmTerm::Unsigned64(u64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast u16 to u128
                                    (VmTerm::Unsigned16(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(u128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast u16 to ubig
                                    (VmTerm::Unsigned16(v), 0x08) => {
                                        let term = VmTerm::UnsignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u16 to i8
                                    (VmTerm::Unsigned16(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u16 to i16
                                    (VmTerm::Unsigned16(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u16 to i32
                                    (VmTerm::Unsigned16(v), 0x0b) => {
                                        frame.stack.push(VmTerm::Signed32(i32::from(v)));
                                        memory_size += 4;
                                    }
                                    // Cast u16 to i64
                                    (VmTerm::Unsigned16(v), 0x0c) => {
                                        frame.stack.push(VmTerm::Signed64(i64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast u16 to i128
                                    (VmTerm::Unsigned16(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(i128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast u16 to ibig
                                    (VmTerm::Unsigned16(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u16 to f32
                                    (VmTerm::Unsigned16(v), 0x0f) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float32(Float32Wrapper(f32::from(v))));
                                        memory_size += 4;
                                    }
                                    // Cast u16 to f64
                                    (VmTerm::Unsigned16(v), 0x10) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float64(Float64Wrapper(f64::from(v))));
                                        memory_size += 8;
                                    }
                                    // Cast u16 to Decimal
                                    (VmTerm::Unsigned16(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u16 to u8 array
                                    (VmTerm::Unsigned16(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u16 to u16 array
                                    (VmTerm::Unsigned16(v), 0x16) => {
                                        let term = VmTerm::Unsigned16Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // U32 casts
                                    //
                                    // Cast u32 to u8.
                                    (VmTerm::Unsigned32(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u32 to u16
                                    (VmTerm::Unsigned32(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u32 to u32
                                    (VmTerm::Unsigned32(v), 0x05) => {
                                        frame.stack.push(VmTerm::Unsigned32(v));
                                        memory_size += 4;
                                    }
                                    // Cast u32 to u64
                                    (VmTerm::Unsigned32(v), 0x06) => {
                                        frame.stack.push(VmTerm::Unsigned64(u64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast u32 to u128
                                    (VmTerm::Unsigned32(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(u128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast u32 to ubig
                                    (VmTerm::Unsigned32(v), 0x08) => {
                                        let term = VmTerm::UnsignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u32 to i8
                                    (VmTerm::Unsigned32(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u32 to i16
                                    (VmTerm::Unsigned32(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u32 to i32
                                    (VmTerm::Unsigned32(v), 0x0b) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u32 to i64
                                    (VmTerm::Unsigned32(v), 0x0c) => {
                                        frame.stack.push(VmTerm::Signed64(i64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast u32 to i128
                                    (VmTerm::Unsigned32(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(i128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast u32 to ibig
                                    (VmTerm::Unsigned32(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u32 to f32
                                    (VmTerm::Unsigned32(v), 0x0f) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float32(Float32Wrapper(v)));
                                                memory_size += 4;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast u32 to f64
                                    (VmTerm::Unsigned32(v), 0x10) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float64(Float64Wrapper(f64::from(v))));
                                        memory_size += 8;
                                    }
                                    // Cast u32 to Decimal
                                    (VmTerm::Unsigned32(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u32 to u8 array
                                    (VmTerm::Unsigned32(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u32 to u32 array
                                    (VmTerm::Unsigned32(v), 0x17) => {
                                        let term = VmTerm::Unsigned32Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // U64 casts
                                    //
                                    // Cast u64 to u8.
                                    (VmTerm::Unsigned64(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u64 to u16
                                    (VmTerm::Unsigned64(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u64 to u32
                                    (VmTerm::Unsigned64(v), 0x05) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u64 to u64
                                    (VmTerm::Unsigned64(v), 0x06) => {
                                        frame.stack.push(VmTerm::Unsigned64(v));
                                        memory_size += 8;
                                    }
                                    // Cast u64 to u128
                                    (VmTerm::Unsigned64(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(u128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast u64 to ubig
                                    (VmTerm::Unsigned64(v), 0x08) => {
                                        let term = VmTerm::UnsignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u64 to i8
                                    (VmTerm::Unsigned64(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u64 to i16
                                    (VmTerm::Unsigned64(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u64 to i32
                                    (VmTerm::Unsigned64(v), 0x0b) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u64 to i64
                                    (VmTerm::Unsigned64(v), 0x0c) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u64 to i128
                                    (VmTerm::Unsigned64(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(i128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast u64 to ibig
                                    (VmTerm::Unsigned64(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u64 to f32
                                    (VmTerm::Unsigned64(v), 0x0f) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float32(Float32Wrapper(v)));
                                                memory_size += 4;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast u64 to f64
                                    (VmTerm::Unsigned64(v), 0x10) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float64(Float64Wrapper(v)));
                                                memory_size += 4;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast u64 to Decimal
                                    (VmTerm::Unsigned64(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u64 to u8 array
                                    (VmTerm::Unsigned64(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u64 to u64 array
                                    (VmTerm::Unsigned64(v), 0x18) => {
                                        let term = VmTerm::Unsigned64Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // U128 casts
                                    //
                                    // Cast u128 to u8.
                                    (VmTerm::Unsigned128(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to u16
                                    (VmTerm::Unsigned128(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to u32
                                    (VmTerm::Unsigned128(v), 0x05) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to u64
                                    (VmTerm::Unsigned128(v), 0x06) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to u128
                                    (VmTerm::Unsigned128(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(v));
                                        memory_size += 16;
                                    }
                                    // Cast u128 to ubig
                                    (VmTerm::Unsigned128(v), 0x08) => {
                                        let term = VmTerm::UnsignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u128 to i8
                                    (VmTerm::Unsigned128(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to i16
                                    (VmTerm::Unsigned128(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to i32
                                    (VmTerm::Unsigned128(v), 0x0b) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to i64
                                    (VmTerm::Unsigned128(v), 0x0c) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to i128
                                    (VmTerm::Unsigned128(v), 0x0d) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed128(v));
                                            memory_size += 16;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast u128 to ibig
                                    (VmTerm::Unsigned128(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u128 to f32
                                    (VmTerm::Unsigned128(v), 0x0f) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float32(Float32Wrapper(v)));
                                                memory_size += 4;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast u128 to f64
                                    (VmTerm::Unsigned128(v), 0x10) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float64(Float64Wrapper(v)));
                                                memory_size += 8;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast u128 to Decimal
                                    (VmTerm::Unsigned128(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u128 to u8 array
                                    (VmTerm::Unsigned128(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast u128 to u128 array
                                    (VmTerm::Unsigned128(v), 0x19) => {
                                        let term = VmTerm::Unsigned128Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // UBIG casts
                                    //
                                    // Cast ubig to u8.
                                    (VmTerm::UnsignedBig(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to u16
                                    (VmTerm::UnsignedBig(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to u32
                                    (VmTerm::UnsignedBig(v), 0x05) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to u64
                                    (VmTerm::UnsignedBig(v), 0x06) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to u128
                                    (VmTerm::UnsignedBig(v), 0x07) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned128(v));
                                            memory_size += 16;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to ubig
                                    (VmTerm::UnsignedBig(v), 0x08) => {
                                        let term = VmTerm::UnsignedBig(v);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast ubig to i8
                                    (VmTerm::UnsignedBig(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to i16
                                    (VmTerm::UnsignedBig(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to i32
                                    (VmTerm::UnsignedBig(v), 0x0b) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to i64
                                    (VmTerm::UnsignedBig(v), 0x0c) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to i128
                                    (VmTerm::UnsignedBig(v), 0x0d) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed128(v));
                                            memory_size += 16;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ubig to ibig
                                    (VmTerm::UnsignedBig(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast ubig to f32
                                    (VmTerm::UnsignedBig(v), 0x0f) => {
                                        match TryInto::<u128>::try_into(v) {
                                            Ok(v) => {
                                                let v: Decimal = v.into();
                                                match v.try_into() {
                                                    Ok(v) => {
                                                        let term =
                                                            VmTerm::Float32(Float32Wrapper(v));
                                                        memory_size += 4;
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                }
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast ubig to f64
                                    (VmTerm::UnsignedBig(v), 0x10) => {
                                        match TryInto::<u128>::try_into(v) {
                                            Ok(v) => {
                                                let v: Decimal = v.into();
                                                match v.try_into() {
                                                    Ok(v) => {
                                                        let term =
                                                            VmTerm::Float64(Float64Wrapper(v));
                                                        memory_size += 8;
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                }
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast ubig to decimal
                                    (VmTerm::UnsignedBig(v), 0x11) => {
                                        match TryInto::<u128>::try_into(v) {
                                            Ok(v) => {
                                                let term = VmTerm::Decimal(v.into());
                                                memory_size += term.size();
                                                frame.stack.push(term);
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast ubig to u8 array
                                    (VmTerm::UnsignedBig(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast ubig to ubig array
                                    (VmTerm::UnsignedBig(v), 0x1a) => {
                                        let term = VmTerm::UnsignedBigArray(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // I8 casts
                                    //
                                    // Cast i8 to u8
                                    (VmTerm::Signed8(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i8 to u16
                                    (VmTerm::Signed8(v), 0x04) => {
                                        frame.stack.push(VmTerm::Unsigned16(v as u16));
                                        memory_size += 2;
                                    }
                                    // Cast i8 to u32
                                    (VmTerm::Signed8(v), 0x05) => {
                                        frame.stack.push(VmTerm::Unsigned32(v as u32));
                                        memory_size += 4;
                                    }
                                    // Cast i8 to u64
                                    (VmTerm::Signed8(v), 0x06) => {
                                        frame.stack.push(VmTerm::Unsigned64(v as u64));
                                        memory_size += 8;
                                    }
                                    // Cast i8 to u128
                                    (VmTerm::Signed8(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(v as u128));
                                        memory_size += 16;
                                    }
                                    // Cast i8 to ubig
                                    (VmTerm::Signed8(v), 0x08) => match v.try_into() {
                                        Ok(v) => {
                                            let term = VmTerm::UnsignedBig(v);
                                            memory_size += term.size();
                                            frame.stack.push(term);
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i8 to i8
                                    (VmTerm::Signed8(v), 0x09) => {
                                        frame.stack.push(VmTerm::Signed8(v));
                                        memory_size += 1;
                                    }
                                    // Cast i8 to i16
                                    (VmTerm::Signed8(v), 0x0a) => {
                                        frame.stack.push(VmTerm::Signed16(i16::from(v)));
                                        memory_size += 2;
                                    }
                                    // Cast i8 to i32
                                    (VmTerm::Signed8(v), 0x0b) => {
                                        frame.stack.push(VmTerm::Signed32(i32::from(v)));
                                        memory_size += 4;
                                    }
                                    // Cast i8 to i64
                                    (VmTerm::Signed8(v), 0x0c) => {
                                        frame.stack.push(VmTerm::Signed64(i64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast i8 to i128
                                    (VmTerm::Signed8(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(i128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast i8 to ibig
                                    (VmTerm::Signed8(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i8 to f32
                                    (VmTerm::Signed8(v), 0x0f) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float32(Float32Wrapper(f32::from(v))));
                                        memory_size += 4;
                                    }
                                    // Cast i8 to f64
                                    (VmTerm::Signed8(v), 0x10) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float64(Float64Wrapper(f64::from(v))));
                                        memory_size += 8;
                                    }
                                    // Cast i8 to Decimal
                                    (VmTerm::Signed8(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i8 to u8 array
                                    (VmTerm::Signed8(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i8 to i8 array
                                    (VmTerm::Signed8(v), 0x1b) => {
                                        let term = VmTerm::Signed8Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // I16 casts
                                    //
                                    // Cast i16 to u8
                                    (VmTerm::Signed16(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i16 to u16
                                    (VmTerm::Signed16(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i16 to u32
                                    (VmTerm::Signed16(v), 0x05) => {
                                        frame.stack.push(VmTerm::Unsigned32(v as u32));
                                        memory_size += 4;
                                    }
                                    // Cast i16 to u64
                                    (VmTerm::Signed16(v), 0x06) => {
                                        frame.stack.push(VmTerm::Unsigned64(v as u64));
                                        memory_size += 8;
                                    }
                                    // Cast i16 to u128
                                    (VmTerm::Signed16(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(v as u128));
                                        memory_size += 16;
                                    }
                                    // Cast i16 to ubig
                                    (VmTerm::Signed16(v), 0x08) => match v.try_into() {
                                        Ok(v) => {
                                            let term = VmTerm::UnsignedBig(v);
                                            memory_size += term.size();
                                            frame.stack.push(term);
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i16 to i8
                                    (VmTerm::Signed16(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i16 to i16
                                    (VmTerm::Signed16(v), 0x0a) => {
                                        frame.stack.push(VmTerm::Signed16(v));
                                        memory_size += 2;
                                    }
                                    // Cast i16 to i32
                                    (VmTerm::Signed16(v), 0x0b) => {
                                        frame.stack.push(VmTerm::Signed32(i32::from(v)));
                                        memory_size += 4;
                                    }
                                    // Cast i16 to i64
                                    (VmTerm::Signed16(v), 0x0c) => {
                                        frame.stack.push(VmTerm::Signed64(i64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast i16 to i128
                                    (VmTerm::Signed16(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(i128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast i16 to ibig
                                    (VmTerm::Signed16(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i16 to f32
                                    (VmTerm::Signed16(v), 0x0f) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float32(Float32Wrapper(f32::from(v))));
                                        memory_size += 4;
                                    }
                                    // Cast i16 to f64
                                    (VmTerm::Signed16(v), 0x10) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float64(Float64Wrapper(f64::from(v))));
                                        memory_size += 8;
                                    }
                                    // Cast i16 to Decimal
                                    (VmTerm::Signed16(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i16 to u8 array
                                    (VmTerm::Signed16(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i16 to i16 array
                                    (VmTerm::Signed16(v), 0x1c) => {
                                        let term = VmTerm::Signed16Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // I32 casts
                                    //
                                    // Cast i32 to u8
                                    (VmTerm::Signed32(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i32 to u16
                                    (VmTerm::Signed32(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i32 to u32
                                    (VmTerm::Signed32(v), 0x05) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i32 to u64
                                    (VmTerm::Signed32(v), 0x06) => {
                                        frame.stack.push(VmTerm::Unsigned64(v as u64));
                                        memory_size += 8;
                                    }
                                    // Cast i32 to u128
                                    (VmTerm::Signed32(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(v as u128));
                                        memory_size += 16;
                                    }
                                    // Cast i32 to ubig
                                    (VmTerm::Signed32(v), 0x08) => match v.try_into() {
                                        Ok(v) => {
                                            let term = VmTerm::UnsignedBig(v);
                                            memory_size += term.size();
                                            frame.stack.push(term);
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i32 to i8
                                    (VmTerm::Signed32(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i32 to i16
                                    (VmTerm::Signed32(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i32 to i32
                                    (VmTerm::Signed32(v), 0x0b) => {
                                        frame.stack.push(VmTerm::Signed32(v));
                                        memory_size += 4;
                                    }
                                    // Cast i32 to i64
                                    (VmTerm::Signed32(v), 0x0c) => {
                                        frame.stack.push(VmTerm::Signed64(i64::from(v)));
                                        memory_size += 8;
                                    }
                                    // Cast i32 to i128
                                    (VmTerm::Signed32(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(i128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast i32 to ibig
                                    (VmTerm::Signed32(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i32 to f32
                                    (VmTerm::Signed32(v), 0x0f) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float32(Float32Wrapper(v)));
                                                memory_size += 4;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast i32 to f64
                                    (VmTerm::Signed32(v), 0x10) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float64(Float64Wrapper(f64::from(v))));
                                        memory_size += 8;
                                    }
                                    // Cast i32 to Decimal
                                    (VmTerm::Signed32(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i32 to u8 array
                                    (VmTerm::Signed32(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i32 to i32 array
                                    (VmTerm::Signed32(v), 0x1d) => {
                                        let term = VmTerm::Signed32Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // I64 casts
                                    //
                                    // Cast i64 to u8
                                    (VmTerm::Signed64(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i64 to u16
                                    (VmTerm::Signed64(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i64 to u32
                                    (VmTerm::Signed64(v), 0x05) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i64 to u64
                                    (VmTerm::Signed64(v), 0x06) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i64 to u128
                                    (VmTerm::Signed64(v), 0x07) => {
                                        frame.stack.push(VmTerm::Unsigned128(v as u128));
                                        memory_size += 16;
                                    }
                                    // Cast i64 to ubig
                                    (VmTerm::Signed64(v), 0x08) => match v.try_into() {
                                        Ok(v) => {
                                            let term = VmTerm::UnsignedBig(v);
                                            memory_size += term.size();
                                            frame.stack.push(term);
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i64 to i8
                                    (VmTerm::Signed64(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i64 to i16
                                    (VmTerm::Signed64(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i64 to i32
                                    (VmTerm::Signed64(v), 0x0b) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i64 to i64
                                    (VmTerm::Signed64(v), 0x0c) => {
                                        frame.stack.push(VmTerm::Signed64(v));
                                        memory_size += 8;
                                    }
                                    // Cast i64 to i128
                                    (VmTerm::Signed64(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(i128::from(v)));
                                        memory_size += 16;
                                    }
                                    // Cast i64 to ibig
                                    (VmTerm::Signed64(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i64 to f32
                                    (VmTerm::Signed64(v), 0x0f) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float32(Float32Wrapper(v)));
                                                memory_size += 4;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast i64 to f64
                                    (VmTerm::Signed64(v), 0x10) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float64(Float64Wrapper(v)));
                                                memory_size += 8;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast i64 to Decimal
                                    (VmTerm::Signed64(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i64 to u8 array
                                    (VmTerm::Signed64(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i64 to i64 array
                                    (VmTerm::Signed64(v), 0x1e) => {
                                        let term = VmTerm::Signed64Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // I128 casts
                                    //
                                    // Cast i128 to u8
                                    (VmTerm::Signed128(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to u16
                                    (VmTerm::Signed128(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to u32
                                    (VmTerm::Signed128(v), 0x05) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to u64
                                    (VmTerm::Signed128(v), 0x06) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to u128
                                    (VmTerm::Signed128(v), 0x07) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned128(v));
                                            memory_size += 16;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to ubig
                                    (VmTerm::Signed128(v), 0x08) => match v.try_into() {
                                        Ok(v) => {
                                            let term = VmTerm::UnsignedBig(v);
                                            memory_size += term.size();
                                            frame.stack.push(term);
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to i8
                                    (VmTerm::Signed128(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to i16
                                    (VmTerm::Signed128(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to i32
                                    (VmTerm::Signed128(v), 0x0b) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to i64
                                    (VmTerm::Signed128(v), 0x0c) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast i128 to i128
                                    (VmTerm::Signed128(v), 0x0d) => {
                                        frame.stack.push(VmTerm::Signed128(v));
                                        memory_size += 16;
                                    }
                                    // Cast i128 to ibig
                                    (VmTerm::Signed128(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i128 to f32
                                    (VmTerm::Signed128(v), 0x0f) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float32(Float32Wrapper(v)));
                                                memory_size += 4;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast i128 to f64
                                    (VmTerm::Signed128(v), 0x10) => {
                                        let v: Decimal = v.into();
                                        match v.try_into() {
                                            Ok(v) => {
                                                frame
                                                    .stack
                                                    .push(VmTerm::Float64(Float64Wrapper(v)));
                                                memory_size += 8;
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast i128 to Decimal
                                    (VmTerm::Signed128(v), 0x11) => {
                                        let term = VmTerm::Decimal(v.into());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i128 to u8 array
                                    (VmTerm::Signed128(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast i128 to i128 array
                                    (VmTerm::Signed128(v), 0x1f) => {
                                        let term = VmTerm::Signed128Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // IBIG casts
                                    //
                                    // Cast ibig to u8.
                                    (VmTerm::SignedBig(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to u16
                                    (VmTerm::SignedBig(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to u32
                                    (VmTerm::SignedBig(v), 0x05) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to u64
                                    (VmTerm::SignedBig(v), 0x06) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to u128
                                    (VmTerm::SignedBig(v), 0x07) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned128(v));
                                            memory_size += 16;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to ubig
                                    (VmTerm::SignedBig(v), 0x08) => match v.try_into() {
                                        Ok(v) => {
                                            let term = VmTerm::UnsignedBig(v);
                                            memory_size += term.size();
                                            frame.stack.push(term);
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to i8
                                    (VmTerm::SignedBig(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to i16
                                    (VmTerm::SignedBig(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to i32
                                    (VmTerm::SignedBig(v), 0x0b) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to i64
                                    (VmTerm::SignedBig(v), 0x0c) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to i128
                                    (VmTerm::SignedBig(v), 0x0d) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed128(v));
                                            memory_size += 16;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast ibig to ibig
                                    (VmTerm::SignedBig(v), 0x0e) => {
                                        let term = VmTerm::SignedBig(v);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast ibig to f32
                                    (VmTerm::SignedBig(v), 0x0f) => {
                                        match TryInto::<i128>::try_into(v) {
                                            Ok(v) => {
                                                let v: Decimal = v.into();
                                                match v.try_into() {
                                                    Ok(v) => {
                                                        let term =
                                                            VmTerm::Float32(Float32Wrapper(v));
                                                        memory_size += 4;
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                }
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast ibig to f64
                                    (VmTerm::SignedBig(v), 0x10) => {
                                        match TryInto::<i128>::try_into(v) {
                                            Ok(v) => {
                                                let v: Decimal = v.into();
                                                match v.try_into() {
                                                    Ok(v) => {
                                                        let term =
                                                            VmTerm::Float64(Float64Wrapper(v));
                                                        memory_size += 8;
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                }
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast ibig to decimal
                                    (VmTerm::SignedBig(v), 0x11) => {
                                        match TryInto::<i128>::try_into(v) {
                                            Ok(v) => {
                                                let term = VmTerm::Decimal(v.into());
                                                memory_size += term.size();
                                                frame.stack.push(term);
                                            }
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast ibig to u8 array
                                    (VmTerm::SignedBig(v), 0x15) => {
                                        let sign = v.signum().to_f32() as i8;
                                        let v = v.abs();

                                        let bytes = match sign {
                                            -1 => {
                                                let mut buf = vec![0x0e_u8];
                                                let v: UBig = v.try_into().unwrap();
                                                let bytes = v.to_le_bytes();
                                                buf.extend_from_slice(&bytes);
                                                buf
                                            }

                                            1 => {
                                                let mut buf = vec![0x0f_u8];
                                                let v: UBig = v.try_into().unwrap();
                                                let bytes = v.to_le_bytes();
                                                buf.extend_from_slice(&bytes);
                                                buf
                                            }

                                            0 => {
                                                vec![0x10_u8]
                                            }

                                            _ => unreachable!(),
                                        };

                                        let term = VmTerm::Unsigned8Array(bytes);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast ibig to ibig array
                                    (VmTerm::SignedBig(v), 0x20) => {
                                        let term = VmTerm::SignedBigArray(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // Decimal casts
                                    //
                                    // Cast decimal to u8.
                                    (VmTerm::Decimal(v), 0x03) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to u16
                                    (VmTerm::Decimal(v), 0x04) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to u32
                                    (VmTerm::Decimal(v), 0x05) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to u64
                                    (VmTerm::Decimal(v), 0x06) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to u128
                                    (VmTerm::Decimal(v), 0x07) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Unsigned128(v));
                                            memory_size += 16;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to ubig
                                    (VmTerm::Decimal(v), 0x08) => {
                                        match TryInto::<u128>::try_into(v) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    let term = VmTerm::UnsignedBig(v);
                                                    memory_size += term.size();
                                                    frame.stack.push(term);
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast decimal to i8
                                    (VmTerm::Decimal(v), 0x09) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed8(v));
                                            memory_size += 1;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to i16
                                    (VmTerm::Decimal(v), 0x0a) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed16(v));
                                            memory_size += 2;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to i32
                                    (VmTerm::Decimal(v), 0x0b) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed32(v));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to i64
                                    (VmTerm::Decimal(v), 0x0c) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed64(v));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to i128
                                    (VmTerm::Decimal(v), 0x0d) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Signed128(v));
                                            memory_size += 16;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast decimal to ibig
                                    (VmTerm::Decimal(v), 0x0e) => {
                                        match TryInto::<i128>::try_into(v) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    let term = VmTerm::SignedBig(v);
                                                    memory_size += term.size();
                                                    frame.stack.push(term);
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast Decimal to f32
                                    (VmTerm::Decimal(v), 0x0f) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Float32(Float32Wrapper(v)));
                                            memory_size += 4;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast Decimal to f64
                                    (VmTerm::Decimal(v), 0x10) => match v.try_into() {
                                        Ok(v) => {
                                            frame.stack.push(VmTerm::Float64(Float64Wrapper(v)));
                                            memory_size += 8;
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast Decimal to Decimal
                                    (VmTerm::Decimal(v), 0x11) => {
                                        let term = VmTerm::Decimal(v);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast decimal to u8 array
                                    (VmTerm::Decimal(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.serialize().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast decimal to decimal array
                                    (VmTerm::Decimal(v), 0x23) => {
                                        let term = VmTerm::DecimalArray(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // Float32 casts
                                    //
                                    // Cast f32 to u8.
                                    (VmTerm::Float32(v), 0x03) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned8(v));
                                                    memory_size += 1;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to u16
                                    (VmTerm::Float32(v), 0x04) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned16(v));
                                                    memory_size += 2;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to u32
                                    (VmTerm::Float32(v), 0x05) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned32(v));
                                                    memory_size += 4;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to u64
                                    (VmTerm::Float32(v), 0x06) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned64(v));
                                                    memory_size += 8;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to u128
                                    (VmTerm::Float32(v), 0x07) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned128(v));
                                                    memory_size += 16;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to ubig
                                    (VmTerm::Float32(v), 0x08) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match TryInto::<u128>::try_into(v) {
                                                Ok(v) => match v.try_into() {
                                                    Ok(v) => {
                                                        let term = VmTerm::UnsignedBig(v);
                                                        memory_size += term.size();
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                },
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to i8
                                    (VmTerm::Float32(v), 0x09) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed8(v));
                                                    memory_size += 1;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to i16
                                    (VmTerm::Float32(v), 0x0a) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed16(v));
                                                    memory_size += 2;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to i32
                                    (VmTerm::Float32(v), 0x0b) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed32(v));
                                                    memory_size += 4;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to i64
                                    (VmTerm::Float32(v), 0x0c) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed64(v));
                                                    memory_size += 8;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to i128
                                    (VmTerm::Float32(v), 0x0d) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed128(v));
                                                    memory_size += 16;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to ibig
                                    (VmTerm::Float32(v), 0x0e) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match TryInto::<i128>::try_into(v) {
                                                Ok(v) => match v.try_into() {
                                                    Ok(v) => {
                                                        let term = VmTerm::SignedBig(v);
                                                        memory_size += term.size();
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                },
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f32 to f32
                                    (VmTerm::Float32(v), 0x0f) => {
                                        frame.stack.push(VmTerm::Float32(v));
                                        memory_size += 4;
                                    }
                                    // Cast f32 to f64
                                    (VmTerm::Float32(v), 0x10) => {
                                        frame
                                            .stack
                                            .push(VmTerm::Float64(Float64Wrapper(v.0.into())));
                                        memory_size += 8;
                                    }
                                    // Cast f32 to Decimal
                                    (VmTerm::Float32(v), 0x11) => match v.0.try_into() {
                                        Ok(v) => {
                                            let term = VmTerm::Decimal(v);
                                            memory_size += term.size();
                                            frame.stack.push(term);
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast f32 to u8 array
                                    (VmTerm::Float32(v), 0x15) => {
                                        let term =
                                            VmTerm::Unsigned8Array(v.0.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast f32 to f32 array
                                    (VmTerm::Float32(v), 0x21) => {
                                        let term = VmTerm::Float32Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // Float64 casts
                                    //
                                    // Cast f64 to u8.
                                    (VmTerm::Float64(v), 0x03) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned8(v));
                                                    memory_size += 1;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to u16
                                    (VmTerm::Float64(v), 0x04) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned16(v));
                                                    memory_size += 2;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to u32
                                    (VmTerm::Float64(v), 0x05) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned32(v));
                                                    memory_size += 4;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to u64
                                    (VmTerm::Float64(v), 0x06) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned64(v));
                                                    memory_size += 8;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to u128
                                    (VmTerm::Float64(v), 0x07) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Unsigned128(v));
                                                    memory_size += 16;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to ubig
                                    (VmTerm::Float64(v), 0x08) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match TryInto::<u128>::try_into(v) {
                                                Ok(v) => match v.try_into() {
                                                    Ok(v) => {
                                                        let term = VmTerm::UnsignedBig(v);
                                                        memory_size += term.size();
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                },
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to i8
                                    (VmTerm::Float64(v), 0x09) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed8(v));
                                                    memory_size += 1;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to i16
                                    (VmTerm::Float64(v), 0x0a) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed16(v));
                                                    memory_size += 2;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to i32
                                    (VmTerm::Float64(v), 0x0b) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed32(v));
                                                    memory_size += 4;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to i64
                                    (VmTerm::Float64(v), 0x0c) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed64(v));
                                                    memory_size += 8;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to i128
                                    (VmTerm::Float64(v), 0x0d) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame.stack.push(VmTerm::Signed128(v));
                                                    memory_size += 16;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to ibig
                                    (VmTerm::Float64(v), 0x0e) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match TryInto::<i128>::try_into(v) {
                                                Ok(v) => match v.try_into() {
                                                    Ok(v) => {
                                                        let term = VmTerm::SignedBig(v);
                                                        memory_size += term.size();
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                },
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to f32
                                    (VmTerm::Float64(v), 0x0f) => {
                                        match TryInto::<Decimal>::try_into(v.0) {
                                            Ok(v) => match v.try_into() {
                                                Ok(v) => {
                                                    frame
                                                        .stack
                                                        .push(VmTerm::Float32(Float32Wrapper(v)));
                                                    memory_size += 4;
                                                }
                                                _ => {
                                                    frame.executor.state =
                                                        ScriptExecutorState::Error(
                                                            ExecutionResult::InvalidCast,
                                                            (
                                                                frame.i_ptr,
                                                                frame.func_idx,
                                                                i.clone(),
                                                                frame.stack.as_slice(),
                                                            )
                                                                .into(),
                                                        );
                                                }
                                            },
                                            _ => {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            }
                                        }
                                    }
                                    // Cast f64 to f64
                                    (VmTerm::Float64(v), 0x10) => {
                                        frame.stack.push(VmTerm::Float64(v));
                                        memory_size += 8;
                                    }
                                    // Cast f64 to Decimal
                                    (VmTerm::Float64(v), 0x11) => match v.0.try_into() {
                                        Ok(v) => {
                                            let term = VmTerm::Decimal(v);
                                            memory_size += term.size();
                                            frame.stack.push(term);
                                        }
                                        _ => {
                                            frame.executor.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidCast,
                                                (
                                                    frame.i_ptr,
                                                    frame.func_idx,
                                                    i.clone(),
                                                    frame.stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    },
                                    // Cast f64 to u8 array
                                    (VmTerm::Float64(v), 0x15) => {
                                        let term =
                                            VmTerm::Unsigned8Array(v.0.to_le_bytes().to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast f64 to f32 array
                                    (VmTerm::Float64(v), 0x22) => {
                                        let term = VmTerm::Float64Array(vec![v]);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // Hash160 casts
                                    //
                                    // Cast Hash160 to U8Array
                                    (VmTerm::Hash160(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // Hash256 casts
                                    //
                                    // Cast Hash256 to U8Array
                                    (VmTerm::Hash256(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast Hash256 to Hash160
                                    (VmTerm::Hash256(v), 0x00) => {
                                        let mut buf = [0; 20];
                                        buf.copy_from_slice(&v[..20]);
                                        let term = VmTerm::Hash160(buf);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // Hash512 casts
                                    //
                                    // Cast Hash512 to U8Array
                                    (VmTerm::Hash512(v), 0x15) => {
                                        let term = VmTerm::Unsigned8Array(v.to_vec());
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast Hash512 to Hash160
                                    (VmTerm::Hash512(v), 0x00) => {
                                        let mut buf = [0; 20];
                                        buf.copy_from_slice(&v[..20]);
                                        let term = VmTerm::Hash160(buf);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast Hash512 to Hash256
                                    (VmTerm::Hash512(v), 0x01) => {
                                        let mut buf = [0; 32];
                                        buf.copy_from_slice(&v[..32]);
                                        let term = VmTerm::Hash256(buf);
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    // Unsigned8Array casts
                                    //
                                    // Cast Unsigned8Array to Hash160
                                    (VmTerm::Unsigned8Array(v), 0x00) if v.len() == 20 => {
                                        let mut bytes = [0; 20];
                                        bytes.copy_from_slice(&v);
                                        frame.stack.push(VmTerm::Hash160(bytes));
                                        memory_size += 20;
                                    }
                                    // Cast Unsigned8Array to Hash256
                                    (VmTerm::Unsigned8Array(v), 0x01) if v.len() == 32 => {
                                        let mut bytes = [0; 32];
                                        bytes.copy_from_slice(&v);
                                        frame.stack.push(VmTerm::Hash256(bytes));
                                        memory_size += 32;
                                    }
                                    // Cast Unsigned8Array to Hash512
                                    (VmTerm::Unsigned8Array(v), 0x02) if v.len() == 64 => {
                                        let mut bytes = [0; 64];
                                        bytes.copy_from_slice(&v);
                                        frame.stack.push(VmTerm::Hash512(bytes));
                                        memory_size += 64;
                                    }
                                    // Cast Unsigned8Array to u8
                                    (VmTerm::Unsigned8Array(v), 0x03) if v.len() == 1 => {
                                        frame.stack.push(VmTerm::Unsigned8(v[0]));
                                        memory_size += 1;
                                    }
                                    // Cast Unsigned8Array to u16
                                    (VmTerm::Unsigned8Array(v), 0x04) if v.len() == 2 => {
                                        let mut bytes = [0; 2];
                                        bytes.copy_from_slice(&v);
                                        frame
                                            .stack
                                            .push(VmTerm::Unsigned16(u16::from_le_bytes(bytes)));
                                        memory_size += 2;
                                    }
                                    // Cast Unsigned8Array to u32
                                    (VmTerm::Unsigned8Array(v), 0x05) if v.len() == 4 => {
                                        let mut bytes = [0; 4];
                                        bytes.copy_from_slice(&v);
                                        frame
                                            .stack
                                            .push(VmTerm::Unsigned32(u32::from_le_bytes(bytes)));
                                        memory_size += 4;
                                    }
                                    // Cast Unsigned8Array to u64
                                    (VmTerm::Unsigned8Array(v), 0x06) if v.len() == 8 => {
                                        let mut bytes = [0; 8];
                                        bytes.copy_from_slice(&v);
                                        frame
                                            .stack
                                            .push(VmTerm::Unsigned64(u64::from_le_bytes(bytes)));
                                        memory_size += 8;
                                    }
                                    // Cast Unsigned8Array to u128
                                    (VmTerm::Unsigned8Array(v), 0x07) if v.len() == 16 => {
                                        let mut bytes = [0; 16];
                                        bytes.copy_from_slice(&v);
                                        frame
                                            .stack
                                            .push(VmTerm::Unsigned128(u128::from_le_bytes(bytes)));
                                        memory_size += 16;
                                    }
                                    // Cast Unsigned8Array to ubig
                                    (VmTerm::Unsigned8Array(v), 0x08) => {
                                        let term = VmTerm::UnsignedBig(UBig::from_le_bytes(&v));
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }
                                    // Cast Unsigned8Array to i8
                                    (VmTerm::Unsigned8Array(v), 0x09) if v.len() == 1 => {
                                        let mut bytes = [0; 1];
                                        bytes[0] = v[0];
                                        frame.stack.push(VmTerm::Signed8(i8::from_le_bytes(bytes)));
                                        memory_size += 1;
                                    }
                                    // Cast Unsigned8Array to i16
                                    (VmTerm::Unsigned8Array(v), 0x0a) if v.len() == 2 => {
                                        let mut bytes = [0; 2];
                                        bytes.copy_from_slice(&v);
                                        frame
                                            .stack
                                            .push(VmTerm::Signed16(i16::from_le_bytes(bytes)));
                                        memory_size += 2;
                                    }
                                    // Cast Unsigned8Array to i32
                                    (VmTerm::Unsigned8Array(v), 0x0b) if v.len() == 4 => {
                                        let mut bytes = [0; 4];
                                        bytes.copy_from_slice(&v);
                                        frame
                                            .stack
                                            .push(VmTerm::Signed32(i32::from_le_bytes(bytes)));
                                        memory_size += 4;
                                    }
                                    // Cast Unsigned8Array to i64
                                    (VmTerm::Unsigned8Array(v), 0x0c) if v.len() == 8 => {
                                        let mut bytes = [0; 8];
                                        bytes.copy_from_slice(&v);
                                        frame
                                            .stack
                                            .push(VmTerm::Signed64(i64::from_le_bytes(bytes)));
                                        memory_size += 8;
                                    }
                                    // Cast Unsigned8Array to i128
                                    (VmTerm::Unsigned8Array(v), 0x0d) if v.len() == 16 => {
                                        let mut bytes = [0; 16];
                                        bytes.copy_from_slice(&v);
                                        frame
                                            .stack
                                            .push(VmTerm::Signed128(i128::from_le_bytes(bytes)));
                                        memory_size += 16;
                                    }
                                    // Cast Unsigned8Array to ibig
                                    (VmTerm::Unsigned8Array(v), 0x0e) => {
                                        if !v.is_empty() {
                                            let sign = v[0];

                                            // Zero must be a single byte
                                            if sign == 0x10 && v.len() > 1 {
                                                frame.executor.state = ScriptExecutorState::Error(
                                                    ExecutionResult::InvalidCast,
                                                    (
                                                        frame.i_ptr,
                                                        frame.func_idx,
                                                        i.clone(),
                                                        frame.stack.as_slice(),
                                                    )
                                                        .into(),
                                                );
                                            } else {
                                                let v = UBig::from_le_bytes(&v[1..]);

                                                match sign {
                                                    // Negative
                                                    0x0e => match v.try_into() {
                                                        Ok(v) => {
                                                            let mut v: IBig = v;
                                                            v = v * ibig!(-1);
                                                            let term = VmTerm::SignedBig(v);
                                                            memory_size += term.size();
                                                            frame.stack.push(term);
                                                        }
                                                        _ => {
                                                            frame.executor.state =
                                                                ScriptExecutorState::Error(
                                                                    ExecutionResult::InvalidCast,
                                                                    (
                                                                        frame.i_ptr,
                                                                        frame.func_idx,
                                                                        i.clone(),
                                                                        frame.stack.as_slice(),
                                                                    )
                                                                        .into(),
                                                                );
                                                        }
                                                    },
                                                    // Positive
                                                    0x0f => match v.try_into() {
                                                        Ok(v) => {
                                                            let term = VmTerm::SignedBig(v);
                                                            memory_size += term.size();
                                                            frame.stack.push(term);
                                                        }
                                                        _ => {
                                                            frame.executor.state =
                                                                ScriptExecutorState::Error(
                                                                    ExecutionResult::InvalidCast,
                                                                    (
                                                                        frame.i_ptr,
                                                                        frame.func_idx,
                                                                        i.clone(),
                                                                        frame.stack.as_slice(),
                                                                    )
                                                                        .into(),
                                                                );
                                                        }
                                                    },
                                                    // Zero
                                                    0x10 => {
                                                        let term = VmTerm::SignedBig(ibig!(0));
                                                        memory_size += term.size();
                                                        frame.stack.push(term);
                                                    }
                                                    _ => {
                                                        frame.executor.state =
                                                            ScriptExecutorState::Error(
                                                                ExecutionResult::InvalidCast,
                                                                (
                                                                    frame.i_ptr,
                                                                    frame.func_idx,
                                                                    i.clone(),
                                                                    frame.stack.as_slice(),
                                                                )
                                                                    .into(),
                                                            );
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // Cast Unsigned8Array to f32
                                    (VmTerm::Unsigned8Array(v), 0x0f) if v.len() == 4 => {
                                        let mut bytes = [0; 4];
                                        bytes.copy_from_slice(&v);
                                        let term = VmTerm::Float32(Float32Wrapper(
                                            f32::from_le_bytes(bytes),
                                        ));
                                        frame.stack.push(term);
                                        memory_size += 4;
                                    }
                                    // Cast Unsigned8Array to f64
                                    (VmTerm::Unsigned8Array(v), 0x10) if v.len() == 8 => {
                                        let mut bytes = [0; 8];
                                        bytes.copy_from_slice(&v);
                                        let term = VmTerm::Float64(Float64Wrapper(
                                            f64::from_le_bytes(bytes),
                                        ));
                                        frame.stack.push(term);
                                        memory_size += 8;
                                    }
                                    // Cast Unsigned8Array to decimal
                                    (VmTerm::Unsigned8Array(v), 0x11) if v.len() == 16 => {
                                        let mut bytes = [0; 16];
                                        bytes.copy_from_slice(&v);
                                        let term = VmTerm::Decimal(Decimal::deserialize(bytes));
                                        memory_size += term.size();
                                        frame.stack.push(term);
                                    }

                                    _ => {
                                        frame.executor.state = ScriptExecutorState::Error(
                                            ExecutionResult::InvalidCast,
                                            (
                                                frame.i_ptr,
                                                frame.func_idx,
                                                i.clone(),
                                                frame.stack.as_slice(),
                                            )
                                                .into(),
                                        );
                                    }
                                }

                                // Check if we've had an exception
                                if !matches!(frame.executor.state, ScriptExecutorState::Error(..)) {
                                    frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                    frame.i_ptr += 1;
                                }
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetAtArray) => {
                            let exec_stack = &mut frame.stack;
                            let len: usize = exec_stack.len();

                            if len == 0 || !exec_stack[len - 1].is_array() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::InvalidArgs,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        exec_stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let mut idx: u16 = 0;

                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    idx += u16::from(*byte);
                                } else {
                                    unreachable!()
                                }
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    idx += u16::from(*byte) << 8;
                                } else {
                                    unreachable!()
                                }

                                let idx: usize = idx as usize;
                                if idx >= exec_stack[len - 1].len() {
                                    frame.executor.state = ScriptExecutorState::Error(
                                        ExecutionResult::IndexOutOfBounds,
                                        (
                                            frame.i_ptr,
                                            frame.func_idx,
                                            i.clone(),
                                            exec_stack.as_slice(),
                                        )
                                            .into(),
                                    );
                                } else {
                                    let cloned = exec_stack[len - 1].clone_at_unchecked(idx);
                                    memory_size += cloned.size();
                                    exec_stack.push(cloned);
                                    exec_count += 2;
                                    frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                    frame.i_ptr += 1;
                                }
                            }
                        }

                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::DeleteAtArray) => {
                            let exec_stack = &mut frame.stack;
                            let len: usize = exec_stack.len();

                            if len == 0 || !exec_stack[len - 1].is_array() {
                                frame.executor.state = ScriptExecutorState::Error(
                                    ExecutionResult::InvalidArgs,
                                    (
                                        frame.i_ptr,
                                        frame.func_idx,
                                        i.clone(),
                                        exec_stack.as_slice(),
                                    )
                                        .into(),
                                );
                            } else {
                                let mut idx: u16 = 0;

                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    idx += u16::from(*byte);
                                } else {
                                    unreachable!()
                                }
                                frame.i_ptr += 1;
                                if let ScriptEntry::Byte(byte) = &f[frame.i_ptr] {
                                    idx += u16::from(*byte) << 8;
                                } else {
                                    unreachable!()
                                }

                                let idx: usize = idx as usize;
                                if idx >= exec_stack[len - 1].len() {
                                    frame.executor.state = ScriptExecutorState::Error(
                                        ExecutionResult::IndexOutOfBounds,
                                        (
                                            frame.i_ptr,
                                            frame.func_idx,
                                            i.clone(),
                                            exec_stack.as_slice(),
                                        )
                                            .into(),
                                    );
                                } else {
                                    let removed = exec_stack[len - 1].remove_at_unchecked(idx);
                                    memory_size -= removed.size();
                                    exec_count += 2;
                                    frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                                    frame.i_ptr += 1;
                                }
                            }
                        }

                        // Extend stack trace
                        ScriptExecutorState::Error(err, stack_trace) => {
                            let mut stack_trace = stack_trace.clone();
                            frame.executor.state = ScriptExecutorState::Error(*err, stack_trace);
                        }

                        _ => {
                            frame.i_ptr += 1;
                        }
                    }
                }
            } else {
                unreachable!();
            }

            // Check if we are done
            match frame_stack.last().unwrap().executor.done() {
                None => {}
                Some(result) => match result {
                    Ok(res) => return Ok(res).into(),
                    Err((result, mut stack_trace)) => {
                        let fs_len = frame_stack.len();

                        if flags.build_stacktrace {
                            stack_trace.extend_from_frame_stack(&frame_stack[..fs_len - 1], self);
                        }

                        return Err((result, stack_trace)).into();
                    }
                },
            }

            if exec_count > SCRIPT_GAS_LIMIT {
                let mut stack_trace = StackTrace::default();
                let i_ptr = frame_stack.last().unwrap().i_ptr;
                let fs_len = frame_stack.len();

                if flags.build_stacktrace {
                    stack_trace.trace.push(
                        (
                            i_ptr,
                            frame_stack.last().unwrap().func_idx,
                            self.script[i_ptr].clone(),
                        )
                            .into(),
                    );
                    stack_trace.extend_from_frame_stack(&frame_stack[..fs_len - 1], self);
                }
                return Err((ExecutionResult::OutOfGas, stack_trace)).into();
            }

            if memory_size > MEMORY_SIZE {
                let mut stack_trace = StackTrace::default();
                let i_ptr = frame_stack.last().unwrap().i_ptr;
                let fs_len = frame_stack.len();

                if flags.build_stacktrace {
                    stack_trace.trace.push(
                        (
                            i_ptr,
                            frame_stack.last().unwrap().func_idx,
                            self.script[i_ptr].clone(),
                        )
                            .into(),
                    );
                    stack_trace.extend_from_frame_stack(&frame_stack[..fs_len - 1], self);
                }

                return Err((ExecutionResult::OutOfMemory, stack_trace)).into();
            }

            if pop_frame {
                let frame = frame_stack.pop().unwrap();
                let fs_len = frame_stack.len();

                // Check the top of the stack for the execution result
                if fs_len == 0 {
                    if frame.stack.is_empty() {
                        let mut stack_trace = StackTrace::default();
                        if flags.build_stacktrace {
                            stack_trace.trace.push(
                                (
                                    frame.i_ptr - 1,
                                    frame.func_idx,
                                    self.script[frame.i_ptr - 1].clone(),
                                )
                                    .into(),
                            );
                        }
                        return Err((ExecutionResult::Invalid, stack_trace)).into();
                    }

                    let top = &frame.stack[0];

                    match top {
                        VmTerm::Signed8(v) => {
                            check_top_stack_val!(v, frame, frame_stack, self, &flags);
                        }
                        VmTerm::Signed16(v) => {
                            check_top_stack_val!(v, frame, frame_stack, self, &flags);
                        }
                        VmTerm::Signed32(v) => {
                            check_top_stack_val!(v, frame, frame_stack, self, &flags);
                        }
                        VmTerm::Signed64(v) => {
                            check_top_stack_val!(v, frame, frame_stack, self, &flags);
                        }
                        VmTerm::Signed128(v) => {
                            check_top_stack_val!(v, frame, frame_stack, self, &flags);
                        }
                        VmTerm::SignedBig(v) => {
                            if v == &ibig!(1) {
                                return Ok(ExecutionResult::Ok).into();
                            }

                            let mut stack_trace = StackTrace::default();

                            if flags.build_stacktrace {
                                stack_trace.trace.push(
                                    (
                                        frame.i_ptr - 1,
                                        frame.func_idx,
                                        self.script[frame.i_ptr - 1].clone(),
                                    )
                                        .into(),
                                );
                                stack_trace.top_frame_stack.extend_from_slice(&frame.stack);
                                stack_trace.extend_from_frame_stack(&frame_stack, self);
                            }

                            return Err((ExecutionResult::Invalid, stack_trace)).into();
                        }
                        _ => {
                            let mut stack_trace = StackTrace::default();

                            if flags.build_stacktrace {
                                stack_trace.trace.push(
                                    (
                                        frame.i_ptr - 1,
                                        frame.func_idx,
                                        self.script[frame.i_ptr - 1].clone(),
                                    )
                                        .into(),
                                );
                                stack_trace.extend_from_frame_stack(&frame_stack, self);
                            }

                            return Err((ExecutionResult::Invalid, stack_trace)).into();
                        }
                    }
                } else {
                    let mut parent_frame = &mut frame_stack[fs_len - 1];
                    let mut parent_stack = &mut parent_frame.stack;

                    if let Some(ip) = set_ip {
                        parent_frame.i_ptr = ip;
                        parent_frame.executor.state = ScriptExecutorState::ExpectingInitialOP;
                        set_ip = None;
                    }

                    parent_frame.i_ptr += 1;

                    // Push terms on the parent stack
                    for t in frame.stack.iter().cloned() {
                        parent_stack.push(t);

                        if parent_stack.len() > STACK_SIZE {
                            let mut stack_trace = StackTrace::default();

                            if flags.build_stacktrace {
                                stack_trace.trace.push(
                                    (
                                        frame.i_ptr - 1,
                                        frame.func_idx,
                                        self.script[frame.i_ptr - 1].clone(),
                                    )
                                        .into(),
                                );
                                stack_trace.extend_from_frame_stack(&frame_stack, self);
                            }
                            return Err((ExecutionResult::StackOverflow, stack_trace)).into();
                        }
                    }
                }
            }

            if let Some(new_script) = new_script {
                script_stack.push(new_script);
            }

            if let Some(new_frame) = new_frame {
                if frame_stack.len() > MAX_FRAMES {
                    let frame = frame_stack.last().unwrap();
                    let mut stack_trace = StackTrace::default();
                    if flags.build_stacktrace {
                        stack_trace.trace.push(
                            (
                                frame.i_ptr,
                                frame.func_idx,
                                self.script[new_frame.i_ptr].clone(),
                            )
                                .into(),
                        );
                        stack_trace.extend_from_frame_stack(&frame_stack, self);
                    }
                    return Err((ExecutionResult::StackOverflow, stack_trace)).into();
                }

                frame_stack.push(new_frame);
            }
        }
    }

    #[must_use]
    pub fn to_script_hash(&self, key: &str) -> Hash160 {
        Hash160::hash_from_slice(crate::codec::encode_to_vec(&self).unwrap(), key)
    }
}

#[derive(Debug, Clone)]
pub struct ScriptExecutor {
    state: ScriptExecutorState,
}

impl Default for ScriptExecutor {
    fn default() -> Self {
        Self::new()
    }
}

impl ScriptExecutor {
    #[must_use]
    pub fn new() -> Self {
        Self {
            state: ScriptExecutorState::ExpectingArgsLen,
        }
    }

    #[inline]
    pub fn push_op(
        &mut self,
        flags: &VmFlags,
        op: &ScriptEntry,
        i_ptr: usize,
        func_idx: Option<usize>,
        inputs_hash: &Hash160,
        memory_size: &mut usize,
        exec_stack: &mut Vec<VmTerm>,
        verification_stack: &mut VerificationStack,
        input_stack: &[Input],
        output_stack: &mut Vec<Output>,
        output_stack_idx_map: &mut HashMap<(Address, Hash160), u16>,
        script_outputs: &mut Vec<VmTerm>,
        key: &str,
        network_name: &str,
        exec_count: &mut u64,
        script_storage: &HashMap<Hash256, Rc<Script>>,
        script_stack: &Vec<Rc<Script>>,
    ) {
        match self.state {
            ScriptExecutorState::ExpectingArgsLen => match op {
                ScriptEntry::Byte(args_len) => {
                    let args_len = *args_len as usize;
                    if exec_stack.len() != args_len {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingInitialOP;
                }

                _ => {
                    self.state = ScriptExecutorState::Error(
                        ExecutionResult::BadFormat,
                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                    );
                }
            },

            ScriptExecutorState::ExpectingIndexU8(last_op) => match (last_op, op) {
                (OP::Pick, ScriptEntry::Byte(idx)) => {
                    let idx: usize = *idx as usize;
                    if idx >= exec_stack.len() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::IndexOutOfBounds,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let cloned = exec_stack[exec_stack.len() - 1 - idx].clone();
                    *memory_size += cloned.size();
                    exec_stack.push(cloned);

                    self.state = ScriptExecutorState::ExpectingInitialOP;
                }

                (OP::Roll, ScriptEntry::Byte(idx)) => {
                    let idx: usize = *idx as usize;
                    if idx >= exec_stack.len() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::IndexOutOfBounds,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let rolled = exec_stack.remove(exec_stack.len() - 1 - idx);
                    exec_stack.push(rolled);

                    self.state = ScriptExecutorState::ExpectingInitialOP;
                }

                (OP::PickToScriptOuts, ScriptEntry::Byte(idx)) => {
                    let idx: usize = *idx as usize;
                    if idx >= exec_stack.len() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::IndexOutOfBounds,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let cloned = exec_stack[exec_stack.len() - 1 - idx].clone();
                    script_outputs.push(cloned);

                    self.state = ScriptExecutorState::ExpectingInitialOP;
                }

                _ => {
                    self.state = ScriptExecutorState::Error(
                        ExecutionResult::BadFormat,
                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                    );
                }
            },

            ScriptExecutorState::ExpectingInitialOP => match op {
                ScriptEntry::Byte(_) => {
                    self.state = ScriptExecutorState::Error(
                        ExecutionResult::BadFormat,
                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                    );
                }

                ScriptEntry::Opcode(OP::ChainId) => {
                    let term = VmTerm::Unsigned8(flags.chain_id);
                    *memory_size += 1;
                    exec_stack.push(term);
                }

                ScriptEntry::Opcode(OP::ChainTimestamp) => {
                    let term = VmTerm::Signed64(flags.chain_timestamp);
                    *memory_size += 8;
                    exec_stack.push(term);
                }

                ScriptEntry::Opcode(OP::ChainHeight) => {
                    let term = VmTerm::Unsigned64(flags.chain_height);
                    *memory_size += 8;
                    exec_stack.push(term);
                }

                ScriptEntry::Opcode(OP::NetworkName) => {
                    let term = VmTerm::Unsigned8Array(network_name.as_bytes().to_vec());
                    *memory_size += term.size();
                    exec_stack.push(term);
                }

                ScriptEntry::Opcode(OP::Pi) => {
                    let term = VmTerm::Decimal(Decimal::PI);
                    *memory_size += term.size();
                    exec_stack.push(term);
                }

                ScriptEntry::Opcode(OP::OpenImplicitCert) => {
                    if exec_stack.len() < 4 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let t1 = exec_stack.pop().unwrap();
                    *memory_size -= t1.size();
                    let t2 = exec_stack.pop().unwrap();
                    *memory_size -= t2.size();
                    let t3 = exec_stack.pop().unwrap();
                    *memory_size -= t3.size();
                    let t4 = exec_stack.pop().unwrap();
                    *memory_size -= t4.size();

                    match (t1, t2, t3, t4) {
                        (
                            VmTerm::Unsigned8Array(issuer_pub_key),
                            VmTerm::Unsigned8Array(transcript),
                            VmTerm::Unsigned8Array(ctx),
                            VmTerm::Unsigned8Array(cert),
                        ) if issuer_pub_key.len() == 32 && cert.len() == 32 => {
                            match PublicKey::from_bytes(&issuer_pub_key) {
                                Ok(issuer_pub_key) => {
                                    // Create context
                                    let ctx = signing_context(ctx.as_slice());

                                    let mut cert_buf = [0; 32];
                                    cert_buf.copy_from_slice(cert.as_slice());
                                    let cert = AdaptorCertPublic(cert_buf);

                                    match issuer_pub_key
                                        .open_adaptor_cert(ctx.bytes(transcript.as_slice()), &cert)
                                    {
                                        Ok(cert_pub_key) => {
                                            let cert_pub_key_bytes = cert_pub_key.to_bytes();
                                            let cert_pub_key =
                                                VmTerm::Unsigned8Array(cert_pub_key_bytes.to_vec());
                                            *memory_size += cert_pub_key.size();
                                            exec_stack.push(cert_pub_key);
                                        }
                                        _ => {
                                            self.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidArgs,
                                                (
                                                    i_ptr,
                                                    func_idx,
                                                    op.clone(),
                                                    exec_stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    }
                                }
                                _ => {
                                    self.state = ScriptExecutorState::Error(
                                        ExecutionResult::InvalidArgs,
                                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                                    );
                                }
                            }
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::OpenImplicitCertGlobal) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let t1 = exec_stack.pop().unwrap();
                    *memory_size -= t1.size();
                    let t2 = exec_stack.pop().unwrap();
                    *memory_size -= t2.size();
                    let t3 = exec_stack.pop().unwrap();
                    *memory_size -= t3.size();

                    match (t1, t2, t3) {
                        (
                            VmTerm::Unsigned8Array(issuer_pub_key),
                            VmTerm::Unsigned8Array(transcript),
                            VmTerm::Unsigned8Array(cert),
                        ) if issuer_pub_key.len() == 32 && cert.len() == 32 => {
                            match PublicKey::from_bytes(&issuer_pub_key) {
                                Ok(issuer_pub_key) => {
                                    // Create the context string and context
                                    let mut ctx_buf = network_name.to_owned();
                                    ctx_buf.push_str(ADAPTOR_CERT_CTX);
                                    let ctx = signing_context(ctx_buf.as_str().as_bytes());

                                    let mut cert_buf = [0; 32];
                                    cert_buf.copy_from_slice(cert.as_slice());
                                    let cert = AdaptorCertPublic(cert_buf);

                                    match issuer_pub_key
                                        .open_adaptor_cert(ctx.bytes(transcript.as_slice()), &cert)
                                    {
                                        Ok(cert_pub_key) => {
                                            let cert_pub_key_bytes = cert_pub_key.to_bytes();
                                            let cert_pub_key =
                                                VmTerm::Unsigned8Array(cert_pub_key_bytes.to_vec());
                                            *memory_size += cert_pub_key.size();
                                            exec_stack.push(cert_pub_key);
                                        }
                                        _ => {
                                            self.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidArgs,
                                                (
                                                    i_ptr,
                                                    func_idx,
                                                    op.clone(),
                                                    exec_stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    }
                                }
                                _ => {
                                    self.state = ScriptExecutorState::Error(
                                        ExecutionResult::InvalidArgs,
                                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                                    );
                                }
                            }
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::OpenImplicitCertScoped) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let t1 = exec_stack.pop().unwrap();
                    *memory_size -= t1.size();
                    let t2 = exec_stack.pop().unwrap();
                    *memory_size -= t2.size();
                    let t3 = exec_stack.pop().unwrap();
                    *memory_size -= t3.size();

                    match (t1, t2, t3) {
                        (
                            VmTerm::Unsigned8Array(issuer_pub_key),
                            VmTerm::Unsigned8Array(transcript),
                            VmTerm::Unsigned8Array(cert),
                        ) if issuer_pub_key.len() == 32 && cert.len() == 32 => {
                            match PublicKey::from_bytes(&issuer_pub_key) {
                                Ok(issuer_pub_key) => {
                                    // Create the context string and context
                                    let mut ctx_buf = key.to_owned();
                                    ctx_buf.push_str(ADAPTOR_CERT_CTX);
                                    let ctx = signing_context(ctx_buf.as_str().as_bytes());

                                    let mut cert_buf = [0; 32];
                                    cert_buf.copy_from_slice(cert.as_slice());
                                    let cert = AdaptorCertPublic(cert_buf);

                                    match issuer_pub_key
                                        .open_adaptor_cert(ctx.bytes(transcript.as_slice()), &cert)
                                    {
                                        Ok(cert_pub_key) => {
                                            let cert_pub_key_bytes = cert_pub_key.to_bytes();
                                            let cert_pub_key =
                                                VmTerm::Unsigned8Array(cert_pub_key_bytes.to_vec());
                                            *memory_size += cert_pub_key.size();
                                            exec_stack.push(cert_pub_key);
                                        }
                                        _ => {
                                            self.state = ScriptExecutorState::Error(
                                                ExecutionResult::InvalidArgs,
                                                (
                                                    i_ptr,
                                                    func_idx,
                                                    op.clone(),
                                                    exec_stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                        }
                                    }
                                }
                                _ => {
                                    self.state = ScriptExecutorState::Error(
                                        ExecutionResult::InvalidArgs,
                                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                                    );
                                }
                            }
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::BaseContext) => {
                    let term = VmTerm::Unsigned8Array(key.as_bytes().to_vec());
                    *memory_size += term.size();
                    exec_stack.push(term);
                }

                ScriptEntry::Opcode(OP::VerifyInline) => {
                    if exec_stack.len() < 4 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let t1 = exec_stack.pop().unwrap();
                    *memory_size -= t1.size();
                    let t2 = exec_stack.pop().unwrap();
                    *memory_size -= t2.size();
                    let t3 = exec_stack.pop().unwrap();
                    *memory_size -= t3.size();
                    let t4 = exec_stack.pop().unwrap();
                    *memory_size -= t4.size();

                    match (t1, t2, t3, t4) {
                        (
                            VmTerm::Unsigned8Array(pub_key),
                            VmTerm::Unsigned8Array(transcript),
                            VmTerm::Unsigned8Array(signature),
                            VmTerm::Unsigned8Array(message),
                        ) if pub_key.len() == 32 && signature.len() == 64 => {
                            // Create the context string and context
                            let mut ctx_str = key.to_owned();
                            ctx_str.push_str(INLINE_VERIFICATION_CTX);

                            let mut pub_key_buf = [0; 32];
                            let mut sig_buf = [0; 64];
                            pub_key_buf.copy_from_slice(&pub_key);
                            sig_buf.copy_from_slice(&signature);

                            match verify_single_schnor(
                                ctx_str.as_str(),
                                &pub_key_buf,
                                &sig_buf,
                                &message,
                            ) {
                                Ok(()) => {
                                    exec_stack.push(VmTerm::Unsigned8(1));
                                    *memory_size += 1;
                                }

                                Err(
                                    SigVerificationErr::InvalidPublicKey
                                    | SigVerificationErr::InvalidSignature,
                                ) => {
                                    self.state = ScriptExecutorState::Error(
                                        ExecutionResult::InvalidArgs,
                                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                                    );
                                }

                                _ => {
                                    exec_stack.push(VmTerm::Unsigned8(0));
                                    *memory_size += 1;
                                }
                            }
                        }

                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::PrevBlockHash) => {
                    let term = VmTerm::Hash256(flags.prev_block_hash);
                    *memory_size += 32;
                    exec_stack.push(term);
                }

                ScriptEntry::Opcode(
                    OP::PushOut
                    | OP::PushOutIf
                    | OP::PushOutIfEq
                    | OP::PushOutIfNeq
                    | OP::PushOutIfLt
                    | OP::PushOutIfGt
                    | OP::PushOutIfLeq
                    | OP::PushOutIfGeq,
                ) => {
                    match Self::check_condition_push_out(exec_stack, memory_size, op.clone()) {
                        Ok(val) => {
                            if val {
                                if exec_stack.len() < 3 {
                                    self.state = ScriptExecutorState::Error(
                                        ExecutionResult::InvalidArgs,
                                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                                    );
                                    return;
                                }

                                let amount = exec_stack.pop().unwrap();
                                *memory_size -= amount.size();
                                let address = exec_stack.pop().unwrap();
                                *memory_size -= address.size();
                                let script_hash = exec_stack.pop().unwrap();
                                *memory_size -= script_hash.size();

                                match (amount, address, script_hash) {
                                    (
                                        VmTerm::Signed128(amount),
                                        VmTerm::Hash160(addr),
                                        VmTerm::Hash160(script_hash),
                                    ) if amount > 0 => {
                                        let address = Address(addr);
                                        let script_hash = Hash160(script_hash);

                                        if let Some(idx) = output_stack_idx_map
                                            .get(&(address.clone(), script_hash.clone()))
                                        {
                                            // Re-hash inputs
                                            let inputs_hashes: Vec<u8> = [
                                                output_stack[*idx as usize].inputs_hash.clone(),
                                                inputs_hash.clone(),
                                            ]
                                            .iter()
                                            .fold(vec![], |mut acc, hash| {
                                                acc.extend(hash.0);
                                                acc
                                            });

                                            let inputs_hash =
                                                Hash160::hash_from_slice(inputs_hashes, key);

                                            output_stack[*idx as usize].amount += amount;
                                            output_stack[*idx as usize].inputs_hash = inputs_hash;
                                            output_stack[*idx as usize].compute_hash(key);
                                            output_stack[*idx as usize].script_outs =
                                                script_outputs.clone();

                                            *script_outputs = vec![];
                                        } else {
                                            let mut output = Output {
                                                amount,
                                                address: Some(address.clone()),
                                                script_hash: script_hash.clone(),
                                                coinbase_height: None,
                                                coloured_address: None,
                                                inputs_hash: inputs_hash.clone(),
                                                idx: output_stack.len() as u16,
                                                script_outs: script_outputs.clone(),
                                                hash: None,
                                            };

                                            output.compute_hash(key);
                                            output_stack_idx_map.insert(
                                                (address, script_hash),
                                                output_stack.len() as u16,
                                            );
                                            output_stack.push(output);
                                            *script_outputs = vec![];
                                        }

                                        if output_stack.len() > MAX_OUT_STACK {
                                            self.state = ScriptExecutorState::Error(
                                                ExecutionResult::OutStackOverflow,
                                                (
                                                    i_ptr,
                                                    func_idx,
                                                    op.clone(),
                                                    exec_stack.as_slice(),
                                                )
                                                    .into(),
                                            );
                                            return;
                                        }

                                        self.state = ScriptExecutorState::ExpectingInitialOP;
                                    }

                                    _ => {
                                        self.state = ScriptExecutorState::Error(
                                            ExecutionResult::InvalidArgs,
                                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice())
                                                .into(),
                                        );
                                    }
                                }
                            }
                        }
                        Err(()) => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::PushOutVerify) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let amount = exec_stack.pop().unwrap();
                    let address = exec_stack.pop().unwrap();
                    let script_hash = exec_stack.pop().unwrap();

                    match (amount, address, script_hash) {
                        (
                            VmTerm::Signed128(amount),
                            VmTerm::Hash160(addr),
                            VmTerm::Hash160(script_hash),
                        ) if amount > 0 => {
                            let address = Address(addr);
                            let script_hash = Hash160(script_hash);

                            if let Some(idx) =
                                output_stack_idx_map.get(&(address.clone(), script_hash.clone()))
                            {
                                // Re-hash inputs
                                let inputs_hashes: Vec<u8> = [
                                    output_stack[*idx as usize].inputs_hash.clone(),
                                    inputs_hash.clone(),
                                ]
                                .iter()
                                .fold(vec![], |mut acc, hash| {
                                    acc.extend(hash.0);
                                    acc
                                });

                                let inputs_hash = Hash160::hash_from_slice(inputs_hashes, key);

                                output_stack[*idx as usize].amount += amount;
                                output_stack[*idx as usize].inputs_hash = inputs_hash;
                                output_stack[*idx as usize].compute_hash(key);
                                output_stack[*idx as usize].script_outs = script_outputs.clone();

                                *script_outputs = vec![];
                            } else {
                                let mut output = Output {
                                    amount,
                                    address: Some(address.clone()),
                                    script_hash: script_hash.clone(),
                                    coinbase_height: None,
                                    coloured_address: None,
                                    inputs_hash: inputs_hash.clone(),
                                    idx: output_stack.len() as u16,
                                    script_outs: script_outputs.clone(),
                                    hash: None,
                                };

                                output.compute_hash(key);
                                output_stack_idx_map
                                    .insert((address, script_hash), output_stack.len() as u16);
                                output_stack.push(output);
                                *script_outputs = vec![];

                                if output_stack.len() > MAX_OUT_STACK {
                                    self.state = ScriptExecutorState::Error(
                                        ExecutionResult::OutStackOverflow,
                                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                                    );
                                    return;
                                }
                            }

                            self.state = ScriptExecutorState::OkVerify;
                        }

                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::PushCoinbaseOut) => {
                    if exec_stack.len() < 4 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if !flags.is_coinbase {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OPOnlyAllowedInCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let amount = exec_stack.pop().unwrap();
                    *memory_size -= amount.size();
                    let address = exec_stack.pop().unwrap();
                    *memory_size -= address.size();
                    let script_hash = exec_stack.pop().unwrap();
                    *memory_size -= script_hash.size();
                    let coinbase_height = exec_stack.pop().unwrap();
                    *memory_size -= coinbase_height.size();

                    match (amount, address, script_hash, coinbase_height) {
                        (
                            VmTerm::Signed128(amount),
                            VmTerm::Hash160(addr),
                            VmTerm::Hash160(script_hash),
                            VmTerm::Unsigned64(coinbase_height),
                        ) if amount > 0 && coinbase_height > 0 => {
                            let mut output = Output {
                                amount,
                                address: Some(Address(addr)),
                                script_hash: Hash160(script_hash),
                                coinbase_height: Some(coinbase_height),
                                coloured_address: None,
                                inputs_hash: inputs_hash.clone(),
                                idx: output_stack.len() as u16,
                                script_outs: script_outputs.clone(),
                                hash: None,
                            };

                            output.compute_hash(key);
                            output_stack.push(output);
                            *script_outputs = vec![];

                            self.state = ScriptExecutorState::Ok;
                        }

                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::PushCoinbaseOutNoSpendAddress) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if !flags.is_coinbase {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OPOnlyAllowedInCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let amount = exec_stack.pop().unwrap();
                    *memory_size -= amount.size();
                    let script_hash = exec_stack.pop().unwrap();
                    *memory_size -= script_hash.size();
                    let coinbase_height = exec_stack.pop().unwrap();
                    *memory_size -= coinbase_height.size();

                    match (amount, script_hash, coinbase_height) {
                        (
                            VmTerm::Signed128(amount),
                            VmTerm::Hash160(script_hash),
                            VmTerm::Unsigned64(coinbase_height),
                        ) if amount > 0 && coinbase_height > 0 => {
                            let mut output = Output {
                                amount,
                                address: None,
                                script_hash: Hash160(script_hash),
                                coinbase_height: Some(coinbase_height),
                                coloured_address: None,
                                inputs_hash: inputs_hash.clone(),
                                idx: output_stack.len() as u16,
                                script_outs: script_outputs.clone(),
                                hash: None,
                            };

                            output.compute_hash(key);
                            output_stack.push(output);
                            *script_outputs = vec![];

                            self.state = ScriptExecutorState::Ok;
                        }

                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Call) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Call);
                }

                ScriptEntry::Opcode(OP::ReturnFunc) => {
                    if func_idx.is_some() {
                        self.state = ScriptExecutorState::ReturnFunc;
                    } else {
                        // Behaves the same as `OP_Return` if called from the main function
                        if exec_stack.is_empty() {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }

                        let top = exec_stack.pop().unwrap();
                        *memory_size -= top.size();

                        if top.equals_1() {
                            self.state = ScriptExecutorState::Ok;
                        } else {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::Invalid,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::GetSpentOutScriptOutsLen) => {
                    if let Some(outs) = flags.spent_out.as_ref().map(|o| &o.script_outs) {
                        exec_stack.push(VmTerm::Unsigned16(outs.len() as u16));
                        *memory_size += 2;
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::SpillSpentOutScriptOuts) => {
                    if let Some(outs) = flags.spent_out.as_ref().map(|o| &o.script_outs) {
                        for t in outs.iter().rev() {
                            exec_stack.push(t.clone());
                            *memory_size += t.size();
                        }
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::InputScriptArgsLen) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::InputScriptArgsLen);
                }

                ScriptEntry::Opcode(OP::GetOutScriptOutsLen) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutScriptOutsLen);
                }

                ScriptEntry::Opcode(OP::InputsLen) => {
                    exec_stack.push(VmTerm::Unsigned16(input_stack.len() as u16));
                    *memory_size += 2;
                }

                ScriptEntry::Opcode(OP::OutputsLen) => {
                    exec_stack.push(VmTerm::Unsigned16(output_stack.len() as u16));
                    *memory_size += 2;
                }

                ScriptEntry::Opcode(OP::SpillInputScriptArgs) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::SpillInputScriptArgs);
                }

                ScriptEntry::Opcode(OP::SpillScriptOuts) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::SpillScriptOuts);
                }

                ScriptEntry::Opcode(OP::GetInputScriptArgAt) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetInputScriptArgAt);
                }

                ScriptEntry::Opcode(OP::GetOutScriptOut) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutScriptOut);
                }

                ScriptEntry::Opcode(OP::GetOutAmount) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutAmount);
                }

                ScriptEntry::Opcode(OP::IsColouredOut) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::IsColouredOut);
                }

                ScriptEntry::Opcode(OP::ColourHash) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::ColourHash);
                }

                ScriptEntry::Opcode(OP::GetOutReceiver) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutReceiver);
                }

                ScriptEntry::Opcode(OP::PushPrevScriptOuts) => {
                    if flags.spent_out.as_ref().is_some() {
                        self.state =
                            ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::PushPrevScriptOuts);
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::GetSpentOutScriptOut) => {
                    if flags.spent_out.as_ref().is_some() {
                        self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(
                            OP::GetSpentOutScriptOut,
                        );
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::GetSpentOutScriptOutsLen) => {
                    if let Some(prev_out_outs) = flags.spent_out.as_ref().map(|o| &o.script_outs) {
                        exec_stack.push(VmTerm::Unsigned16(prev_out_outs.len() as u16));
                        *memory_size += 2;
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::GetOutScriptHash) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetOutScriptHash);
                }

                ScriptEntry::Opcode(OP::GetSpentOutScriptHash) => {
                    if let Some(out) = flags.spent_out.as_ref() {
                        exec_stack.push(VmTerm::Hash160(out.script_hash.0));
                        *memory_size += 20;
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::GetSpentOutAmount) => {
                    if let Some(out) = flags.spent_out.as_ref() {
                        exec_stack.push(VmTerm::Signed128(out.amount));
                        *memory_size += 16;
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::GetSpentOutReceiver) => {
                    if let Some(out) = flags.spent_out.as_ref() {
                        if let Some(receiver) = &out.coloured_address {
                            let term = VmTerm::Unsigned8Array(receiver.address.to_vec());
                            *memory_size += term.size();
                            exec_stack.push(term);
                        } else if let Some(receiver) = &out.address {
                            let term = VmTerm::Unsigned8Array(receiver.0.to_vec());
                            *memory_size += term.size();
                            exec_stack.push(term);
                        } else {
                            // Push 0 as empty array
                            exec_stack.push(VmTerm::Unsigned8Array(vec![]));
                            *memory_size += EMPTY_VEC_HEAP_SIZE;
                        }
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::SpentOutIsColouredOut) => {
                    if let Some(out) = flags.spent_out.as_ref() {
                        if out.is_coloured() {
                            exec_stack.push(VmTerm::Unsigned8(1));
                            *memory_size += 1;
                        } else {
                            exec_stack.push(VmTerm::Unsigned8(0));
                            *memory_size += 1;
                        }
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::SpentOutColourHash) => {
                    if let Some(out) = flags.spent_out.as_ref() {
                        if let Some(receiver) = &out.coloured_address {
                            exec_stack.push(VmTerm::Hash160(receiver.colour_hash));
                            *memory_size += 20;
                        } else {
                            exec_stack.push(VmTerm::Hash160([0; 20]));
                            *memory_size += 20;
                        }
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidOPForCoinbaseInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::Concat) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut top = exec_stack.pop().unwrap();

                    match exec_stack.last_mut().unwrap().append(&mut top) {
                        Some(()) => {
                            // The items size is already added to the memory_size of the VM,
                            // we only have to substract the HEAP_SIZE for the removed vector
                            *memory_size -= crate::vm::internal::EMPTY_VEC_HEAP_SIZE;
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Verify) => {
                    self.state = ScriptExecutorState::OkVerify;
                }

                ScriptEntry::Opcode(OP::Ok) => {
                    self.state = ScriptExecutorState::Ok;
                }

                ScriptEntry::Opcode(OP::Return) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    *memory_size -= top.size();

                    if top.equals_1() {
                        self.state = ScriptExecutorState::Ok;
                    } else {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::Invalid,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::EqVerify) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 == e2 {
                        self.state = ScriptExecutorState::OkVerify;
                    }
                }

                ScriptEntry::Opcode(OP::LtVerify) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 < e2 {
                        self.state = ScriptExecutorState::OkVerify;
                    }
                }

                ScriptEntry::Opcode(OP::GtVerify) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 > e2 {
                        self.state = ScriptExecutorState::OkVerify;
                    }
                }

                ScriptEntry::Opcode(OP::LeqVerify) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 <= e2 {
                        self.state = ScriptExecutorState::OkVerify;
                    }
                }

                ScriptEntry::Opcode(OP::GeqVerify) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 >= e2 {
                        self.state = ScriptExecutorState::OkVerify;
                    }
                }

                ScriptEntry::Opcode(OP::NeqVerify) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 != e2 {
                        self.state = ScriptExecutorState::OkVerify;
                    }
                }

                ScriptEntry::Opcode(OP::Loop) => {
                    self.state = ScriptExecutorState::NewLoopFrame;
                }

                ScriptEntry::Opcode(OP::Break) => {
                    self.state = ScriptExecutorState::BreakLoop;
                }

                ScriptEntry::Opcode(OP::BreakIf) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    *memory_size -= top.size();

                    if top.equals_1() {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::BreakIfn) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    *memory_size -= top.size();

                    if !top.equals_1() {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::BreakIfEq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 == e2 {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::BreakIfNeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 != e2 {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::BreakIfLeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 <= e2 {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::BreakIfGeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 >= e2 {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::BreakIfLt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 < e2 {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::BreakIfGt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 > e2 {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::Continue) => {
                    self.state = ScriptExecutorState::ContinueLoop;
                }

                ScriptEntry::Opcode(OP::ContinueIf) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    *memory_size -= top.size();

                    if top.equals_1() {
                        self.state = ScriptExecutorState::ContinueLoop;
                    } else {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::ContinueIfn) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    *memory_size -= top.size();

                    if !top.equals_1() {
                        self.state = ScriptExecutorState::ContinueLoop;
                    } else {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::ContinueIfEq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 == e2 {
                        self.state = ScriptExecutorState::ContinueLoop;
                    } else {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::ContinueIfNeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 != e2 {
                        self.state = ScriptExecutorState::ContinueLoop;
                    } else {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::ContinueIfLeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 <= e2 {
                        self.state = ScriptExecutorState::ContinueLoop;
                    } else {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::ContinueIfGeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 >= e2 {
                        self.state = ScriptExecutorState::ContinueLoop;
                    } else {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::ContinueIfLt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 < e2 {
                        self.state = ScriptExecutorState::ContinueLoop;
                    } else {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::ContinueIfGt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 > e2 {
                        self.state = ScriptExecutorState::ContinueLoop;
                    } else {
                        self.state = ScriptExecutorState::BreakLoop;
                    }
                }

                ScriptEntry::Opcode(OP::End) => {
                    self.state = ScriptExecutorState::EndBlock;
                }

                ScriptEntry::Opcode(OP::Depth) => {
                    exec_stack.push(VmTerm::Unsigned16(exec_stack.len() as u16));
                    *memory_size += 2;
                }

                ScriptEntry::Opcode(OP::Factorial) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = exec_stack.last_mut().unwrap();
                    if last.factorial(exec_count).is_none() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::Drop) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }
                    let e = exec_stack.pop().unwrap();
                    *memory_size -= e.size();

                    self.state = ScriptExecutorState::ExpectingInitialOP;
                }

                ScriptEntry::Opcode(OP::Dup) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let c = exec_stack[exec_stack.len() - 1].clone();
                    *memory_size += c.size();
                    exec_stack.push(c);

                    self.state = ScriptExecutorState::ExpectingInitialOP;
                }

                ScriptEntry::Opcode(OP::Nip) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let r = exec_stack.remove(exec_stack.len() - 2);
                    *memory_size -= r.size();

                    self.state = ScriptExecutorState::ExpectingInitialOP;
                }

                ScriptEntry::Opcode(OP::Over) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let c = exec_stack[exec_stack.len() - 2].clone();
                    *memory_size += c.size();
                    exec_stack.push(c);

                    self.state = ScriptExecutorState::ExpectingInitialOP;
                }

                ScriptEntry::Opcode(OP::Pick) => {
                    self.state = ScriptExecutorState::ExpectingIndexU8(OP::Pick);
                }

                ScriptEntry::Opcode(OP::Roll) => {
                    self.state = ScriptExecutorState::ExpectingIndexU8(OP::Roll);
                }

                ScriptEntry::Opcode(OP::Rot) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let len = exec_stack.len();

                    unsafe {
                        // Similar implementation like in case of Rot2:
                        //
                        // Let's suppose we have the following items on the stack:
                        // [0, 1, 2]
                        //
                        // We first swap the pointers of the first elem and the last elem:
                        // [2, 1, 0]
                        exec_stack.swap_unchecked(len - 1, len - 3);

                        // We then swap the second and third elements:
                        // [1, 2, 0]
                        exec_stack.swap_unchecked(len - 2, len - 3);
                    }
                }

                ScriptEntry::Opcode(OP::Swap) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let len = exec_stack.len();

                    unsafe {
                        exec_stack.swap_unchecked(len - 1, len - 2);
                    }
                }

                ScriptEntry::Opcode(OP::Tuck) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e = exec_stack[exec_stack.len() - 1].clone();
                    *memory_size += e.size();
                    exec_stack.insert(exec_stack.len() - 2, e);
                }

                ScriptEntry::Opcode(OP::Drop2) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }
                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();
                }

                ScriptEntry::Opcode(OP::Dup2) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let c1 = exec_stack[exec_stack.len() - 1].clone();
                    let c2 = exec_stack[exec_stack.len() - 2].clone();

                    *memory_size += c1.size();
                    *memory_size += c2.size();

                    exec_stack.push(c2);
                    exec_stack.push(c1);
                }

                ScriptEntry::Opcode(OP::Dup3) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let c1 = exec_stack[exec_stack.len() - 1].clone();
                    let c2 = exec_stack[exec_stack.len() - 2].clone();
                    let c3 = exec_stack[exec_stack.len() - 3].clone();

                    *memory_size += c1.size();
                    *memory_size += c2.size();
                    *memory_size += c3.size();

                    exec_stack.push(c3);
                    exec_stack.push(c2);
                    exec_stack.push(c1);
                }

                ScriptEntry::Opcode(OP::Over2) => {
                    if exec_stack.len() < 4 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let c1 = exec_stack[exec_stack.len() - 3].clone();
                    let c2 = exec_stack[exec_stack.len() - 4].clone();

                    *memory_size += c1.size();
                    *memory_size += c2.size();

                    exec_stack.push(c2);
                    exec_stack.push(c1);
                }

                ScriptEntry::Opcode(OP::Rot2) => {
                    if exec_stack.len() < 6 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let len = exec_stack.len();

                    unsafe {
                        // Fastest implementation I can think of:
                        //
                        // Let's suppose we have the following items on the stack:
                        // [0, 1, 2, 3, 4, 5]
                        //
                        // We first swap the pointers of the first two elems and the last two:
                        // [4, 5, 2, 3, 0, 1]
                        exec_stack.swap_unchecked(len - 1, len - 5);
                        exec_stack.swap_unchecked(len - 2, len - 6);

                        // We then swap the third and fourth elements with the last two:
                        // [2, 3, 4, 5, 0, 1]
                        exec_stack.swap_unchecked(len - 3, len - 5);
                        exec_stack.swap_unchecked(len - 4, len - 6);
                    }
                }

                ScriptEntry::Opcode(OP::Swap2) => {
                    if exec_stack.len() < 4 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let len = exec_stack.len();

                    unsafe {
                        exec_stack.swap_unchecked(len - 1, len - 3);
                        exec_stack.swap_unchecked(len - 2, len - 4);
                    }
                }

                ScriptEntry::Opcode(OP::Size) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let size = exec_stack[exec_stack.len() - 1].size();
                    let e = VmTerm::Unsigned64(size as u64);

                    *memory_size += e.size();
                    exec_stack.push(e);
                }

                ScriptEntry::Opcode(OP::Substr) => {
                    let len = exec_stack.len();

                    if len == 0 || !exec_stack[len - 1].is_array() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Substr);
                }

                ScriptEntry::Opcode(OP::BitAND) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match second.and(&mut last, exec_count) {
                        Some(()) => {
                            exec_stack.push(second);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::BitOR) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match second.or(&mut last, exec_count) {
                        Some(()) => {
                            exec_stack.push(second);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::BitInvert) => {
                    let len = exec_stack.len();
                    if len == 0 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = &mut exec_stack[len - 1];

                    match last.not(exec_count) {
                        Some(()) => {}
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::DupAll) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if *memory_size > MEMORY_SIZE / 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OutOfMemory,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let copy = exec_stack.clone();
                    *exec_count += copy.len() as u64;
                    exec_stack.extend_from_slice(&copy);
                    *memory_size *= 2;
                }

                ScriptEntry::Opcode(OP::IsUTF8) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let term = exec_stack.last().unwrap();
                    if term.get_type() != crate::vm::internal::HASH_KEY_TYPE {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if let VmTerm::Unsigned8Array(arr) = term {
                        *exec_count += arr.len() as u64;
                        let utf8 = from_utf8(arr);
                        if utf8.is_err() {
                            exec_stack.push(VmTerm::Unsigned8(0));
                            *memory_size += 1;
                        } else {
                            exec_stack.push(VmTerm::Unsigned8(1));
                            *memory_size += 1;
                        }
                    } else {
                        unreachable!()
                    }
                }

                ScriptEntry::Opcode(OP::RandomHash160Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomHash160Var);
                }

                ScriptEntry::Opcode(OP::RandomHash256Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomHash256Var);
                }

                ScriptEntry::Opcode(OP::RandomHash512Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomHash512Var);
                }

                ScriptEntry::Opcode(OP::RandomUnsigned8Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned8Var);
                }

                ScriptEntry::Opcode(OP::RandomUnsigned16Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned16Var);
                }

                ScriptEntry::Opcode(OP::RandomUnsigned32Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned32Var);
                }

                ScriptEntry::Opcode(OP::RandomUnsigned64Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned64Var);
                }

                ScriptEntry::Opcode(OP::RandomUnsigned128Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomUnsigned128Var);
                }

                ScriptEntry::Opcode(OP::RandomSigned8Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned8Var);
                }

                ScriptEntry::Opcode(OP::RandomSigned16Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned16Var);
                }

                ScriptEntry::Opcode(OP::RandomSigned32Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned32Var);
                }

                ScriptEntry::Opcode(OP::RandomSigned64Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned64Var);
                }

                ScriptEntry::Opcode(OP::RandomSigned128Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomSigned128Var);
                }

                ScriptEntry::Opcode(OP::RandomFloat32Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomFloat32Var);
                }

                ScriptEntry::Opcode(OP::RandomFloat64Var) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomFloat64Var);
                }

                ScriptEntry::Opcode(OP::RandomDecimalVar) => {
                    if !flags.can_fail {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::OpcodeAllowedOnlyInFailableInput,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingRandomTerm(OP::RandomDecimalVar);
                }

                ScriptEntry::Opcode(OP::Hash160Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash160Var);
                }

                ScriptEntry::Opcode(OP::Hash256Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash256Var);
                }

                ScriptEntry::Opcode(OP::Hash512Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash512Var);
                }

                ScriptEntry::Opcode(OP::Unsigned8Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned8Var);
                }

                ScriptEntry::Opcode(OP::Unsigned16Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned16Var);
                }

                ScriptEntry::Opcode(OP::Unsigned32Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned32Var);
                }

                ScriptEntry::Opcode(OP::Unsigned64Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned64Var);
                }

                ScriptEntry::Opcode(OP::Unsigned128Var) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned128Var);
                }

                ScriptEntry::Opcode(OP::UnsignedBigVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::UnsignedBigVar);
                }

                ScriptEntry::Opcode(OP::Signed8Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed8Var);
                }

                ScriptEntry::Opcode(OP::Signed16Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed16Var);
                }

                ScriptEntry::Opcode(OP::Signed32Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed32Var);
                }

                ScriptEntry::Opcode(OP::Signed64Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed64Var);
                }

                ScriptEntry::Opcode(OP::Signed128Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed128Var);
                }

                ScriptEntry::Opcode(OP::SignedBigVar) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::SignedBigVar);
                }

                ScriptEntry::Opcode(OP::Float32Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Float32Var);
                }

                ScriptEntry::Opcode(OP::Float64Var) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Float64Var);
                }

                ScriptEntry::Opcode(OP::DecimalVar) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::DecimalVar);
                }

                ScriptEntry::Opcode(OP::Hash160ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash160ArrayVar);
                }

                ScriptEntry::Opcode(OP::Hash256ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash256ArrayVar);
                }

                ScriptEntry::Opcode(OP::Hash512ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Hash512ArrayVar);
                }

                ScriptEntry::Opcode(OP::Unsigned8ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned8ArrayVar);
                }

                ScriptEntry::Opcode(OP::Unsigned16ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned16ArrayVar);
                }

                ScriptEntry::Opcode(OP::Unsigned32ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned32ArrayVar);
                }

                ScriptEntry::Opcode(OP::Unsigned64ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned64ArrayVar);
                }

                ScriptEntry::Opcode(OP::Unsigned128ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Unsigned128ArrayVar);
                }

                ScriptEntry::Opcode(OP::UnsignedBigArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::UnsignedBigArrayVar);
                }

                ScriptEntry::Opcode(OP::Signed8ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed8ArrayVar);
                }

                ScriptEntry::Opcode(OP::Signed16ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed16ArrayVar);
                }

                ScriptEntry::Opcode(OP::Signed32ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed32ArrayVar);
                }

                ScriptEntry::Opcode(OP::Signed64ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed64ArrayVar);
                }

                ScriptEntry::Opcode(OP::Signed128ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Signed128ArrayVar);
                }

                ScriptEntry::Opcode(OP::SignedBigArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::SignedBigArrayVar);
                }

                ScriptEntry::Opcode(OP::Float32ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Float32ArrayVar);
                }

                ScriptEntry::Opcode(OP::Float64ArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::Float64ArrayVar);
                }

                ScriptEntry::Opcode(OP::DecimalArrayVar) => {
                    self.state =
                        ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::DecimalArrayVar);
                }

                ScriptEntry::Opcode(OP::GetAtArray) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::GetAtArray);
                }

                ScriptEntry::Opcode(OP::CastTo) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::CastTo);
                }

                ScriptEntry::Opcode(OP::PushBackArray) => {
                    let len: usize = exec_stack.len();

                    if len < 2 || !exec_stack[len - 1].is_array() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let r: VmTerm = exec_stack.remove(len - 2);
                    let len: usize = exec_stack.len();

                    match exec_stack[len - 1].push_back(&r) {
                        Some(()) => {}
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::PushFrontArray) => {
                    let len: usize = exec_stack.len();

                    if len < 2 || !exec_stack[len - 1].is_array() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let r: VmTerm = exec_stack.remove(len - 2);
                    let len: usize = exec_stack.len();

                    match exec_stack[len - 1].push_front(&r) {
                        Some(()) => {}
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::PopBackArray) => {
                    let len: usize = exec_stack.len();

                    if len < 1 || !exec_stack[len - 1].is_array() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    match exec_stack[len - 1].pop_back() {
                        Some(term) => {
                            exec_stack.push(term);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::PopFrontArray) => {
                    let len: usize = exec_stack.len();

                    if len < 1 || !exec_stack[len - 1].is_array() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    match exec_stack[len - 1].pop_front() {
                        Some(term) => {
                            exec_stack.push(term);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::DeleteAtArray) => {
                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::DeleteAtArray);
                }

                ScriptEntry::Opcode(OP::ArrayLen) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let last = exec_stack.last().unwrap();

                    if !last.is_array() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e = VmTerm::Unsigned16(last.len() as u16);

                    *memory_size += e.size();
                    exec_stack.push(e);
                }

                ScriptEntry::Opcode(OP::ToHex) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    *exec_count += last.size() as u64;

                    let bytes = last.to_bytes_raw();
                    let encoded = hex::encode(bytes);
                    let hex_bytes = encoded.into_bytes();
                    let term = VmTerm::Unsigned8Array(hex_bytes);

                    *memory_size += term.size();
                    exec_stack.push(term);
                }

                ScriptEntry::Opcode(OP::FromHex) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    *exec_count += last.size() as u64;

                    match last {
                        VmTerm::Unsigned8Array(val) => match hex::decode(val) {
                            Ok(decoded) => {
                                let term = VmTerm::Unsigned8Array(decoded);
                                *memory_size += term.size();
                                exec_stack.push(term);
                            }
                            Err(_) => {
                                self.state = ScriptExecutorState::Error(
                                    ExecutionResult::InvalidArgs,
                                    (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                                );
                            }
                        },

                        // Not an `Unsigned8Array`, throw error
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::BoolAnd) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    if last.equals_1() && second.equals_1() {
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::BoolOr) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    if last.equals_1() || second.equals_1() {
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::Negate) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = exec_stack.last_mut().unwrap();
                    last.negate(exec_count);
                }

                ScriptEntry::Opcode(OP::Abs) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = exec_stack.last_mut().unwrap();

                    match last {
                        VmTerm::Signed8(val) => {
                            *val = val.abs();
                        }
                        VmTerm::Signed16(val) => {
                            *val = val.abs();
                        }
                        VmTerm::Signed32(val) => {
                            *val = val.abs();
                        }
                        VmTerm::Signed64(val) => {
                            *val = val.abs();
                        }
                        VmTerm::Signed128(val) => {
                            *val = val.abs();
                        }
                        VmTerm::SignedBig(val) => {
                            *val = val.clone().abs();
                        }
                        VmTerm::Float32(val) => {
                            *val = val.abs();
                        }
                        VmTerm::Float64(val) => {
                            *val = val.abs();
                        }
                        VmTerm::Decimal(val) => {
                            *val = val.abs();
                        }
                        VmTerm::Signed8Array(val) => {
                            for v in val.iter_mut() {
                                *v = v.abs();
                            }
                        }
                        VmTerm::Signed16Array(val) => {
                            for v in val.iter_mut() {
                                *v = v.abs();
                            }
                        }
                        VmTerm::Signed32Array(val) => {
                            for v in val.iter_mut() {
                                *v = v.abs();
                            }
                        }
                        VmTerm::Signed64Array(val) => {
                            for v in val.iter_mut() {
                                *v = v.abs();
                            }
                        }
                        VmTerm::Signed128Array(val) => {
                            for v in val.iter_mut() {
                                *v = v.abs();
                            }
                        }
                        VmTerm::SignedBigArray(val) => {
                            for v in val.iter_mut() {
                                *v = v.clone().abs();
                            }
                        }
                        VmTerm::Float32Array(val) => {
                            for v in val.iter_mut() {
                                *v = v.abs();
                            }
                        }
                        VmTerm::Float64Array(val) => {
                            for v in val.iter_mut() {
                                *v = v.abs();
                            }
                        }
                        VmTerm::DecimalArray(val) => {
                            for v in val.iter_mut() {
                                *v = v.abs();
                            }
                        }
                        _ => {} // Do nothing
                    }
                }

                ScriptEntry::Opcode(OP::Add1) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = exec_stack.last_mut().unwrap();
                    if last.add_one().is_none() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::Ln) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = exec_stack.last_mut().unwrap();
                    if last.ln(exec_count).is_none() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::Exp) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = exec_stack.last_mut().unwrap();
                    if last.exp(exec_count).is_none() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::Sqrt) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = exec_stack.last_mut().unwrap();
                    if last.sqrt(exec_count).is_none() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::Min) => {
                    let len = exec_stack.len();
                    if len < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    if !exec_stack[len - 1].is_comparable(&exec_stack[len - 2]) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if exec_stack[len - 1] < exec_stack[len - 2] {
                        let e = exec_stack.remove(len - 2_usize);
                        *memory_size -= e.size();
                    } else {
                        let e = exec_stack.pop().unwrap();
                        *memory_size -= e.size();
                    }
                }

                ScriptEntry::Opcode(OP::Max) => {
                    let len = exec_stack.len();
                    if len < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    if !exec_stack[len - 1].is_comparable(&exec_stack[len - 2]) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if exec_stack[len - 1] > exec_stack[len - 2] {
                        let e = exec_stack.remove(len - 2_usize);
                        *memory_size -= e.size();
                    } else {
                        let e = exec_stack.pop().unwrap();
                        *memory_size -= e.size();
                    }
                }

                ScriptEntry::Opcode(OP::Within) => {
                    let len = exec_stack.len();
                    if len < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    if !exec_stack[len - 1].is_comparable(&exec_stack[len - 2])
                        || !exec_stack[len - 1].is_comparable(&exec_stack[len - 3])
                    {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    let left = exec_stack.pop().unwrap();
                    let right = exec_stack.pop().unwrap();

                    *memory_size -= top.size();
                    *memory_size -= left.size();
                    *memory_size -= right.size();

                    if left <= top && top < right {
                        // left-inclusive
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::Sub1) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let mut last = exec_stack.last_mut().unwrap();
                    if last.sub_one().is_none() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::Add) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match second.add(&mut last, exec_count) {
                        Some(()) => {
                            *memory_size += second.size();
                            exec_stack.push(second);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Sub) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match second.sub(&mut last, exec_count) {
                        Some(()) => {
                            *memory_size += second.size();
                            exec_stack.push(second);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Mult) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match second.mul(&mut last, exec_count) {
                        Some(()) => {
                            *memory_size += second.size();
                            exec_stack.push(second);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Div) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match second.div(&mut last, exec_count) {
                        Some(()) => {
                            *memory_size += second.size();
                            exec_stack.push(second);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Pow) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match second.pow(&mut last, exec_count) {
                        Some(()) => {
                            *memory_size += second.size();
                            exec_stack.push(second);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Rem) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match second.rem(&mut last, exec_count) {
                        Some(()) => {
                            *memory_size += second.size();
                            exec_stack.push(second);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Floor) => match exec_stack.pop() {
                    Some(VmTerm::Float32(v)) => {
                        exec_stack.push(VmTerm::Float32(Float32Wrapper(v.0.floor())));
                    }
                    Some(VmTerm::Float64(v)) => {
                        exec_stack.push(VmTerm::Float64(Float64Wrapper(v.0.floor())));
                    }
                    Some(VmTerm::Decimal(v)) => {
                        exec_stack.push(VmTerm::Decimal(v.floor()));
                    }
                    _ => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Ceil) => match exec_stack.pop() {
                    Some(VmTerm::Float32(v)) => {
                        exec_stack.push(VmTerm::Float32(Float32Wrapper(v.0.ceil())));
                    }
                    Some(VmTerm::Float64(v)) => {
                        exec_stack.push(VmTerm::Float64(Float64Wrapper(v.0.ceil())));
                    }
                    Some(VmTerm::Decimal(v)) => {
                        exec_stack.push(VmTerm::Decimal(v.ceil()));
                    }
                    _ => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Trunc) => match exec_stack.pop() {
                    Some(VmTerm::Float32(v)) => {
                        exec_stack.push(VmTerm::Float32(Float32Wrapper(v.0.trunc())));
                    }
                    Some(VmTerm::Float64(v)) => {
                        exec_stack.push(VmTerm::Float64(Float64Wrapper(v.0.trunc())));
                    }
                    Some(VmTerm::Decimal(v)) => {
                        exec_stack.push(VmTerm::Decimal(v.trunc()));
                    }
                    _ => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Frac) => match exec_stack.pop() {
                    Some(VmTerm::Float32(v)) => {
                        exec_stack.push(VmTerm::Float32(Float32Wrapper(v.0.fract())));
                    }
                    Some(VmTerm::Float64(v)) => {
                        exec_stack.push(VmTerm::Float64(Float64Wrapper(v.0.fract())));
                    }
                    Some(VmTerm::Decimal(v)) => {
                        exec_stack.push(VmTerm::Decimal(v.fract()));
                    }
                    _ => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::IsNaN) => match exec_stack.last() {
                    Some(VmTerm::Float32(v)) => {
                        if v.0.is_nan() {
                            exec_stack.push(VmTerm::Unsigned8(1));
                            *memory_size += 1;
                        } else {
                            exec_stack.push(VmTerm::Unsigned8(0));
                            *memory_size += 1;
                        }
                    }
                    Some(VmTerm::Float64(v)) => {
                        if v.0.is_nan() {
                            exec_stack.push(VmTerm::Unsigned8(1));
                            *memory_size += 1;
                        } else {
                            exec_stack.push(VmTerm::Unsigned8(0));
                            *memory_size += 1;
                        }
                    }
                    _ => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::IsInfinite) => match exec_stack.last() {
                    Some(VmTerm::Float32(v)) => {
                        if v.0.is_infinite() {
                            exec_stack.push(VmTerm::Unsigned8(1));
                            *memory_size += 1;
                        } else {
                            exec_stack.push(VmTerm::Unsigned8(0));
                            *memory_size += 1;
                        }
                    }
                    Some(VmTerm::Float64(v)) => {
                        if v.0.is_infinite() {
                            exec_stack.push(VmTerm::Unsigned8(1));
                            *memory_size += 1;
                        } else {
                            exec_stack.push(VmTerm::Unsigned8(0));
                            *memory_size += 1;
                        }
                    }
                    _ => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Round) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    *memory_size -= last.size();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match (second, last) {
                        (VmTerm::Float32(v), VmTerm::Unsigned8(dec)) => {
                            let y = 10i32.pow(dec as u32) as f32;
                            let rounded = (v.0 * y).round() / y;
                            exec_stack.push(VmTerm::Float32(Float32Wrapper(rounded)));
                            *memory_size += 4;
                        }
                        (VmTerm::Float64(v), VmTerm::Unsigned8(dec)) => {
                            let y = 10i32.pow(dec as u32) as f64;
                            let rounded = (v.0 * y).round() / y;
                            exec_stack.push(VmTerm::Float64(Float64Wrapper(rounded)));
                            *memory_size += 8;
                        }
                        (VmTerm::Decimal(v), VmTerm::Unsigned8(dec)) => {
                            let rounded = v.round_dp_with_strategy(
                                dec as u32,
                                RoundingStrategy::MidpointTowardZero,
                            );
                            exec_stack.push(VmTerm::Decimal(rounded));
                            *memory_size += 16;
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::BitSHLeft) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match last.sh_left(&mut second, exec_count) {
                        Some(()) => {
                            exec_stack.push(last);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::BitSHRight) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match last.sh_right(&mut second, exec_count) {
                        Some(()) => {
                            exec_stack.push(last);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::BitXOR) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }

                    let mut last = exec_stack.pop().unwrap();
                    let mut second = exec_stack.pop().unwrap();
                    *memory_size -= second.size();

                    match last.xor(&mut second, exec_count) {
                        Some(()) => {
                            exec_stack.push(last);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::FlushToScriptOuts) => {
                    while let Some(e) = exec_stack.pop() {
                        *memory_size -= e.size();
                        script_outputs.push(e);
                    }
                }

                ScriptEntry::Opcode(OP::PopToScriptOuts) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e = exec_stack.pop().unwrap();
                    *memory_size -= e.size();
                    script_outputs.push(e);
                }

                ScriptEntry::Opcode(OP::PickToScriptOuts) => {
                    self.state = ScriptExecutorState::ExpectingIndexU8(OP::PickToScriptOuts);
                }

                ScriptEntry::Opcode(OP::Eq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 == e2 {
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::Neq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 != e2 {
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::Lt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 < e2 {
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::Gt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 > e2 {
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::Leq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 <= e2 {
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::Geq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 >= e2 {
                        exec_stack.push(VmTerm::Unsigned8(1));
                        *memory_size += 1;
                    } else {
                        exec_stack.push(VmTerm::Unsigned8(0));
                        *memory_size += 1;
                    }
                }

                ScriptEntry::Opcode(OP::GetType) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let tp = exec_stack[exec_stack.len() - 1].get_type();
                    exec_stack.push(VmTerm::Unsigned8(tp));
                    *memory_size += 1;
                }

                ScriptEntry::Opcode(OP::ClearStack) => {
                    exec_stack.clear();
                }

                ScriptEntry::Opcode(OP::Trap) => {
                    self.state = ScriptExecutorState::Error(
                        ExecutionResult::Panic,
                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                    );
                }

                ScriptEntry::Opcode(OP::TrapIf) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    *memory_size -= top.size();

                    if top.equals_1() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::Panic,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::TrapIfEq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 == e2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::Panic,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::TrapIfNeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 != e2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::Panic,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::TrapIfLeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 <= e2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::Panic,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::TrapIfGeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 >= e2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::Panic,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::TrapIfLt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 < e2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::Panic,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::TrapIfGt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if e1 > e2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::Panic,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                }

                ScriptEntry::Opcode(OP::TrapIfNeqType) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ExpectingBytesOrCachedTerm(OP::TrapIfNeqType);
                }

                ScriptEntry::Opcode(OP::PeekArray) => {
                    let len: usize = exec_stack.len();

                    if len == 0 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    match exec_stack[len - 1].peek() {
                        Some(val) => {
                            *memory_size += val.size();
                            exec_stack.push(val);
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::ClearArray) => {
                    let len: usize = exec_stack.len();

                    if len == 0 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let size = exec_stack[len - 1].size();

                    match exec_stack[len - 1].clear() {
                        Some(()) => {
                            *memory_size -= size;

                            // Because the array was cleared, but 'size' contains HEAP_SIZE as well,
                            // we only have to add the HEAP_SIZE back to the 'memory_size'
                            *memory_size += crate::vm::internal::EMPTY_VEC_HEAP_SIZE;
                        }
                        None => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::GhostRider) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let value_to_hash = exec_stack.pop().unwrap();
                    *memory_size -= value_to_hash.size();
                    let new_key = exec_stack.pop().unwrap();
                    *memory_size -= new_key.size();

                    if new_key.get_type() != crate::vm::internal::HASH_KEY_TYPE {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if let VmTerm::Unsigned8Array(arr) = new_key {
                        if arr.len() != 32 {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }

                        let hash_term =
                            bifs::ghostrider256(&value_to_hash, arr.try_into().unwrap());

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    } else {
                        unreachable!()
                    }
                }

                ScriptEntry::Opcode(OP::Fugue) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::fugue256(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::JH256) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::jh256(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Ripemd160) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::ripemd160(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Sha256) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::sha256(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Sha512) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::sha512(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Keccak256) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::keccak256(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Keccak512) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::keccak512(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake2b256) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake2b_256(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake2b512) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake2b_512(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake2s256) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake2s_256(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake3_160) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake3_160(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake3_256) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake3_256(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake3_512) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake3_512(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake3_256_160) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake3_256_160(&val);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake3_256Keyed) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let value_to_hash = exec_stack.pop().unwrap();
                    *memory_size -= value_to_hash.size();
                    let new_key = exec_stack.pop().unwrap();
                    *memory_size -= new_key.size();

                    if new_key.get_type() != crate::vm::internal::HASH_KEY_TYPE {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if let VmTerm::Unsigned8Array(arr) = new_key {
                        let utf8_key = from_utf8(&arr);
                        if utf8_key.is_err() {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }

                        let hash_term =
                            bifs::blake3_256_internal(&value_to_hash, utf8_key.unwrap());

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    } else {
                        unreachable!()
                    }
                }

                ScriptEntry::Opcode(OP::Blake3_512Keyed) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let value_to_hash = exec_stack.pop().unwrap();
                    *memory_size -= value_to_hash.size();
                    let new_key = exec_stack.pop().unwrap();
                    *memory_size -= new_key.size();

                    if new_key.get_type() != crate::vm::internal::HASH_KEY_TYPE {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if let VmTerm::Unsigned8Array(arr) = new_key {
                        let utf8_key = from_utf8(&arr);
                        if utf8_key.is_err() {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }

                        let hash_term =
                            bifs::blake3_512_internal(&value_to_hash, utf8_key.unwrap());

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    } else {
                        unreachable!()
                    }
                }

                ScriptEntry::Opcode(OP::Blake3_160Keyed) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let value_to_hash = exec_stack.pop().unwrap();
                    *memory_size -= value_to_hash.size();
                    let new_key = exec_stack.pop().unwrap();
                    *memory_size -= new_key.size();

                    if new_key.get_type() != crate::vm::internal::HASH_KEY_TYPE {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    if let VmTerm::Unsigned8Array(arr) = new_key {
                        let utf8_key = from_utf8(&arr);
                        if utf8_key.is_err() {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }

                        let hash_term =
                            bifs::blake3_160_internal(&value_to_hash, utf8_key.unwrap());

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    } else {
                        unreachable!()
                    }
                }

                ScriptEntry::Opcode(OP::Blake3_160Internal) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake3_160_internal(&val, key);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake3_256Internal) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake3_256_internal(&val, key);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake3_512Internal) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake3_512_internal(&val, key);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::Blake3_256_160Internal) => match exec_stack.pop() {
                    Some(val) => {
                        *memory_size -= val.size();

                        let hash_term = bifs::blake3_256_160_internal(&val, key);

                        *memory_size += hash_term.size();
                        exec_stack.push(hash_term);
                    }
                    None => {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                    }
                },

                ScriptEntry::Opcode(OP::VerifyEd25519) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let public_key = exec_stack.pop().unwrap();
                    *memory_size -= public_key.size();
                    let mut pub_key_buf = [0; 32];

                    // Check type and length of public key
                    match &public_key {
                        VmTerm::Unsigned8Array(val) if val.len() == 32 => {
                            // Transfer contents to buffer if the validation is successful
                            pub_key_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let signature = exec_stack.pop().unwrap();
                    *memory_size -= signature.size();
                    let mut sig_buf = [0; 64];

                    // Check type and length of signature
                    match &signature {
                        VmTerm::Unsigned8Array(val) if val.len() == 64 => {
                            // Transfer contents to buffer if the validation is successful
                            sig_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let vk = match ed25519_dalek::VerifyingKey::from_bytes(&pub_key_buf) {
                        Ok(vk) => vk,
                        Err(_) => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    };

                    // Push to verification stack and stop script execution
                    verification_stack.push_ed25519(flags.in_binary.clone(), sig_buf.into(), vk);
                    self.state = ScriptExecutorState::Ok;
                }

                ScriptEntry::Opcode(OP::VerifyEd25519Inline) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let public_key = exec_stack.pop().unwrap();
                    *memory_size -= public_key.size();
                    let mut pub_key_buf = [0; 32];

                    // Check type and length of public key
                    match &public_key {
                        VmTerm::Unsigned8Array(val) if val.len() == 32 => {
                            // Transfer contents to buffer if the validation is successful
                            pub_key_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let signature = exec_stack.pop().unwrap();
                    *memory_size -= signature.size();
                    let mut sig_buf = [0; 64];

                    // Check type and length of signature
                    match &signature {
                        VmTerm::Unsigned8Array(val) if val.len() == 64 => {
                            // Transfer contents to buffer if the validation is successful
                            sig_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let message = exec_stack.pop().unwrap();
                    *memory_size -= message.size();

                    // Check type of message
                    match &message {
                        // Validate signature if type validation is successful
                        VmTerm::Unsigned8Array(val) => {
                            match verify_single_ed25519(&pub_key_buf, &sig_buf, val) {
                                Ok(()) => {
                                    // Signature verification successful, push `1` on the execution stack
                                    *memory_size += 1;
                                    exec_stack.push(VmTerm::Unsigned8(1));
                                }
                                Err(_) => {
                                    // Signature verification failed, push `0` on the execution stack
                                    *memory_size += 1;
                                    exec_stack.push(VmTerm::Unsigned8(0));
                                }
                            }
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::VerifyEcdsa) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let public_key = exec_stack.pop().unwrap();
                    *memory_size -= public_key.size();
                    let mut pub_key_buf = [0; 33];

                    // Check type and length of public key
                    match &public_key {
                        VmTerm::Unsigned8Array(val) if val.len() == 33 => {
                            // Transfer contents to buffer if the validation is successful
                            pub_key_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let signature = exec_stack.pop().unwrap();
                    *memory_size -= signature.size();
                    let mut sig_buf = [0; 64];

                    // Check type and length of signature
                    match &signature {
                        VmTerm::Unsigned8Array(val) if val.len() == 64 => {
                            // Transfer contents to buffer if the validation is successful
                            sig_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    // Hash input binary with blake3
                    let mut message_buf = [0u8; 32];
                    let mut hasher = blake3::Hasher::new();
                    hasher.update(&flags.in_binary);
                    let mut out = hasher.finalize_xof();
                    out.fill(&mut message_buf);

                    // Push to verification stack and stop script execution
                    verification_stack.push_ecdsa(message_buf, sig_buf, pub_key_buf);
                    self.state = ScriptExecutorState::Ok;
                }

                ScriptEntry::Opcode(OP::VerifyEcdsaInline) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let public_key = exec_stack.pop().unwrap();
                    *memory_size -= public_key.size();
                    let mut pub_key_buf = [0; 33];

                    // Check type and length of public key
                    match &public_key {
                        VmTerm::Unsigned8Array(val) if val.len() == 33 => {
                            // Transfer contents to buffer if the validation is successful
                            pub_key_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let signature = exec_stack.pop().unwrap();
                    *memory_size -= signature.size();
                    let mut sig_buf = [0; 64];

                    // Check type and length of signature
                    match &signature {
                        VmTerm::Unsigned8Array(val) if val.len() == 64 => {
                            // Transfer contents to buffer if the validation is successful
                            sig_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let message = exec_stack.pop().unwrap();
                    *memory_size -= message.size();

                    // Check type of message
                    match &message {
                        // Validate signature if type validation is successful
                        VmTerm::Hash256(val) => {
                            match verify_single_ecdsa(&pub_key_buf, &sig_buf, val) {
                                Ok(()) => {
                                    // Signature verification successful, push `1` on the execution stack
                                    *memory_size += 1;
                                    exec_stack.push(VmTerm::Unsigned8(1));
                                }
                                Err(_) => {
                                    // Signature verification failed, push `0` on the execution stack
                                    *memory_size += 1;
                                    exec_stack.push(VmTerm::Unsigned8(0));
                                }
                            }
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::VerifyBIP340) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let public_key = exec_stack.pop().unwrap();
                    *memory_size -= public_key.size();
                    let mut pub_key_buf = [0; 32];

                    // Check type and length of public key
                    match &public_key {
                        VmTerm::Unsigned8Array(val) if val.len() == 32 => {
                            // Transfer contents to buffer if the validation is successful
                            pub_key_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let signature = exec_stack.pop().unwrap();
                    *memory_size -= signature.size();
                    let mut sig_buf = [0; 64];

                    // Check type and length of signature
                    match &signature {
                        VmTerm::Unsigned8Array(val) if val.len() == 64 => {
                            // Transfer contents to buffer if the validation is successful
                            sig_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    // Hash input binary with blake3
                    let mut message_buf = [0u8; 32];
                    let mut hasher = blake3::Hasher::new();
                    hasher.update(&flags.in_binary);
                    let mut out = hasher.finalize_xof();
                    out.fill(&mut message_buf);

                    // Push to verification stack and stop script execution
                    verification_stack.push_bip340(message_buf, sig_buf, pub_key_buf);
                    self.state = ScriptExecutorState::Ok;
                }

                ScriptEntry::Opcode(OP::VerifyBIP340Inline) => {
                    if exec_stack.len() < 3 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let public_key = exec_stack.pop().unwrap();
                    *memory_size -= public_key.size();
                    let mut pub_key_buf = [0; 32];

                    // Check type and length of public key
                    match &public_key {
                        VmTerm::Unsigned8Array(val) if val.len() == 32 => {
                            // Transfer contents to buffer if the validation is successful
                            pub_key_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let signature = exec_stack.pop().unwrap();
                    *memory_size -= signature.size();
                    let mut sig_buf = [0; 64];

                    // Check type and length of signature
                    match &signature {
                        VmTerm::Unsigned8Array(val) if val.len() == 64 => {
                            // Transfer contents to buffer if the validation is successful
                            sig_buf.copy_from_slice(val.as_slice());
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                            return;
                        }
                    }

                    let message = exec_stack.pop().unwrap();
                    *memory_size -= message.size();

                    // Check type of message
                    match &message {
                        // Validate signature if type validation is successful
                        VmTerm::Hash256(val) => {
                            match verify_single_bip340(&pub_key_buf, &sig_buf, val) {
                                Ok(()) => {
                                    // Signature verification successful, push `1` on the execution stack
                                    *memory_size += 1;
                                    exec_stack.push(VmTerm::Unsigned8(1));
                                }
                                Err(_) => {
                                    // Signature verification failed, push `0` on the execution stack
                                    *memory_size += 1;
                                    exec_stack.push(VmTerm::Unsigned8(0));
                                }
                            }
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::PushExecCount) => {
                    exec_stack.push(VmTerm::Unsigned64(*exec_count));
                    *memory_size += 8;
                }

                ScriptEntry::Opcode(OP::If) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    *memory_size -= top.size();

                    self.state = ScriptExecutorState::ControlOperator(Some(top.equals_1()));
                }

                ScriptEntry::Opcode(OP::Ifn) => {
                    if exec_stack.is_empty() {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let top = exec_stack.pop().unwrap();
                    *memory_size -= top.size();

                    self.state = ScriptExecutorState::ControlOperator(Some(!top.equals_1()));
                }

                ScriptEntry::Opcode(OP::Else) => {
                    self.state = ScriptExecutorState::ControlOperator(None);
                }

                ScriptEntry::Opcode(OP::IfLt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ControlOperator(Some(e1 < e2));
                }

                ScriptEntry::Opcode(OP::IfGt) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ControlOperator(Some(e1 > e2));
                }

                ScriptEntry::Opcode(OP::IfLeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ControlOperator(Some(e1 <= e2));
                }

                ScriptEntry::Opcode(OP::IfGeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ControlOperator(Some(e1 >= e2));
                }

                ScriptEntry::Opcode(OP::IfEq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ControlOperator(Some(e1 == e2));
                }

                ScriptEntry::Opcode(OP::IfNeq) => {
                    if exec_stack.len() < 2 {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    let e1 = exec_stack.pop().unwrap();
                    *memory_size -= e1.size();
                    let e2 = exec_stack.pop().unwrap();
                    *memory_size -= e2.size();

                    if !e1.is_comparable(&e2) {
                        self.state = ScriptExecutorState::Error(
                            ExecutionResult::InvalidArgs,
                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                        );
                        return;
                    }

                    self.state = ScriptExecutorState::ControlOperator(Some(e1 != e2));
                }

                ScriptEntry::Opcode(OP::CallBody) => {
                    match exec_stack.pop() {
                        Some(VmTerm::Unsigned8Array(val)) => {
                            let script_hash = Hash256::hash_from_slice(&val, "");

                            if script_stack.len() >= MAX_SCRIPTS {
                                self.state = ScriptExecutorState::Error(
                                    ExecutionResult::TooManyScripts,
                                    (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                                );
                            }

                            // Check if we loaded the script yet
                            match script_storage.get(&script_hash) {
                                Some(script_ref) => {
                                    // Signal to push a new frame
                                    self.state = ScriptExecutorState::NewCallBodyFrameCached(
                                        script_ref.clone(),
                                    );
                                }
                                None => match crate::codec::decode::<Script>(&val) {
                                    Ok(script) => {
                                        // Increment gas with the length of the script
                                        *exec_count += val.len() as u64;

                                        // Signal to push a new frame
                                        self.state = ScriptExecutorState::NewCallBodyFrame(
                                            script_hash,
                                            Rc::new(script),
                                        );
                                    }
                                    _ => {
                                        self.state = ScriptExecutorState::Error(
                                            ExecutionResult::InvalidArgs,
                                            (i_ptr, func_idx, op.clone(), exec_stack.as_slice())
                                                .into(),
                                        );
                                    }
                                },
                            }
                        }
                        _ => {
                            self.state = ScriptExecutorState::Error(
                                ExecutionResult::InvalidArgs,
                                (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                            );
                        }
                    }
                }

                ScriptEntry::Opcode(OP::Nop) => {
                    // do nothing
                }

                ScriptEntry::Opcode(_) => {
                    self.state = ScriptExecutorState::Error(
                        ExecutionResult::BadFormat,
                        (i_ptr, func_idx, op.clone(), exec_stack.as_slice()).into(),
                    );
                }
            },
            _ => {
                unreachable!();
            }
        }
    }

    #[inline]
    #[must_use]
    pub fn done(&self) -> Option<Result<ExecutionResult, (ExecutionResult, StackTrace)>> {
        match &self.state {
            ScriptExecutorState::OkVerify => Some(Ok(ExecutionResult::OkVerify)),
            ScriptExecutorState::Ok => Some(Ok(ExecutionResult::Ok)),
            ScriptExecutorState::Error(res, trace) => Some(Err((*res, trace.clone()))),
            _ => None,
        }
    }

    #[inline]
    #[must_use]
    fn check_condition_push_out(
        exec_stack: &mut Vec<VmTerm>,
        memory_size: &mut usize,
        op: ScriptEntry,
    ) -> Result<bool, ()> {
        match op {
            ScriptEntry::Opcode(OP::PushOut) => Ok(true),
            ScriptEntry::Opcode(OP::PushOutIf) => {
                if exec_stack.is_empty() {
                    return Err(());
                }

                let top = exec_stack.pop().unwrap();
                *memory_size -= top.size();

                Ok(top.equals_1())
            }
            _ => {
                if exec_stack.len() < 2 {
                    return Err(());
                }

                let e1 = exec_stack.pop().unwrap();
                *memory_size -= e1.size();
                let e2 = exec_stack.pop().unwrap();
                *memory_size -= e2.size();

                if !e1.is_comparable(&e2) {
                    return Err(());
                }

                match op {
                    ScriptEntry::Opcode(OP::PushOutIfEq) => Ok(e1 == e2),
                    ScriptEntry::Opcode(OP::PushOutIfNeq) => Ok(e1 != e2),
                    ScriptEntry::Opcode(OP::PushOutIfLt) => Ok(e1 < e2),
                    ScriptEntry::Opcode(OP::PushOutIfGt) => Ok(e1 > e2),
                    ScriptEntry::Opcode(OP::PushOutIfLeq) => Ok(e1 <= e2),
                    ScriptEntry::Opcode(OP::PushOutIfGeq) => Ok(e1 >= e2),
                    _ => unreachable!(),
                }
            }
        }
    }
}

#[derive(Debug, Clone)]
enum ScriptExecutorState {
    /// Expecting script arguments length
    ExpectingArgsLen,

    /// Expecting any valid opcode in the default state
    ExpectingInitialOP,

    /// Expecting bytes or a cached term
    ExpectingBytesOrCachedTerm(OP),

    /// Expecting random term
    ExpectingRandomTerm(OP),

    /// Expecting an u8 index for an opcode
    ExpectingIndexU8(OP),

    /// A new frame should be pushed to the stack and marked as loop
    NewLoopFrame,

    /// A new frame should be pushed to the stack with a dynamic script
    NewCallBodyFrame(Hash256, Rc<Script>),

    /// A new frame should be pushed to the stack with a dynamic script that is cached
    NewCallBodyFrameCached(Rc<Script>),

    /// The current block has reached the final execution state
    EndBlock,

    /// Break the current loop
    BreakLoop,

    /// Continue to the next iteration of the current loop
    ContinueLoop,

    /// A control operator decision has to be made
    ///
    /// Some(true), the `If` block will be executed
    /// Some(false), the `Else` block will be executed if exists, skips the block otherwise
    /// None, the `If` block was executed and got to its end, block will be exited
    ControlOperator(Option<bool>),

    /// We hit an OP_ReturnFunc
    ReturnFunc,

    /// Return success code and push message and signature to the verification stack
    OkVerify,

    /// Return success code
    Ok,

    /// Error
    Error(ExecutionResult, StackTrace),
}

impl Encode for Script {
    fn encode<E: bincode::enc::Encoder>(
        &self,
        encoder: &mut E,
    ) -> core::result::Result<(), bincode::error::EncodeError> {
        if let ScriptEntry::Byte(len) = &self.script[0] {
            debug_assert_eq!(*len as usize, self.malleable_args.len());
            // Encode script length + bitmaps length
            bincode::Encode::encode(&(self.script.len() + (*len >> 3) as usize + 1), encoder)?;
            // Encode args length
            bincode::Encode::encode(len, encoder)?;
        } else {
            unreachable!();
        }

        // Encode bitmaps
        for chunk in self.malleable_args.chunks(8) {
            let mut bitmap: u8 = 0x00;
            for (i, val) in chunk.iter().enumerate() {
                let v = u8::from(*val);
                bitmap = set_bit!(bitmap, i as u8, v);
            }
            bincode::Encode::encode(&bitmap, encoder)?;
        }

        // Encode script
        for e in &self.script[1..] {
            match e {
                ScriptEntry::Opcode(op) => {
                    bincode::Encode::encode(&op.to_u8().unwrap(), encoder)?;
                }

                ScriptEntry::Byte(byte) => {
                    bincode::Encode::encode(byte, encoder)?;
                }
            }
        }

        Ok(())
    }
}

impl Decode for Script {
    fn decode<D: bincode::de::Decoder>(
        decoder: &mut D,
    ) -> core::result::Result<Self, bincode::error::DecodeError> {
        let len: u16 = bincode::Decode::decode(decoder)?;
        let len = len as usize;
        let mut script_parser = ScriptParser::new(len);

        for _ in 0..len {
            let byte: u8 = bincode::Decode::decode(decoder)?;

            script_parser
                .push_byte(byte)
                .map_err(|err| bincode::error::DecodeError::OtherString(err.to_owned()))?;
        }

        let (script, malleable_args, functions) = script_parser.out();

        Ok(Self {
            script,
            functions,
            malleable_args,
        })
    }
}

struct ScriptParser {
    state: ScriptParserState,
    out: Vec<ScriptEntry>,
    malleable_args: BitVec,
    current_func: Option<Vec<ScriptEntry>>,
    functions: Vec<Vec<ScriptEntry>>,
}

macro_rules! push_out {
    ($self:expr, $entry:expr) => {{
        if let Some(ref mut func) = &mut $self.current_func {
            func.push($entry);
        } else {
            $self.out.push($entry);
        }
    }};
}

macro_rules! impl_parser_expecting_bytes {
    ($self:expr, $op:expr, $len:expr) => {{
        push_out!($self, ScriptEntry::Opcode($op));

        match &$self.state {
            ScriptParserState::ExpectingOP => {
                $self.state = ScriptParserState::ExpectingBytes($len, None, true);
            }

            ScriptParserState::ExpectingOPButNotFuncOrEnd => {
                $self.state = ScriptParserState::ExpectingBytes($len, None, false);
            }

            ScriptParserState::ExpectingOPCF(cf_stack, blocks_allowed) => {
                $self.state = ScriptParserState::ExpectingBytes(
                    $len,
                    Some(cf_stack.clone()),
                    *blocks_allowed,
                );
            }

            _ => unreachable!(),
        }

        Ok(())
    }};
}

macro_rules! impl_parser_expecting_len {
    ($self:expr, $op:expr) => {{
        push_out!($self, ScriptEntry::Opcode($op));

        match &$self.state {
            ScriptParserState::ExpectingOP => {
                $self.state = ScriptParserState::ExpectingLen($op, 0, 0, None, true);
            }

            ScriptParserState::ExpectingOPButNotFuncOrEnd => {
                $self.state = ScriptParserState::ExpectingLen($op, 0, 0, None, false);
            }

            ScriptParserState::ExpectingOPCF(cf_stack, blocks_allowed) => {
                $self.state = ScriptParserState::ExpectingLen(
                    $op,
                    0,
                    0,
                    Some(cf_stack.clone()),
                    *blocks_allowed,
                );
            }

            _ => unreachable!(),
        }

        Ok(())
    }};
}

impl ScriptParser {
    pub fn new(len: usize) -> Self {
        Self {
            state: ScriptParserState::ExpectingArgsLen,
            out: Vec::with_capacity(len),
            malleable_args: bitvec_from_bools![],
            current_func: None,
            functions: vec![],
        }
    }

    fn _out(&mut self) -> &mut Vec<ScriptEntry> {
        if let Some(ref mut func) = &mut self.current_func {
            func
        } else {
            &mut self.out
        }
    }

    pub fn push_byte(&mut self, byte: u8) -> Result<(), &'static str> {
        match &mut self.state {
            ScriptParserState::ExpectingArgsLen => {
                self.out.push(ScriptEntry::Byte(byte));
                if byte == 0x00 {
                    self.state = ScriptParserState::ExpectingOPButNotFuncOrEnd;
                    Ok(())
                } else {
                    let bitmaps = (byte >> 3) + 1;
                    self.state = ScriptParserState::ExpectingScriptFlags(
                        bitmaps,
                        byte,
                        BitVec::with_capacity(bitmaps as usize),
                    );
                    Ok(())
                }
            }

            ScriptParserState::ExpectingFuncArgsLen => {
                push_out!(self, ScriptEntry::Byte(byte));
                self.state = ScriptParserState::ExpectingOP;
                Ok(())
            }

            ScriptParserState::ExpectingScriptFlags(
                ref mut bitmaps,
                total,
                ref mut malleable_args,
            ) if bitmaps > &mut 1 => {
                malleable_args.push(check_bit!(byte, 0));
                malleable_args.push(check_bit!(byte, 1));
                malleable_args.push(check_bit!(byte, 2));
                malleable_args.push(check_bit!(byte, 3));
                malleable_args.push(check_bit!(byte, 4));
                malleable_args.push(check_bit!(byte, 5));
                malleable_args.push(check_bit!(byte, 6));
                malleable_args.push(check_bit!(byte, 7));
                *bitmaps -= 1;
                Ok(())
            }

            ScriptParserState::ExpectingScriptFlags(bitmaps, total, ref mut malleable_args)
                if bitmaps == &1 =>
            {
                let m = *total % 8;
                for i in 0..m {
                    malleable_args.push(check_bit!(byte, i));
                }
                self.malleable_args = malleable_args.clone();
                self.state = ScriptParserState::ExpectingOPButNotFuncOrEnd;
                Ok(())
            }

            ScriptParserState::ExpectingScriptFlags(_, _, _) => {
                unreachable!()
            }

            ScriptParserState::ExpectingOP
            | ScriptParserState::ExpectingOPButNotFuncOrEnd
            | ScriptParserState::ExpectingOPCF(_, _) => match OP::from_u8(byte) {
                Some(OP::Unsigned8Var) => impl_parser_expecting_bytes!(self, OP::Unsigned8Var, 1),
                Some(OP::Signed8Var) => impl_parser_expecting_bytes!(self, OP::Unsigned8Var, 1),
                Some(OP::Unsigned16Var) => impl_parser_expecting_bytes!(self, OP::Unsigned16Var, 2),
                Some(OP::Signed16Var) => impl_parser_expecting_bytes!(self, OP::Unsigned16Var, 2),
                Some(OP::Unsigned32Var) => impl_parser_expecting_bytes!(self, OP::Unsigned32Var, 4),
                Some(OP::Signed32Var) => impl_parser_expecting_bytes!(self, OP::Unsigned32Var, 4),
                Some(OP::Float32Var) => impl_parser_expecting_bytes!(self, OP::Float32Var, 4),
                Some(OP::Unsigned64Var) => impl_parser_expecting_bytes!(self, OP::Unsigned64Var, 8),
                Some(OP::Signed64Var) => impl_parser_expecting_bytes!(self, OP::Unsigned64Var, 8),
                Some(OP::Float64Var) => impl_parser_expecting_bytes!(self, OP::Float64Var, 8),
                Some(OP::DecimalVar) => impl_parser_expecting_bytes!(self, OP::DecimalVar, 16),
                Some(OP::Unsigned128Var) => {
                    impl_parser_expecting_bytes!(self, OP::Unsigned128Var, 16)
                }
                Some(OP::Signed128Var) => {
                    impl_parser_expecting_bytes!(self, OP::Unsigned128Var, 16)
                }
                Some(OP::UnsignedBigVar) => {
                    impl_parser_expecting_bytes!(self, OP::UnsignedBigVar, 32)
                }
                Some(OP::SignedBigVar) => impl_parser_expecting_bytes!(self, OP::SignedBigVar, 32),
                Some(OP::Hash160Var) => impl_parser_expecting_bytes!(self, OP::Hash160Var, 20),
                Some(OP::Hash256Var) => impl_parser_expecting_bytes!(self, OP::Hash256Var, 32),
                Some(OP::Hash512Var) => impl_parser_expecting_bytes!(self, OP::Hash512Var, 64),
                Some(OP::Pick) => impl_parser_expecting_bytes!(self, OP::Pick, 1),
                Some(OP::Roll) => impl_parser_expecting_bytes!(self, OP::Roll, 1),
                Some(OP::PickToScriptOuts) => {
                    impl_parser_expecting_bytes!(self, OP::PickToScriptOuts, 1)
                }
                Some(OP::GetAtArray) => impl_parser_expecting_bytes!(self, OP::GetAtArray, 2),
                Some(OP::DeleteAtArray) => impl_parser_expecting_bytes!(self, OP::DeleteAtArray, 2),
                Some(OP::CastTo) => impl_parser_expecting_bytes!(self, OP::CastTo, 1),
                Some(OP::Hash160ArrayVar) => impl_parser_expecting_len!(self, OP::Hash160ArrayVar),
                Some(OP::Hash256ArrayVar) => impl_parser_expecting_len!(self, OP::Hash256ArrayVar),
                Some(OP::Hash512ArrayVar) => impl_parser_expecting_len!(self, OP::Hash512ArrayVar),
                Some(OP::Unsigned8ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Unsigned8ArrayVar)
                }
                Some(OP::Signed8ArrayVar) => impl_parser_expecting_len!(self, OP::Signed8ArrayVar),
                Some(OP::Unsigned16ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Unsigned16ArrayVar)
                }
                Some(OP::Signed16ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Signed16ArrayVar)
                }
                Some(OP::Unsigned32ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Unsigned32ArrayVar)
                }
                Some(OP::Signed32ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Signed32ArrayVar)
                }
                Some(OP::Unsigned64ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Unsigned64ArrayVar)
                }
                Some(OP::Signed64ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Signed64ArrayVar)
                }
                Some(OP::Unsigned128ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Unsigned128ArrayVar)
                }
                Some(OP::Signed128ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Signed128ArrayVar)
                }
                Some(OP::UnsignedBigArrayVar) => {
                    impl_parser_expecting_len!(self, OP::UnsignedBigArrayVar)
                }
                Some(OP::SignedBigArrayVar) => {
                    impl_parser_expecting_len!(self, OP::SignedBigArrayVar)
                }
                Some(OP::Float32ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Float32ArrayVar)
                }
                Some(OP::Float64ArrayVar) => {
                    impl_parser_expecting_len!(self, OP::Float64ArrayVar)
                }
                Some(OP::DecimalArrayVar) => {
                    impl_parser_expecting_len!(self, OP::DecimalArrayVar)
                }
                Some(OP::InputScriptArgsLen) => {
                    impl_parser_expecting_bytes!(self, OP::InputScriptArgsLen, 2)
                }
                Some(OP::SpillInputScriptArgs) => {
                    impl_parser_expecting_bytes!(self, OP::SpillInputScriptArgs, 2)
                }
                Some(OP::SpillScriptOuts) => {
                    impl_parser_expecting_bytes!(self, OP::SpillScriptOuts, 2)
                }
                Some(OP::GetInputScriptArgAt) => {
                    impl_parser_expecting_bytes!(self, OP::GetInputScriptArgAt, 4)
                }
                Some(OP::GetOutScriptOut) => {
                    impl_parser_expecting_bytes!(self, OP::GetOutScriptOut, 4)
                }
                Some(OP::GetOutAmount) => {
                    impl_parser_expecting_bytes!(self, OP::GetOutAmount, 2)
                }
                Some(OP::IsColouredOut) => {
                    impl_parser_expecting_bytes!(self, OP::IsColouredOut, 2)
                }
                Some(OP::ColourHash) => {
                    impl_parser_expecting_bytes!(self, OP::ColourHash, 2)
                }
                Some(OP::GetOutReceiver) => {
                    impl_parser_expecting_bytes!(self, OP::GetOutReceiver, 2)
                }
                Some(OP::GetOutScriptOutsLen) => {
                    impl_parser_expecting_bytes!(self, OP::GetOutScriptOutsLen, 2)
                }
                Some(OP::GetOutScriptHash) => {
                    impl_parser_expecting_bytes!(self, OP::GetOutScriptHash, 2)
                }
                Some(OP::PushPrevScriptOuts) => {
                    impl_parser_expecting_bytes!(self, OP::PushPrevScriptOuts, 2)
                }
                Some(OP::GetSpentOutScriptOut) => {
                    impl_parser_expecting_bytes!(self, OP::GetSpentOutScriptOut, 2)
                }
                Some(OP::Substr) => impl_parser_expecting_bytes!(self, OP::Substr, 2),
                Some(OP::TrapIfNeqType) => impl_parser_expecting_bytes!(self, OP::TrapIfNeqType, 1),
                Some(OP::Func | OP::End)
                    if matches!(self.state, ScriptParserState::ExpectingOPButNotFuncOrEnd) =>
                {
                    Err("did not expect a func or end opcode")
                }
                Some(OP::Func) if matches!(self.state, ScriptParserState::ExpectingOP) => {
                    if self.current_func.is_some() {
                        return Err("invalid function declaration, did not expect an OP_Func");
                    }
                    self.current_func = Some(vec![]);
                    self.state = ScriptParserState::ExpectingFuncArgsLen;
                    Ok(())
                }
                Some(OP::End) if matches!(self.state, ScriptParserState::ExpectingOP) => {
                    if self.current_func.is_none() {
                        return Err("invalid function declaration, did not expect an OP_End");
                    }
                    let func = self.current_func.take().unwrap();
                    self.functions.push(func);
                    Ok(())
                }
                Some(OP::End) if !matches!(self.state, ScriptParserState::ExpectingOPCF(_, _)) => {
                    Err("invalid script, did not expect an end opcode")
                }
                Some(OP::End) if matches!(self.state, ScriptParserState::ExpectingOPCF(_, _)) => {
                    push_out!(self, ScriptEntry::Opcode(OP::End));
                    let mut empty_cf_stack = false;
                    let mut ba = false;
                    if let ScriptParserState::ExpectingOPCF(ref mut cf_stack, blocks_allowed) =
                        self.state
                    {
                        cf_stack.pop();
                        if cf_stack.is_empty() {
                            empty_cf_stack = true;
                            ba = blocks_allowed;
                        }
                    } else {
                        unreachable!();
                    }
                    if empty_cf_stack {
                        if ba {
                            self.state = ScriptParserState::ExpectingOP;
                        } else {
                            self.state = ScriptParserState::ExpectingOPButNotFuncOrEnd;
                        }
                    }
                    Ok(())
                }
                Some(OP::Else) if !matches!(self.state, ScriptParserState::ExpectingOPCF(_, _)) => {
                    Err("invalid script, did not expect an else opcode")
                }
                Some(OP::Else) if matches!(self.state, ScriptParserState::ExpectingOPCF(_, _)) => {
                    if let ScriptParserState::ExpectingOPCF(ref mut cf_stack, _) = self.state {
                        let top = cf_stack.pop();

                        if let Some(ControlFlowState::Conditional) = top {
                            push_out!(self, ScriptEntry::Opcode(OP::Else));
                            cf_stack.push(ControlFlowState::Else);
                        } else {
                            return Err("invalid script, did not expect an else opcode");
                        }
                    } else {
                        unreachable!();
                    }
                    Ok(())
                }
                Some(OP::Loop) if matches!(self.state, ScriptParserState::ExpectingOP) => {
                    push_out!(self, ScriptEntry::Opcode(OP::Loop));
                    self.state =
                        ScriptParserState::ExpectingOPCF(vec![ControlFlowState::Loop], true);
                    Ok(())
                }
                Some(OP::Loop)
                    if matches!(self.state, ScriptParserState::ExpectingOPButNotFuncOrEnd) =>
                {
                    push_out!(self, ScriptEntry::Opcode(OP::Loop));
                    self.state =
                        ScriptParserState::ExpectingOPCF(vec![ControlFlowState::Loop], false);
                    Ok(())
                }
                Some(OP::Loop) if matches!(self.state, ScriptParserState::ExpectingOPCF(_, _)) => {
                    push_out!(self, ScriptEntry::Opcode(OP::Loop));
                    if let ScriptParserState::ExpectingOPCF(ref mut cf_stack, _) = self.state {
                        cf_stack.push(ControlFlowState::Loop);
                    } else {
                        unreachable!();
                    }
                    Ok(())
                }
                Some(
                    op @ (OP::If
                    | OP::Ifn
                    | OP::IfLt
                    | OP::IfGt
                    | OP::IfLeq
                    | OP::IfGeq
                    | OP::IfEq
                    | OP::IfNeq),
                ) if matches!(self.state, ScriptParserState::ExpectingOP) => {
                    push_out!(self, ScriptEntry::Opcode(op));
                    self.state =
                        ScriptParserState::ExpectingOPCF(vec![ControlFlowState::Conditional], true);
                    Ok(())
                }
                Some(
                    op @ (OP::If
                    | OP::Ifn
                    | OP::IfLt
                    | OP::IfGt
                    | OP::IfLeq
                    | OP::IfGeq
                    | OP::IfEq
                    | OP::IfNeq),
                ) if matches!(self.state, ScriptParserState::ExpectingOPButNotFuncOrEnd) => {
                    push_out!(self, ScriptEntry::Opcode(op));
                    self.state = ScriptParserState::ExpectingOPCF(
                        vec![ControlFlowState::Conditional],
                        false,
                    );
                    Ok(())
                }
                Some(
                    op @ (OP::If
                    | OP::Ifn
                    | OP::IfLt
                    | OP::IfGt
                    | OP::IfLeq
                    | OP::IfGeq
                    | OP::IfEq
                    | OP::IfNeq),
                ) if matches!(self.state, ScriptParserState::ExpectingOPCF(_, _)) => {
                    push_out!(self, ScriptEntry::Opcode(op));
                    if let ScriptParserState::ExpectingOPCF(ref mut cf_stack, _) = self.state {
                        cf_stack.push(ControlFlowState::Conditional);
                    } else {
                        unreachable!();
                    }
                    Ok(())
                }
                Some(OP::Call) => {
                    push_out!(self, ScriptEntry::Opcode(OP::Call));

                    match &self.state {
                        ScriptParserState::ExpectingOPButNotFuncOrEnd => {
                            self.state = ScriptParserState::ExpectingBytes(1, None, true);
                        }
                        ScriptParserState::ExpectingOPCF(cf_stack, allows_funcs)
                            if !*allows_funcs =>
                        {
                            self.state =
                                ScriptParserState::ExpectingBytes(1, Some(cf_stack.clone()), true);
                        }
                        _ => {} // Do nothing
                    }

                    Ok(())
                }
                Some(op) => {
                    push_out!(self, ScriptEntry::Opcode(op));
                    Ok(())
                }
                None => Err("invalid op"),
            },

            ScriptParserState::ExpectingBytes(ref mut i, cf_stack, blocks_allowed) => {
                push_out!(self, ScriptEntry::Byte(byte));
                *i -= 1;

                if *i == 0 {
                    match cf_stack {
                        Some(cf_stack) => {
                            self.state =
                                ScriptParserState::ExpectingOPCF(cf_stack.clone(), *blocks_allowed);
                        }
                        None => {
                            if *blocks_allowed {
                                self.state = ScriptParserState::ExpectingOP;
                            } else {
                                self.state = ScriptParserState::ExpectingOPButNotFuncOrEnd;
                            }
                        }
                    }
                }

                Ok(())
            }

            ScriptParserState::ExpectingLen(
                op,
                ref mut sum,
                ref mut i,
                cf_stack,
                blocks_allowed,
            ) => {
                push_out!(self, ScriptEntry::Byte(byte));
                let b = u16::from(byte);
                if *i == 0 {
                    *sum += b;
                } else {
                    *sum += b << 8;
                }
                *i += 1;

                if *i == 2 {
                    match op {
                        OP::Hash160ArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum * 20) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        OP::Hash256ArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum * 32) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        OP::Hash512ArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum * 64) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        OP::Unsigned8ArrayVar | OP::Signed8ArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        OP::Unsigned16ArrayVar | OP::Signed16ArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum * 2) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        OP::Unsigned32ArrayVar | OP::Signed32ArrayVar | OP::Float32ArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum * 4) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        OP::Unsigned64ArrayVar | OP::Signed64ArrayVar | OP::Float64ArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum * 8) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        OP::Unsigned128ArrayVar | OP::Signed128ArrayVar | OP::DecimalArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum * 16) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        OP::UnsignedBigArrayVar | OP::SignedBigArrayVar => {
                            self.state = ScriptParserState::ExpectingBytes(
                                (*sum * 32) as usize,
                                cf_stack.clone(),
                                *blocks_allowed,
                            );
                            Ok(())
                        }
                        _ => unreachable!(),
                    }
                } else {
                    Ok(())
                }
            }
        }
    }

    pub fn out(self) -> (Vec<ScriptEntry>, BitVec, Vec<Vec<ScriptEntry>>) {
        (self.out, self.malleable_args, self.functions)
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct StackTrace {
    pub trace: Vec<TraceItem>,
    pub top_frame_stack: Vec<VmTerm>,
}

impl StackTrace {
    pub fn extend_from_frame_stack(&mut self, stack: &[Frame], script: &Script) {
        let trace = stack.iter().rev().take(TRACE_SIZE).map(|frame| TraceItem {
            i_ptr: frame.i_ptr,
            func_idx: frame.func_idx,
            entry: script.script[frame.i_ptr].clone(),
        });

        self.trace.extend(trace);
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct TraceItem {
    pub(crate) func_idx: Option<usize>,
    pub(crate) i_ptr: usize,
    pub(crate) entry: ScriptEntry,
}

impl From<(usize, Option<usize>, ScriptEntry, &[VmTerm])> for StackTrace {
    fn from(
        (i_ptr, func_idx, entry, top_frame_stack): (usize, Option<usize>, ScriptEntry, &[VmTerm]),
    ) -> Self {
        let ti = TraceItem {
            func_idx,
            i_ptr,
            entry,
        };

        Self {
            trace: vec![ti],
            top_frame_stack: top_frame_stack
                .iter()
                .rev()
                .take(TRACE_SIZE)
                .cloned()
                .collect(),
        }
    }
}

impl From<(usize, Option<usize>, OP, &[VmTerm])> for StackTrace {
    fn from(
        (i_ptr, func_idx, entry, top_frame_stack): (usize, Option<usize>, OP, &[VmTerm]),
    ) -> Self {
        (i_ptr, func_idx, ScriptEntry::Opcode(entry), top_frame_stack).into()
    }
}

impl From<(usize, Option<usize>, OP)> for TraceItem {
    fn from((i_ptr, func_idx, entry): (usize, Option<usize>, OP)) -> Self {
        (i_ptr, func_idx, ScriptEntry::Opcode(entry)).into()
    }
}

impl From<(usize, Option<usize>, ScriptEntry)> for TraceItem {
    fn from((i_ptr, func_idx, entry): (usize, Option<usize>, ScriptEntry)) -> Self {
        Self {
            func_idx,
            i_ptr,
            entry,
        }
    }
}

// Don't compare stack traces
impl PartialEq for VmResult {
    fn eq(&self, other: &Self) -> bool {
        match (&self.0, &other.0) {
            (Ok(res1), Ok(res2)) => res1 == res2,
            (Err((res1, _)), Err((res2, _))) => res1 == res2,
            _ => false,
        }
    }
}

#[derive(Clone, Debug)]
pub struct VmResult(pub Result<ExecutionResult, (ExecutionResult, StackTrace)>);

impl VmResult {
    #[must_use]
    pub fn is_ok(&self) -> bool {
        self.0.is_ok()
    }

    #[must_use]
    pub fn is_err(&self) -> bool {
        self.0.is_err()
    }

    pub fn to_inner(self) -> Result<ExecutionResult, (ExecutionResult, StackTrace)> {
        self.0
    }
}

impl From<Result<ExecutionResult, (ExecutionResult, StackTrace)>> for VmResult {
    fn from(other: Result<ExecutionResult, (ExecutionResult, StackTrace)>) -> Self {
        Self(other)
    }
}

enum ScriptParserState {
    /// Expecting main function arguments length
    ExpectingArgsLen,

    /// Expecting function arguments length
    ExpectingFuncArgsLen,

    /// Expecting script flags. The state tuple is (remaining_bitmaps, args_len, bitmaps_vec)
    ExpectingScriptFlags(u8, u8, BitVec),

    /// Expecting any OP
    ExpectingOP,

    /// Expecting any OP except OP_Func or OP_End
    ExpectingOPButNotFuncOrEnd,

    /// Expecting any OP while also tracking the Control Flow
    ExpectingOPCF(Vec<ControlFlowState>, bool),

    /// Expecting n bytes. The state tuple is (num_bytes, cf_stack, funcs_allowed)
    ExpectingBytes(usize, Option<Vec<ControlFlowState>>, bool),

    /// Expecting length for for OP
    ExpectingLen(OP, u16, usize, Option<Vec<ControlFlowState>>, bool),
}

#[derive(Clone, Debug)]
enum ControlFlowState {
    /// We hit a loop opcode
    Loop,

    /// We hit a conditional opcode
    Conditional,

    /// We hit an else opcode
    Else,
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum ScriptErr {
    InvalidOpcode,
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum ExecutionResult {
    /// Execution was successful
    Ok,

    /// Execution was successful but requires signature verification
    OkVerify,

    /// Invalid script execution result
    Invalid,

    /// Invalid arguments on the stack
    InvalidArgs,

    /// The number of received arguments is invalid.
    InvalidArgsLen,

    /// Too many scripts on the script stack
    TooManyScripts,

    /// The opcode is not valid in a coinbase input
    InvalidOPForCoinbaseInput,

    /// The opcode is only available in a coinbase input
    OPOnlyAllowedInCoinbaseInput,

    /// The term being cast to the desired type is invalid.
    InvalidCast,

    /// Not enough terms on the execution stack for this operation.
    NotEnoughTerms,

    /// Invalid script format
    BadFormat,

    /// Stack overflow
    StackOverflow,

    /// Output stack overflow
    OutStackOverflow,

    /// VM ran out of memory
    OutOfMemory,

    /// VM ran out of gas
    OutOfGas,

    /// This opcode is only allowed in a failable input
    OpcodeAllowedOnlyInFailableInput,

    /// VM Term overflow
    TermOverflow,

    /// The provided index is out of bounds
    IndexOutOfBounds,

    /// Explicit panic
    Panic,
}

#[cfg(test)]
mod tests {
    use std::string;

    use super::*;
    use crate::consensus::Money;
    use crate::primitives::InputFlags;
    use rayon::prelude::*;

    pub struct TestBaseArgs {
        args: Vec<VmTerm>,
        ins: Vec<Input>,
        out: Vec<Output>,
    }

    macro_rules! impl_primitive_cast_to_test {
        ($test_name:ident, $cast_type:ident, $cast_desired_type:ident, $cast_desired_type_id:expr, $val:expr) => {
            #[test]
            fn $test_name() {
                let to_cast = VmTerm::$cast_type($val);
                let cast_desired = VmTerm::$cast_desired_type($val);

                let key = "test_key";
                let mut ss = Script {
                    script: vec![
                        ScriptEntry::Byte(0x04),
                        ScriptEntry::Opcode(OP::CastTo),
                        ScriptEntry::Byte($cast_desired_type_id),
                        ScriptEntry::Opcode(OP::PopToScriptOuts),
                        ScriptEntry::Opcode(OP::PushOutVerify),
                    ],
                    ..Script::default()
                };

                ss.populate_malleable_args_field();
                let sh = ss.to_script_hash(key);
                let script_output: Vec<VmTerm> = vec![cast_desired];
                let args = vec![
                    to_cast,
                    VmTerm::Signed128(30),
                    VmTerm::Hash160([0; 20]),
                    VmTerm::Hash160(sh.0),
                ];
                let base: TestBaseArgs =
                    get_test_args(&mut ss, 30, script_output.clone(), 0, key, args);
                let mut idx_map = HashMap::new();
                let mut outs = vec![];
                let mut verif_stack = VerificationStack::new();

                assert_eq!(
                    ss.execute(
                        &base.args,
                        &base.ins,
                        &mut outs,
                        &mut idx_map,
                        &mut verif_stack,
                        [0; 32],
                        key,
                        "",
                        VmFlags::default()
                    ),
                    Ok(ExecutionResult::OkVerify).into()
                );
                assert_eq!(script_output, outs[0].script_outs.clone());
            }
        };
    }

    macro_rules! impl_primitive_cast_to_test_dual_vals {
        ($test_name:ident, $cast_type:ident, $cast_desired_type:ident, $cast_desired_type_id:expr, $val1:expr, $val2:expr) => {
            #[test]
            fn $test_name() {
                let to_cast = VmTerm::$cast_type($val1);
                let cast_desired = VmTerm::$cast_desired_type($val2);

                let key = "test_key";
                let mut ss = Script {
                    script: vec![
                        ScriptEntry::Byte(0x04),
                        ScriptEntry::Opcode(OP::CastTo),
                        ScriptEntry::Byte($cast_desired_type_id),
                        ScriptEntry::Opcode(OP::PopToScriptOuts),
                        ScriptEntry::Opcode(OP::PushOutVerify),
                    ],
                    ..Script::default()
                };

                ss.populate_malleable_args_field();
                let sh = ss.to_script_hash(key);
                let script_output: Vec<VmTerm> = vec![cast_desired];
                let args = vec![
                    to_cast,
                    VmTerm::Signed128(30),
                    VmTerm::Hash160([0; 20]),
                    VmTerm::Hash160(sh.0),
                ];
                let base: TestBaseArgs =
                    get_test_args(&mut ss, 30, script_output.clone(), 0, key, args);
                let mut idx_map = HashMap::new();
                let mut outs = vec![];
                let mut verif_stack = VerificationStack::new();

                assert_eq!(
                    ss.execute(
                        &base.args,
                        &base.ins,
                        &mut outs,
                        &mut idx_map,
                        &mut verif_stack,
                        [0; 32],
                        key,
                        "",
                        VmFlags::default()
                    ),
                    Ok(ExecutionResult::OkVerify).into()
                );
                assert_eq!(script_output, outs[0].script_outs.clone());
            }
        };
    }

    macro_rules! impl_primitive_to_array_cast_to_test {
        ($test_name:ident, $cast_type:ident, $cast_desired_type:ident, $cast_desired_type_id:expr, $val:expr) => {
            #[test]
            fn $test_name() {
                let to_cast = VmTerm::$cast_type($val);
                let cast_desired = VmTerm::$cast_desired_type(vec![$val]);

                let key = "test_key";
                let mut ss = Script {
                    script: vec![
                        ScriptEntry::Byte(0x04),
                        ScriptEntry::Opcode(OP::CastTo),
                        ScriptEntry::Byte($cast_desired_type_id),
                        ScriptEntry::Opcode(OP::PopToScriptOuts),
                        ScriptEntry::Opcode(OP::PushOutVerify),
                    ],
                    ..Script::default()
                };

                ss.populate_malleable_args_field();
                let sh = ss.to_script_hash(key);
                let script_output: Vec<VmTerm> = vec![cast_desired];
                let args = vec![
                    to_cast,
                    VmTerm::Signed128(30),
                    VmTerm::Hash160([0; 20]),
                    VmTerm::Hash160(sh.0),
                ];
                let base: TestBaseArgs =
                    get_test_args(&mut ss, 30, script_output.clone(), 0, key, args);
                let mut idx_map = HashMap::new();
                let mut outs = vec![];
                let mut verif_stack = VerificationStack::new();

                assert_eq!(
                    ss.execute(
                        &base.args,
                        &base.ins,
                        &mut outs,
                        &mut idx_map,
                        &mut verif_stack,
                        [0; 32],
                        key,
                        "",
                        VmFlags::default()
                    ),
                    Ok(ExecutionResult::OkVerify).into()
                );
                assert_eq!(script_output, outs[0].script_outs.clone());
            }
        };
    }

    macro_rules! impl_primitive_to_u8_array_cast_to_test {
        ($test_name:ident, $cast_type:ident, $val:expr) => {
            #[test]
            fn $test_name() {
                let to_cast = VmTerm::$cast_type($val);
                let cast_desired = VmTerm::Unsigned8Array($val.to_le_bytes().to_vec());

                let key = "test_key";
                let mut ss = Script {
                    script: vec![
                        ScriptEntry::Byte(0x04),
                        ScriptEntry::Opcode(OP::CastTo),
                        ScriptEntry::Byte(0x15),
                        ScriptEntry::Opcode(OP::PopToScriptOuts),
                        ScriptEntry::Opcode(OP::PushOutVerify),
                    ],
                    ..Script::default()
                };

                ss.populate_malleable_args_field();
                let sh = ss.to_script_hash(key);
                let script_output: Vec<VmTerm> = vec![cast_desired];
                let args = vec![
                    to_cast,
                    VmTerm::Signed128(30),
                    VmTerm::Hash160([0; 20]),
                    VmTerm::Hash160(sh.0),
                ];
                let base: TestBaseArgs =
                    get_test_args(&mut ss, 30, script_output.clone(), 0, key, args);
                let mut idx_map = HashMap::new();
                let mut outs = vec![];
                let mut verif_stack = VerificationStack::new();

                assert_eq!(
                    ss.execute(
                        &base.args,
                        &base.ins,
                        &mut outs,
                        &mut idx_map,
                        &mut verif_stack,
                        [0; 32],
                        key,
                        "",
                        VmFlags::default()
                    ),
                    Ok(ExecutionResult::OkVerify).into()
                );
                assert_eq!(script_output, outs[0].script_outs.clone());
            }
        };
    }

    fn assert_script_ok(mut script: Script, outputs: Vec<VmTerm>, key: &str) {
        script.populate_malleable_args_field();
        let base: TestBaseArgs = get_test_base_args(&mut script, 30, outputs, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();
        assert_eq!(
            script.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    fn assert_script_fail(
        mut script: Script,
        outputs: Vec<VmTerm>,
        key: &str,
        exec_res: ExecutionResult,
    ) {
        script.populate_malleable_args_field();
        let base: TestBaseArgs = get_test_base_args(&mut script, 30, outputs, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();
        assert_eq!(
            script.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((exec_res, StackTrace::default())).into()
        );
    }

    fn get_test_base_args(
        ss: &mut Script,
        out_amount: Money,
        out_script: Vec<VmTerm>,
        push_out_cycles: usize,
        key: &str,
    ) -> TestBaseArgs {
        ss.populate_malleable_args_field();
        let sh = ss.to_script_hash(key);
        let args = vec![
            VmTerm::Signed128(30),
            VmTerm::Hash160([0; 20]),
            VmTerm::Hash160(sh.0),
        ];

        get_test_args(ss, out_amount, out_script, push_out_cycles, key, args)
    }

    fn get_test_args(
        ss: &mut Script,
        out_amount: Money,
        out_script: Vec<VmTerm>,
        push_out_cycles: usize,
        key: &str,
        args: Vec<VmTerm>,
    ) -> TestBaseArgs {
        ss.populate_malleable_args_field();
        let sh = ss.to_script_hash(key);
        let mut ins = vec![Input {
            script: ss.clone(),
            script_args: args.clone(),
            input_flags: InputFlags::IsCoinbase,
            ..Default::default()
        }]
        .iter()
        .cloned()
        .map(|mut i| {
            i.compute_hash(key);
            i
        })
        .collect::<Vec<_>>();

        // Prepare output
        let ins_hashes: Vec<u8> = ins.iter_mut().fold(vec![], |mut acc, v: &mut Input| {
            v.compute_hash(key);
            acc.extend(v.hash().unwrap().0);
            acc
        });
        let inputs_hash = Hash160::hash_from_slice(ins_hashes.as_slice(), key);
        let inputs_hash: Hash160 = ins.iter().cloned().cycle().take(push_out_cycles).fold(
            inputs_hash.clone(),
            |mut acc: Hash160, v: Input| {
                let inputs_hashes = [acc.0, inputs_hash.0]
                    .iter()
                    .flatten()
                    .copied()
                    .collect::<Vec<_>>();
                acc = Hash160::hash_from_slice(inputs_hashes.as_slice(), key);
                acc
            },
        );
        let mut oracle_out = Output {
            address: Some(Hash160::zero().to_address()),
            amount: out_amount,
            script_hash: sh,
            inputs_hash,
            coloured_address: None,
            coinbase_height: None,
            hash: None,
            script_outs: out_script,
            idx: 0,
        };
        oracle_out.compute_hash(key);

        TestBaseArgs {
            args,
            ins,
            out: vec![oracle_out],
        }
    }

    // Cast to primitive implementations
    impl_primitive_cast_to_test!(cast_to_from_u8_to_u8, Unsigned8, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_u16, Unsigned8, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_u32, Unsigned8, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_u64, Unsigned8, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_u128, Unsigned8, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_i8, Unsigned8, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_i16, Unsigned8, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_i32, Unsigned8, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_i64, Unsigned8, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_u8_to_i128, Unsigned8, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_to_ubig,
        Unsigned8,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_to_ibig,
        Unsigned8,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_to_f32,
        Unsigned8,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_to_f64,
        Unsigned8,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_to_dec,
        Unsigned8,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_i8_to_u8, Signed8, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_u16, Signed8, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_u32, Signed8, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_u64, Signed8, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_u128, Signed8, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_i8, Signed8, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_i16, Signed8, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_i32, Signed8, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_i64, Signed8, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_i8_to_i128, Signed8, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i8_to_ubig,
        Signed8,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i8_to_ibig,
        Signed8,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i8_to_f32,
        Signed8,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i8_to_f64,
        Signed8,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i8_to_dec,
        Signed8,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_u16_to_u8, Unsigned16, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_u16, Unsigned16, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_u32, Unsigned16, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_u64, Unsigned16, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_u128, Unsigned16, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_i8, Unsigned16, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_i16, Unsigned16, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_i32, Unsigned16, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_i64, Unsigned16, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_u16_to_i128, Unsigned16, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u16_to_ubig,
        Unsigned16,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u16_to_ibig,
        Unsigned16,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u16_to_f32,
        Unsigned16,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u16_to_f64,
        Unsigned16,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u16_to_dec,
        Unsigned16,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_i16_to_u8, Signed16, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_u16, Signed16, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_u32, Signed16, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_u64, Signed16, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_u128, Signed16, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_i8, Signed16, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_i16, Signed16, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_i32, Signed16, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_i64, Signed16, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_i16_to_i128, Signed16, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i16_to_ubig,
        Signed16,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i16_to_ibig,
        Signed16,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i16_to_f32,
        Signed16,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i16_to_f64,
        Signed16,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i16_to_dec,
        Signed16,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_u32_to_u8, Unsigned32, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_u16, Unsigned32, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_u32, Unsigned32, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_u64, Unsigned32, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_u128, Unsigned32, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_i8, Unsigned32, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_i16, Unsigned32, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_i32, Unsigned32, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_i64, Unsigned32, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_u32_to_i128, Unsigned32, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u32_to_ubig,
        Unsigned32,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u32_to_ibig,
        Unsigned32,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u32_to_f32,
        Unsigned32,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u32_to_f64,
        Unsigned32,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u32_to_dec,
        Unsigned32,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_i32_to_u8, Signed32, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_u16, Signed32, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_u32, Signed32, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_u64, Signed32, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_u128, Signed32, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_i8, Signed32, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_i16, Signed32, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_i32, Signed32, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_i64, Signed32, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_i32_to_i128, Signed32, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i32_to_ubig,
        Signed32,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i32_to_ibig,
        Signed32,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i32_to_f32,
        Signed32,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i32_to_f64,
        Signed32,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i32_to_dec,
        Signed32,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_u64_to_u8, Unsigned64, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_u16, Unsigned64, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_u32, Unsigned64, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_u64, Unsigned64, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_u128, Unsigned64, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_i8, Unsigned64, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_i16, Unsigned64, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_i32, Unsigned64, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_i64, Unsigned64, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_u64_to_i128, Unsigned64, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u64_to_ubig,
        Unsigned64,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u64_to_ibig,
        Unsigned64,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u64_to_f32,
        Unsigned64,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u64_to_f64,
        Unsigned64,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u64_to_dec,
        Unsigned64,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_i64_to_u8, Signed64, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_u16, Signed64, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_u32, Signed64, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_u64, Signed64, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_u128, Signed64, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_i8, Signed64, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_i16, Signed64, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_i32, Signed64, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_i64, Signed64, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_i64_to_i128, Signed64, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i64_to_ubig,
        Signed64,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i64_to_ibig,
        Signed64,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i64_to_f32,
        Signed64,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i64_to_f64,
        Signed64,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i64_to_dec,
        Signed64,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_u128_to_u8, Unsigned128, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_u128_to_u16, Unsigned128, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_u128_to_u32, Unsigned128, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_u128_to_u64, Unsigned128, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(
        cast_to_from_u128_to_u128,
        Unsigned128,
        Unsigned128,
        0x07,
        100
    );
    impl_primitive_cast_to_test!(cast_to_from_u128_to_i8, Unsigned128, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_u128_to_i16, Unsigned128, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_u128_to_i32, Unsigned128, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_u128_to_i64, Unsigned128, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_u128_to_i128, Unsigned128, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u128_to_ubig,
        Unsigned128,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u128_to_ibig,
        Unsigned128,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u128_to_f32,
        Unsigned128,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u128_to_f64,
        Unsigned128,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u128_to_dec,
        Unsigned128,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_u8,
        UnsignedBig,
        Unsigned8,
        0x03,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_u16,
        UnsignedBig,
        Unsigned16,
        0x04,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_u32,
        UnsignedBig,
        Unsigned32,
        0x05,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_u64,
        UnsignedBig,
        Unsigned64,
        0x06,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_u128,
        UnsignedBig,
        Unsigned128,
        0x07,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_ubig,
        UnsignedBig,
        UnsignedBig,
        0x08,
        ubig!(100),
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_i8,
        UnsignedBig,
        Signed8,
        0x09,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_i16,
        UnsignedBig,
        Signed16,
        0x0a,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_i32,
        UnsignedBig,
        Signed32,
        0x0b,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_i64,
        UnsignedBig,
        Signed64,
        0x0c,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_i128,
        UnsignedBig,
        Signed128,
        0x0d,
        ubig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_ibig,
        UnsignedBig,
        SignedBig,
        0x0e,
        ubig!(100),
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_float32,
        UnsignedBig,
        Float32,
        0x0f,
        ubig!(100),
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_float64,
        UnsignedBig,
        Float64,
        0x10,
        ubig!(100),
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_decimal,
        UnsignedBig,
        Decimal,
        0x11,
        ubig!(100),
        dec!(100)
    );
    impl_primitive_cast_to_test!(cast_to_from_i128_to_u8, Signed128, Unsigned8, 0x03, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_u16, Signed128, Unsigned16, 0x04, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_u32, Signed128, Unsigned32, 0x05, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_u64, Signed128, Unsigned64, 0x06, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_u128, Signed128, Unsigned128, 0x07, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_i8, Signed128, Signed8, 0x09, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_i16, Signed128, Signed16, 0x0a, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_i32, Signed128, Signed32, 0x0b, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_i64, Signed128, Signed64, 0x0c, 100);
    impl_primitive_cast_to_test!(cast_to_from_i128_to_i128, Signed128, Signed128, 0x0d, 100);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i128_to_ubig,
        Signed128,
        UnsignedBig,
        0x08,
        100,
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i128_to_ibig,
        Signed128,
        SignedBig,
        0x0e,
        100,
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i128_to_f32,
        Signed128,
        Float32,
        0x0f,
        100,
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i128_to_f64,
        Signed128,
        Float64,
        0x10,
        100,
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_i128_to_dec,
        Signed128,
        Decimal,
        0x11,
        100,
        dec!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_u8,
        SignedBig,
        Unsigned8,
        0x03,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_u16,
        SignedBig,
        Unsigned16,
        0x04,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_u32,
        SignedBig,
        Unsigned32,
        0x05,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_u64,
        SignedBig,
        Unsigned64,
        0x06,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_u128,
        SignedBig,
        Unsigned128,
        0x07,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_ubig,
        SignedBig,
        UnsignedBig,
        0x08,
        ibig!(100),
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_i8,
        SignedBig,
        Signed8,
        0x09,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_i16,
        SignedBig,
        Signed16,
        0x0a,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_i32,
        SignedBig,
        Signed32,
        0x0b,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_i64,
        SignedBig,
        Signed64,
        0x0c,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_i128,
        SignedBig,
        Signed128,
        0x0d,
        ibig!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_ibig,
        SignedBig,
        SignedBig,
        0x0e,
        ibig!(100),
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_float32,
        SignedBig,
        Float32,
        0x0f,
        ibig!(100),
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_float64,
        SignedBig,
        Float64,
        0x10,
        ibig!(100),
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_decimal,
        SignedBig,
        Decimal,
        0x11,
        ibig!(100),
        dec!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_u8,
        Decimal,
        Unsigned8,
        0x03,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_u16,
        Decimal,
        Unsigned16,
        0x04,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_u32,
        Decimal,
        Unsigned32,
        0x05,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_u64,
        Decimal,
        Unsigned64,
        0x06,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_u128,
        Decimal,
        Unsigned128,
        0x07,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_ubig,
        Decimal,
        UnsignedBig,
        0x08,
        dec!(100),
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_i8,
        Decimal,
        Signed8,
        0x09,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_i16,
        Decimal,
        Signed16,
        0x0a,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_i32,
        Decimal,
        Signed32,
        0x0b,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_i64,
        Decimal,
        Signed64,
        0x0c,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_i128,
        Decimal,
        Signed128,
        0x0d,
        dec!(100),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_ibig,
        Decimal,
        SignedBig,
        0x0e,
        dec!(100),
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_float32,
        Decimal,
        Float32,
        0x0f,
        dec!(100),
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_float64,
        Decimal,
        Float64,
        0x10,
        dec!(100),
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_decimal,
        Decimal,
        Decimal,
        0x11,
        dec!(100),
        dec!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_u8,
        Float32,
        Unsigned8,
        0x03,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_u16,
        Float32,
        Unsigned16,
        0x04,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_u32,
        Float32,
        Unsigned32,
        0x05,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_u64,
        Float32,
        Unsigned64,
        0x06,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_u128,
        Float32,
        Unsigned128,
        0x07,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_ubig,
        Float32,
        UnsignedBig,
        0x08,
        Float32Wrapper(100.0),
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_i8,
        Float32,
        Signed8,
        0x09,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_i16,
        Float32,
        Signed16,
        0x0a,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_i32,
        Float32,
        Signed32,
        0x0b,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_i64,
        Float32,
        Signed64,
        0x0c,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_i128,
        Float32,
        Signed128,
        0x0d,
        Float32Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_ibig,
        Float32,
        SignedBig,
        0x0e,
        Float32Wrapper(100.0),
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_float32,
        Float32,
        Float32,
        0x0f,
        Float32Wrapper(100.0),
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_float64,
        Float32,
        Float64,
        0x10,
        Float32Wrapper(100.0),
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_decimal,
        Float32,
        Decimal,
        0x11,
        Float32Wrapper(100.0),
        dec!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_u8,
        Float64,
        Unsigned8,
        0x03,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_u16,
        Float64,
        Unsigned16,
        0x04,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_u32,
        Float64,
        Unsigned32,
        0x05,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_u64,
        Float64,
        Unsigned64,
        0x06,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_u128,
        Float64,
        Unsigned128,
        0x07,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_ubig,
        Float64,
        UnsignedBig,
        0x08,
        Float64Wrapper(100.0),
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_i8,
        Float64,
        Signed8,
        0x09,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_i16,
        Float64,
        Signed16,
        0x0a,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_i32,
        Float64,
        Signed32,
        0x0b,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_i64,
        Float64,
        Signed64,
        0x0c,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_i128,
        Float64,
        Signed128,
        0x0d,
        Float64Wrapper(100.0),
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_ibig,
        Float64,
        SignedBig,
        0x0e,
        Float64Wrapper(100.0),
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_float32,
        Float64,
        Float32,
        0x0f,
        Float64Wrapper(100.0),
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_float64,
        Float64,
        Float64,
        0x10,
        Float64Wrapper(100.0),
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_decimal,
        Float64,
        Decimal,
        0x11,
        Float64Wrapper(100.0),
        dec!(100)
    );

    // Cast to primitive to array implementations
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_u8_to_u8_array,
        Unsigned8,
        Unsigned8Array,
        0x15,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_u16_to_u16_array,
        Unsigned16,
        Unsigned16Array,
        0x16,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_u32_to_u32_array,
        Unsigned32,
        Unsigned32Array,
        0x17,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_u64_to_u64_array,
        Unsigned64,
        Unsigned64Array,
        0x18,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_u128_to_u128_array,
        Unsigned128,
        Unsigned128Array,
        0x19,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_ubig_to_ubig_array,
        UnsignedBig,
        UnsignedBigArray,
        0x1a,
        ubig!(100)
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_i8_to_i8_array,
        Signed8,
        Signed8Array,
        0x1b,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_i16_to_i16_array,
        Signed16,
        Signed16Array,
        0x1c,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_i32_to_i32_array,
        Signed32,
        Signed32Array,
        0x1d,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_i64_to_i64_array,
        Signed64,
        Signed64Array,
        0x1e,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_i128_to_i128_array,
        Signed128,
        Signed128Array,
        0x1f,
        100
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_ibig_to_ibig_array,
        SignedBig,
        SignedBigArray,
        0x20,
        ibig!(100)
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_f32_to_f32_array,
        Float32,
        Float32Array,
        0x21,
        Float32Wrapper(100.0)
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_f64_to_f64_array,
        Float64,
        Float64Array,
        0x22,
        Float64Wrapper(100.0)
    );
    impl_primitive_to_array_cast_to_test!(
        cast_to_from_decimal_to_decimal_array,
        Decimal,
        DecimalArray,
        0x23,
        dec!(100)
    );

    // Cast to u8 array to primitives implementations
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_hash160,
        Unsigned8Array,
        Hash160,
        0x00,
        vec![0; 20],
        [0; 20]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_hash256,
        Unsigned8Array,
        Hash256,
        0x01,
        vec![0; 32],
        [0; 32]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_hash512,
        Unsigned8Array,
        Hash512,
        0x02,
        vec![0; 64],
        [0; 64]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_u8,
        Unsigned8Array,
        Unsigned8,
        0x03,
        vec![100],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_u16,
        Unsigned8Array,
        Unsigned16,
        0x04,
        vec![100, 0],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_u32,
        Unsigned8Array,
        Unsigned32,
        0x05,
        vec![100, 0, 0, 0],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_u64,
        Unsigned8Array,
        Unsigned64,
        0x06,
        vec![100, 0, 0, 0, 0, 0, 0, 0],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_u128,
        Unsigned8Array,
        Unsigned128,
        0x07,
        vec![100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_ubig,
        Unsigned8Array,
        UnsignedBig,
        0x08,
        vec![100],
        ubig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_i8,
        Unsigned8Array,
        Signed8,
        0x09,
        vec![100],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_i16,
        Unsigned8Array,
        Signed16,
        0x0a,
        vec![100, 0],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_i32,
        Unsigned8Array,
        Signed32,
        0x0b,
        vec![100, 0, 0, 0],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_i64,
        Unsigned8Array,
        Signed64,
        0x0c,
        vec![100, 0, 0, 0, 0, 0, 0, 0],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_i128,
        Unsigned8Array,
        Signed128,
        0x0d,
        vec![100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        100
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_ibig_pos,
        Unsigned8Array,
        SignedBig,
        0x0e,
        vec![0x0f, 100],
        ibig!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_ibig_neg,
        Unsigned8Array,
        SignedBig,
        0x0e,
        vec![0x0e, 100],
        ibig!(-100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_ibig_zero,
        Unsigned8Array,
        SignedBig,
        0x0e,
        vec![0x10],
        ibig!(0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_decimal_pos,
        Unsigned8Array,
        Decimal,
        0x11,
        vec![0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        dec!(100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_decimal_neg,
        Unsigned8Array,
        Decimal,
        0x11,
        vec![0, 0, 0, 128, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        dec!(-100)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_decimal_zero,
        Unsigned8Array,
        Decimal,
        0x11,
        vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        dec!(0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_f32_pos,
        Unsigned8Array,
        Float32,
        0x0f,
        vec![0, 0, 200, 66],
        Float32Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_f32_neg,
        Unsigned8Array,
        Float32,
        0x0f,
        vec![0, 0, 200, 194],
        Float32Wrapper(-100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_f32_zero,
        Unsigned8Array,
        Float32,
        0x0f,
        vec![0, 0, 0, 0],
        Float32Wrapper(0.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_f64_pos,
        Unsigned8Array,
        Float64,
        0x10,
        vec![0, 0, 0, 0, 0, 0, 89, 64],
        Float64Wrapper(100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_f64_neg,
        Unsigned8Array,
        Float64,
        0x10,
        vec![0, 0, 0, 0, 0, 0, 89, 192],
        Float64Wrapper(-100.0)
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_u8_array_to_f64_zero,
        Unsigned8Array,
        Float64,
        0x10,
        vec![0, 0, 0, 0, 0, 0, 0, 0],
        Float64Wrapper(0.0)
    );

    // Cast to primitive to u8 array implementations
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_u16_to_u8_array, Unsigned16, 100_u16);
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_u32_to_u8_array, Unsigned32, 100_u32);
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_u64_to_u8_array, Unsigned64, 100_u64);
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_u128_to_u8_array, Unsigned128, 100_u128);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ubig_to_u8_array,
        UnsignedBig,
        Unsigned8Array,
        0x15,
        ubig!(100),
        vec![100]
    );
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_i8_to_u8_array, Signed8, 100_i8);
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_i16_to_u8_array, Signed16, 100_i16);
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_i32_to_u8_array, Signed32, 100_i32);
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_i64_to_u8_array, Signed64, 100_i64);
    impl_primitive_to_u8_array_cast_to_test!(cast_to_from_i128_to_u8_array, Signed128, 100_i128);
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_u8_array_pos,
        SignedBig,
        Unsigned8Array,
        0x15,
        ibig!(100),
        vec![0x0f, 100]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_u8_array_neg,
        SignedBig,
        Unsigned8Array,
        0x15,
        ibig!(-100),
        vec![0x0e, 100]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_ibig_to_u8_array_zero,
        SignedBig,
        Unsigned8Array,
        0x15,
        ibig!(0),
        vec![0x10]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_u8_array_pos,
        Float32,
        Unsigned8Array,
        0x15,
        Float32Wrapper(100.0),
        vec![0, 0, 200, 66]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_u8_array_neg,
        Float32,
        Unsigned8Array,
        0x15,
        Float32Wrapper(-100.0),
        vec![0, 0, 200, 194]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f32_to_u8_array_zero,
        Float32,
        Unsigned8Array,
        0x15,
        Float32Wrapper(0.0),
        vec![0, 0, 0, 0]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_u8_array_pos,
        Float64,
        Unsigned8Array,
        0x15,
        Float64Wrapper(100.0),
        vec![0, 0, 0, 0, 0, 0, 89, 64]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_u8_array_neg,
        Float64,
        Unsigned8Array,
        0x15,
        Float64Wrapper(-100.0),
        vec![0, 0, 0, 0, 0, 0, 89, 192]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_f64_to_u8_array_zero,
        Float64,
        Unsigned8Array,
        0x15,
        Float64Wrapper(0.0),
        vec![0, 0, 0, 0, 0, 0, 0, 0]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_u8_array_pos,
        Decimal,
        Unsigned8Array,
        0x15,
        dec!(100),
        vec![0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_u8_array_neg,
        Decimal,
        Unsigned8Array,
        0x15,
        dec!(-100),
        vec![0, 0, 0, 128, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_decimal_to_u8_array_zero,
        Decimal,
        Unsigned8Array,
        0x15,
        dec!(0),
        vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_hash160_to_u8_array,
        Hash160,
        Unsigned8Array,
        0x15,
        [0; 20],
        vec![0; 20]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_hash256_to_u8_array,
        Hash256,
        Unsigned8Array,
        0x15,
        [0; 32],
        vec![0; 32]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_hash512_to_u8_array,
        Hash512,
        Unsigned8Array,
        0x15,
        [0; 64],
        vec![0; 64]
    );

    // Cast to hash to hash implementations
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_hash256_to_hash160,
        Hash256,
        Hash160,
        0x00,
        [0; 32],
        [0; 20]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_hash512_to_hash160,
        Hash512,
        Hash160,
        0x00,
        [0; 64],
        [0; 20]
    );
    impl_primitive_cast_to_test_dual_vals!(
        cast_to_from_hash512_to_hash256,
        Hash512,
        Hash256,
        0x01,
        [0; 64],
        [0; 32]
    );

    #[test]
    fn it_parses_script_with_only_main() {
        let script: Vec<u8> = vec![
            0x17, // Script length
            0x03, // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
            0x00, // Script flags
            0x26, // OP_Unsigned8Var,
            0x00, // Push 0 to the stack
            0x57, // OP_Loop
            0x57, // OP_Loop
            0x58, // OP_Break
            0xb6, // OP_End
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0xcf, // OP_PushOut,
            0x82, // OP_Add1,
            0x70, // OP_Pick,
            0x00, // Pick at index 0
            0x26, // OP_Unsigned8Var,
            0x03, // Push 3 to the stack
            0x5b, // OP_BreakIfEq
            0xb6, // OP_End
            0xb7, // OP_Verify
        ];

        let oracle_script = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Break),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            malleable_args: bitvec_from_bools![false, false, false],
            ..Script::default()
        };

        let decoded: Script = crate::codec::decode(&script).unwrap();

        assert_eq!(decoded, oracle_script);
    }

    #[test]
    fn it_fails_to_parse_script_with_duplicate_end_opcodes() {
        let script: Vec<u8> = vec![
            0x15, // Script length
            0x03, // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
            0x00, // Script flags
            0x26, // OP_Unsigned8Var,
            0x00, // Push 0 to the stack
            0x57, // OP_Loop
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0xcf, // OP_PushOut,
            0x82, // OP_Add1,
            0x70, // OP_Pick,
            0x00, // Pick at index 0
            0x26, // OP_Unsigned8Var,
            0x03, // Push 3 to the stack
            0x5b, // OP_BreakIfEq
            0xb6, // OP_End
            0xb6, // OP_End
            0xb7, // OP_Verify
        ];

        assert!(crate::codec::decode::<Script>(&script).is_err());
    }

    #[test]
    fn it_fails_to_parse_script_with_invalid_end_opcodes() {
        let script: Vec<u8> = vec![
            0x13, // Script length
            0x03, // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
            0x00, // Script flags
            0x26, // OP_Unsigned8Var,
            0x00, // Push 0 to the stack
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0xcf, // OP_PushOut,
            0x82, // OP_Add1,
            0x70, // OP_Pick,
            0x00, // Pick at index 0
            0x26, // OP_Unsigned8Var,
            0x03, // Push 3 to the stack
            0x5b, // OP_BreakIfEq
            0xb6, // OP_End
            0xb7, // OP_Verify
        ];

        assert!(crate::codec::decode::<Script>(&script).is_err());
    }

    #[test]
    fn it_fails_to_parse_script_with_more_script_flags_than_necessary() {
        let script: Vec<u8> = vec![
            0x15, // Script length
            0x03, // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
            0x00, // Script flags
            0x00, // Script flags
            0x23, // OP_Unsigned8Var,
            0x00, // Push 0 to the stack
            0x57, // OP_Loop
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0x70, // OP_Pick,
            0x03, // Pick at index 3
            0xcf, // OP_PushOut,
            0x82, // OP_Add1,
            0x70, // OP_Pick,
            0x00, // Pick at index 0
            0x23, // OP_Unsigned8Var,
            0x03, // Push 3 to the stack
            0x5b, // OP_BreakIfEq
            0xb6, // OP_End
            0xb7, // OP_Verify
        ];

        assert!(crate::codec::decode::<Script>(&script).is_err());
    }

    #[test]
    fn it_parses_script_with_multiple_functions() {
        let script: Vec<u8> = vec![
            0x13, // Script length
            0x03, // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
            0x00, // Script flags
            0x26, // OP_Unsigned8Var,
            0x00, // Push 0 to the stack
            0x57, // OP_Loop
            0xaf, // OP_Call
            0x00, // Call function with index 0
            0x70, // OP_Pick,
            0x00, // Pick at index 0
            0x26, // OP_Unsigned8Var,
            0x03, // Push 3 to the stack
            0x5b, // OP_BreakIfEq
            0xb6, // OP_End
            0xb7, // OP_Verify
            0x00, // OP_Func
            0x01, // 1 argument pushed onto the stack
            0x82, // OP_Add1,
            0xb8, // OP_ReturnFunc,
            0xb6, // OP_End
        ];

        let oracle_script = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Call),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            malleable_args: bitvec_from_bools![false, false, false],
            functions: vec![vec![
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::ReturnFunc),
            ]],
        };

        let decoded: Script = crate::codec::decode(&script).unwrap();
        assert_eq!(decoded, oracle_script);
    }

    #[test]
    fn set_bit() {
        assert_eq!(set_bit!(0_u8, 0_u8, 1_u8), 0b0000_0001);
    }

    #[test]
    fn check_bit() {
        assert!(check_bit!(0b0000_0001, 0));
        assert!(!check_bit!(0b0000_0000, 0));
    }

    #[test]
    fn it_simple_spends() {
        let key = "test_key";
        let ss = Script::new_simple_spend();
        let sh = ss.to_script_hash(key);
        let mut idx_map = HashMap::new();
        let args = vec![
            VmTerm::Signed128(30),
            VmTerm::Hash160([0; 20]),
            VmTerm::Hash160(sh.0),
        ];
        let mut ins = vec![Input {
            script: ss.clone(),
            script_args: args.clone(),
            input_flags: InputFlags::IsCoinbase,
            ..Default::default()
        }];
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        let ins_hashes: Vec<u8> = ins.iter_mut().fold(vec![], |mut acc, v: &mut Input| {
            v.compute_hash(key);
            acc.extend(v.hash().unwrap().0);
            acc
        });

        let inputs_hash = Hash160::hash_from_slice(ins_hashes, key);
        let mut oracle_out = Output {
            address: Some(Hash160::zero().to_address()),
            amount: 30,
            script_hash: sh,
            inputs_hash,
            coloured_address: None,
            coinbase_height: None,
            hash: None,
            script_outs: vec![],
            idx: 0,
        };
        oracle_out.compute_hash(key);

        assert_eq!(
            ss.execute(
                &args,
                &ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, vec![oracle_out]);
    }

    #[test]
    fn it_breaks_loop_if_values_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_calls_function() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Call),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            malleable_args: bitvec_from_bools![false, false, false],
            functions: vec![vec![
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::ReturnFunc),
            ]],
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
    }

    #[test]
    fn it_breaks_loop_if_values_not_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::BreakIfNeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 60, vec![], 1, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_equal_to_1() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::BreakIf),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_not_equal_to_1() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::BreakIfn),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 60, vec![], 1, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_values_equal_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_less_or_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfLeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_less_or_equal_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::BreakIfLeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_greater_or_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfGeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_greater_or_equal_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfGeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_less() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfLt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_less_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::BreakIfLt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_greater() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::BreakIfGt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_breaks_loop_if_greater_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::BreakIfGt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_less_or_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::ContinueIfLeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_less_or_equal_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::ContinueIfLeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_greater_or_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::ContinueIfGeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_greater_or_equal_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::ContinueIfGeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_less() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::ContinueIfLt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_greater() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::ContinueIfGt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_equals_1() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::ContinueIf),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 60, vec![], 1, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_not_equals_1() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::ContinueIfn),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_equals() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::ContinueIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 60, vec![], 1, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_continues_loop_if_not_equals() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::ContinueIfNeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_runs_out_of_gas() {
        let key = "test_key";
        let ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Verify),
            ],
            malleable_args: bitvec_from_bools![false, false, false],
            ..Script::default()
        };
        let sh = ss.to_script_hash(key);
        let mut idx_map = HashMap::new();
        let args = vec![
            VmTerm::Signed128(30),
            VmTerm::Hash160([0; 20]),
            VmTerm::Hash160(sh.0),
        ];
        let ins = vec![Input {
            script: ss.clone(),
            script_args: args.clone(),
            input_flags: InputFlags::IsCoinbase,
            ..Default::default()
        }]
        .iter()
        .cloned()
        .map(|mut i| {
            i.compute_hash(key);
            i
        })
        .collect::<Vec<_>>();

        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();
        assert_eq!(
            ss.execute(
                &args,
                ins.as_slice(),
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::OutOfGas, StackTrace::default())).into()
        );
    }

    #[test]
    fn pushout_zero_amount() {
        let key = "test_key";
        let ss = Script::new_simple_spend();
        let sh = ss.to_script_hash(key);
        let mut idx_map = HashMap::new();
        let args = vec![
            VmTerm::Signed128(0),
            VmTerm::Hash160([0; 20]),
            VmTerm::Hash160(sh.0),
        ];
        let mut ins: Vec<Input> = vec![Input {
            script: ss.clone(),
            script_args: args.clone(),
            input_flags: InputFlags::IsCoinbase,
            ..Default::default()
        }]
        .iter()
        .cloned()
        .map(|mut i| {
            i.compute_hash(key);
            i
        })
        .collect();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &args,
                &ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn pushout_neg_amount() {
        let key = "test_key";
        let ss = Script::new_simple_spend();
        let sh = ss.to_script_hash(key);
        let mut idx_map = HashMap::new();
        let args = vec![
            VmTerm::Signed128(-30),
            VmTerm::Hash160([0; 20]),
            VmTerm::Hash160(sh.0),
        ];
        let mut ins: Vec<Input> = vec![Input {
            script: ss.clone(),
            script_args: args.clone(),
            input_flags: InputFlags::IsCoinbase,
            ..Default::default()
        }]
        .iter()
        .cloned()
        .map(|mut i| {
            i.compute_hash(key);
            i
        })
        .collect();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &args,
                &ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_encodes_to_single_byte() {
        let script = Script {
            script: vec![
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
            ],
            malleable_args: bitvec_from_bools![false],
            ..Script::default()
        };
        let encoded = crate::codec::encode_to_vec(&script).unwrap();
        assert_eq!(
            encoded,
            vec![0x0a, 0x01, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00]
        );
    }

    #[test]
    fn it_encodes_to_single_byte_2() {
        let script = Script {
            script: vec![
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
            ],
            malleable_args: bitvec_from_bools![false],
            ..Script::default()
        };
        let encoded = crate::codec::encode_to_vec(&script).unwrap();
        assert_eq!(
            encoded,
            vec![0x0a, 0x01, 0x00, 0x28, 0xff, 0xff, 0xff, 0xff, 0x27, 0xff, 0xff]
        );
    }

    #[test]
    fn it_encodes_and_decodes() {
        let script = Script {
            script: vec![
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
            ],
            malleable_args: bitvec_from_bools![false],
            ..Script::default()
        };
        let encoded = crate::codec::encode_to_vec(&script).unwrap();
        let decoded: Script = crate::codec::decode(&encoded).unwrap();
        assert_eq!(decoded, script);
    }

    #[test]
    fn it_encodes_and_decodes_coinbase() {
        let script = Script::new_coinbase();
        let encoded = crate::codec::encode_to_vec(&script).unwrap();
        let decoded: Script = crate::codec::decode(&encoded).unwrap();
        assert_eq!(decoded, script);
    }

    #[test]
    fn it_encodes_and_decodes_simple_spend() {
        let script = Script::new_simple_spend();
        let encoded = crate::codec::encode_to_vec(&script).unwrap();
        let decoded: Script = crate::codec::decode(&encoded).unwrap();
        assert_eq!(decoded, script);
    }

    #[test]
    fn it_encodes_and_decodes_2() {
        let script = Script {
            script: vec![
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned32ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xf0),
                ScriptEntry::Byte(0xf0),
            ],
            malleable_args: bitvec_from_bools![false],
            ..Script::default()
        };
        let encoded = crate::codec::encode_to_vec(&script).unwrap();
        let decoded: Script = crate::codec::decode(&encoded).unwrap();
        assert_eq!(decoded, script);
    }

    #[test]
    fn it_roll_pop_out() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Roll),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Roll),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(2),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_roll_pick_out() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Roll),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Roll),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PickToScriptOuts),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PickToScriptOuts),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::PickToScriptOuts),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(0),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_depth() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x1),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x1),
                ScriptEntry::Opcode(OP::Depth),
                ScriptEntry::Opcode(OP::Depth),
                ScriptEntry::Opcode(OP::Depth),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned16(7),
            VmTerm::Unsigned16(6),
            VmTerm::Unsigned16(5),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_dup() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(1),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_dup_all() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0xaa),
                ScriptEntry::Byte(0xbb),
                ScriptEntry::Byte(0xcc),
                ScriptEntry::Byte(0xdd),
                ScriptEntry::Opcode(OP::DupAll),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned32(0xddcc_bbaa),
            VmTerm::Unsigned8(0x03),
            VmTerm::Unsigned8(0x02),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned32(0xddcc_bbaa),
            VmTerm::Unsigned8(0x03),
            VmTerm::Unsigned8(0x02),
            VmTerm::Unsigned8(0x01),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_nip() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Nip),
                ScriptEntry::Opcode(OP::Nip),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(4), VmTerm::Unsigned8(1)];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_rot() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Rot),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(5),
            VmTerm::Unsigned8(4),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(0),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_rot2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Rot2),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(0),
            VmTerm::Unsigned8(5),
            VmTerm::Unsigned8(4),
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(2),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_over() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Over),
                ScriptEntry::Opcode(OP::Over2),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_swap() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Swap),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(1),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_swap2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Swap2),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(5),
            VmTerm::Unsigned8(4),
            VmTerm::Unsigned8(1),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_tuck() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Tuck),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(1),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_drop2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(5)];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_dup2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Dup2),
                ScriptEntry::Opcode(OP::Dup2),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_dup3() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Dup3),
                ScriptEntry::Opcode(OP::Dup3),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(3),
            VmTerm::Unsigned8(2),
            VmTerm::Unsigned8(1),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    // TODO: extend for all types when implemented
    #[test]
    fn it_adds_size() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Size),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![VmTerm::Unsigned64(1), VmTerm::Unsigned8(0)];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_drop_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_dup_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_nip_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Nip),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_rot_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Rot),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_rot_2_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Rot2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_over_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Over),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_roll_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Roll),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::IndexOutOfBounds, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_swap_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Swap),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_tuck_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Tuck),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_drop_2_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_dup_2_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Dup2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_dup_3_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Dup3),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_over_2_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x1),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x2),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x3),
                ScriptEntry::Opcode(OP::Over2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_swap_2_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x1),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x2),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x3),
                ScriptEntry::Opcode(OP::Swap2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_fails_to_push_size_when_stack_length_is_lower() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Size),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Err((ExecutionResult::InvalidArgs, StackTrace::default())).into()
        );
    }

    #[test]
    fn it_loads_hash_160var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Hash160Var),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Opcode(OP::Hash160Var),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Hash160([
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57,
            ]),
            VmTerm::Hash160([
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57,
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_hash_256var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Hash256Var),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Opcode(OP::Hash256Var),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Hash256([
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47,
                0x35, 0x12, 0x18, 0x34,
            ]),
            VmTerm::Hash256([
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47,
                0x35, 0x12, 0x18, 0x34,
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_hash_512var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Hash512Var),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Opcode(OP::Hash512Var),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Hash512([
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47,
                0x35, 0x12, 0x18, 0x34, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12,
                0x18, 0x34, 0x85, 0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23,
                0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34,
            ]),
            VmTerm::Hash512([
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47,
                0x35, 0x12, 0x18, 0x34, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12,
                0x18, 0x34, 0x85, 0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23,
                0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34,
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_8var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x11),
            VmTerm::Unsigned8(0x23),
            VmTerm::Unsigned8(0x01),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_16var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned16(0x0011),
            VmTerm::Unsigned16(0x2301),
            VmTerm::Unsigned16(0x0123),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_32var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned32(0x0000_0011),
            VmTerm::Unsigned32(0x0000_2301),
            VmTerm::Unsigned32(0x0000_0123),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_64var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned64Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned64Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned64Var),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned64(0x0000_0000_0000_0011),
            VmTerm::Unsigned64(0x0123_0000_0000_2301),
            VmTerm::Unsigned64(0x0123_0000_0000_0123),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_128var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned128Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Opcode(OP::Unsigned128Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned128(0x2200_0000_0000_0000_0123_0000_0000_2301),
            VmTerm::Unsigned128(0x1100_0000_0000_0000_0123_0000_0000_0123),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_16var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed16Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Signed16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Opcode(OP::Signed16Var),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed16(0x0011),
            VmTerm::Signed16(0x2301),
            VmTerm::Signed16(0x0123),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_32var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed32Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Signed32Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Signed32Var),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed32(0x0000_0011),
            VmTerm::Signed32(0x0000_2301),
            VmTerm::Signed32(0x0000_0123),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_64var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed64Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Signed64Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Signed64Var),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed64(0x0000_0000_0000_0011),
            VmTerm::Signed64(0x0123_0000_0000_2301),
            VmTerm::Signed64(0x0123_0000_0000_0123),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_128var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed128Var),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Opcode(OP::Signed128Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed128(0x2200_0000_0000_0000_0123_0000_0000_2301),
            VmTerm::Signed128(0x1100_0000_0000_0000_0123_0000_0000_0123),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_float_32var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Float32Var),
                ScriptEntry::Byte(0x77),
                ScriptEntry::Byte(0xbe),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Byte(0x3f),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Float32(Float32Wrapper(1.123)), // le bytes: [0x77, 0xbe, 0x8f, 0x37]
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_float_64var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Float64Var),
                ScriptEntry::Byte(0x4c),
                ScriptEntry::Byte(0xb6),
                ScriptEntry::Byte(0xcb),
                ScriptEntry::Byte(0xc8),
                ScriptEntry::Byte(0x8a),
                ScriptEntry::Byte(0x48),
                ScriptEntry::Byte(0x93),
                ScriptEntry::Byte(0x40),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Float64(Float64Wrapper(1_234.135_531_6)), // le bytes: [0x4c, 0xb6, 0xcb, 0xc8, 0x8a, 0x48, 0x93, 0x40]
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_decimal_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::DecimalVar),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x4e),
                ScriptEntry::Byte(0x61),
                ScriptEntry::Byte(0xbc),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::DecimalVar),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Byte(0xce),
                ScriptEntry::Byte(0xdd),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Decimal(dec!(123.45678)), // serialized: [0x00, 0x00, 0x05, 0x00, 0x4e, 0x61, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
            VmTerm::Decimal(dec!(313.13579)), // serialized: [0x00, 0x00, 0x05, 0x00, 0xab, 0xce, 0xdd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_hash_160_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Hash160ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Hash160ArrayVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Hash160Array(vec![
                [
                    0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85,
                    0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57,
                ],
                [
                    0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85,
                    0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57,
                ],
            ]),
            VmTerm::Hash160Array(vec![[
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57,
            ]]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_hash_256_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Hash256ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Hash256ArrayVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Hash256Array(vec![
                [
                    0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85,
                    0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53,
                    0x23, 0x47, 0x35, 0x12, 0x18, 0x34,
                ],
                [
                    0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85,
                    0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53,
                    0x23, 0x47, 0x35, 0x12, 0x18, 0x34,
                ],
            ]),
            VmTerm::Hash256Array(vec![[
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47,
                0x35, 0x12, 0x18, 0x34,
            ]]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_hash_512_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Hash512ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Hash512ArrayVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x85),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x69),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x22),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x57),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0x53),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x47),
                ScriptEntry::Byte(0x35),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Hash512Array(vec![
                [
                    0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85,
                    0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53,
                    0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23,
                    0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57,
                    0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34,
                ],
                [
                    0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85,
                    0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53,
                    0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23,
                    0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57,
                    0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34,
                ],
            ]),
            VmTerm::Hash512Array(vec![[
                0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34, 0x85, 0x36,
                0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47,
                0x35, 0x12, 0x18, 0x34, 0x36, 0x23, 0x74, 0x23, 0x78, 0x53, 0x23, 0x47, 0x35, 0x12,
                0x18, 0x34, 0x85, 0x36, 0x69, 0x09, 0x22, 0x35, 0x78, 0x57, 0x36, 0x23, 0x74, 0x23,
                0x78, 0x53, 0x23, 0x47, 0x35, 0x12, 0x18, 0x34,
            ]]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_8_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x3f),
                ScriptEntry::Byte(0x79),
                ScriptEntry::Byte(0x25),
                ScriptEntry::Byte(0xae),
                ScriptEntry::Byte(0x77),
                ScriptEntry::Byte(0xa1),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0x3f, 0x79, 0x25, 0xae, 0x77, 0xa1]),
            VmTerm::Unsigned8Array(vec![0x75, 0xaf, 0xf6, 0xa5]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_16_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x3f),
                ScriptEntry::Byte(0x26),
                ScriptEntry::Byte(0x79),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Byte(0x25),
                ScriptEntry::Byte(0xbc),
                ScriptEntry::Byte(0xae),
                ScriptEntry::Byte(0x27),
                ScriptEntry::Byte(0x77),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0xa1),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned16Array(vec![0x3ffe, 0x7926, 0x2510, 0xaebc, 0x7727, 0xa123]),
            VmTerm::Unsigned16Array(vec![0x7536, 0x7516, 0xaf41, 0xa5f6]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_32_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned32ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Opcode(OP::Unsigned32ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned32Array(vec![
                0xa5f6_af41,
                0x7516_7536,
                0x7516_7536,
                0x7516_7536,
                0x7516_7536,
                0xa5f6_af41,
            ]),
            VmTerm::Unsigned32Array(vec![0x01fe_7814, 0x7516_7536, 0xa5f6_af41, 0x7516_7536]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_64_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned64ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Opcode(OP::Unsigned64ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned64Array(vec![
                0xa5f6_af41_a5f6_af41,
                0x7516_7536_7516_7536,
                0x7516_7536_7516_7536,
                0x7516_7536_7516_7536,
                0x7516_7536_7516_7536,
                0xa5f6_af41_a5f6_af41,
            ]),
            VmTerm::Unsigned64Array(vec![
                0x01fe_7814_01fe_7814,
                0x7516_7536_7516_7536,
                0xa5f6_af41_a5f6_af41,
                0x7516_7536_7516_7536,
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_unsigned_128_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned128ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Opcode(OP::Unsigned128ArrayVar),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned128Array(vec![
                0x7516_7536_7516_7536_a5f6_af41_a5f6_af41,
                0x7516_7536_7516_7536_7516_7536_7516_7536,
                0xa5f6_af41_a5f6_af41_7516_7536_7516_7536,
            ]),
            VmTerm::Unsigned128Array(vec![
                0x7516_7536_7516_7536_01fe_7814_01fe_7814,
                0x7516_7536_7516_7536_a5f6_af41_a5f6_af41,
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_8_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x34),
                ScriptEntry::Byte(0x54),
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x3f),
                ScriptEntry::Byte(0x79),
                ScriptEntry::Byte(0x25),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x77),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed8Array(vec![0x3f, 0x79, 0x25, 0x12, 0x77, 0x11]),
            VmTerm::Signed8Array(vec![0x75, 0x12, 0x34, 0x54]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_16_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed16ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0x1f),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Opcode(OP::Signed16ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x3f),
                ScriptEntry::Byte(0x26),
                ScriptEntry::Byte(0x79),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Byte(0x25),
                ScriptEntry::Byte(0xbc),
                ScriptEntry::Byte(0x2e),
                ScriptEntry::Byte(0x27),
                ScriptEntry::Byte(0x77),
                ScriptEntry::Byte(0x23),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed16Array(vec![0x3ffe, 0x7926, 0x2510, 0x2ebc, 0x7727, 0x1123]),
            VmTerm::Signed16Array(vec![0x7536, 0x7516, 0x1f41, 0x15f6]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_32_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed32ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Opcode(OP::Signed32ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed32Array(vec![
                0x15f6_af41,
                0x7516_7536,
                0x7516_7536,
                0x7516_7536,
                0x7516_7536,
                0x15f6_af41,
            ]),
            VmTerm::Signed32Array(vec![0x01fe_7814, 0x7516_7536, 0x15f6_af41, 0x7516_7536]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_64_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed64ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Opcode(OP::Signed64ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed64Array(vec![
                0x15f6_af41_a5f6_af41,
                0x7516_7536_7516_7536,
                0x7516_7536_7516_7536,
                0x7516_7536_7516_7536,
                0x7516_7536_7516_7536,
                0x15f6_af41_a5f6_af41,
            ]),
            VmTerm::Signed64Array(vec![
                0x01fe_7814_01fe_7814,
                0x7516_7536_7516_7536,
                0x15f6_af41_a5f6_af41,
                0x7516_7536_7516_7536,
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_signed_128_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed128ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x78),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Opcode(OP::Signed128ArrayVar),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x36),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed128Array(vec![
                0x7516_7536_7516_7536_a5f6_af41_a5f6_af41,
                0x7516_7536_7516_7536_7516_7536_7516_7536,
                0x15f6_af41_a5f6_af41_7516_7536_7516_7536,
            ]),
            VmTerm::Signed128Array(vec![
                0x7516_7536_7516_7536_01fe_7814_01fe_7814,
                0x7516_7536_7516_7536_a5f6_af41_a5f6_af41,
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_float_32_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Float32ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x77),
                ScriptEntry::Byte(0xbe),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Byte(0x3f),
                ScriptEntry::Byte(0x25),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x55),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Float32ArrayVar),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x5c),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x43),
                ScriptEntry::Byte(0x77),
                ScriptEntry::Byte(0xbe),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Byte(0x3f),
                ScriptEntry::Byte(0x25),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x55),
                ScriptEntry::Byte(0x41),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Float32Array(vec![
                Float32Wrapper(1.123_f32),  // le bytes: [0x77, 0xbe, 0x8f, 0x37]
                Float32Wrapper(13.314_f32), // le bytes: [0x25, 0x06, 0x55, 0x41]
            ]),
            VmTerm::Float32Array(vec![
                Float32Wrapper(133.45453_f32), // le bytes: [0x5c, 0x74, 0x05, 0x43]
                Float32Wrapper(1.123_f32),     // le bytes: [0x77, 0xbe, 0x8f, 0x37]
                Float32Wrapper(13.314_f32),    // le bytes: [0x25, 0x06, 0x55, 0x41]
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_float_64_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Float64ArrayVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x4c),
                ScriptEntry::Byte(0xb6),
                ScriptEntry::Byte(0xcb),
                ScriptEntry::Byte(0xc8),
                ScriptEntry::Byte(0x8a),
                ScriptEntry::Byte(0x48),
                ScriptEntry::Byte(0x93),
                ScriptEntry::Byte(0x40),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Float64ArrayVar),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x4c),
                ScriptEntry::Byte(0xb6),
                ScriptEntry::Byte(0xcb),
                ScriptEntry::Byte(0xc8),
                ScriptEntry::Byte(0x8a),
                ScriptEntry::Byte(0x48),
                ScriptEntry::Byte(0x93),
                ScriptEntry::Byte(0x40),
                ScriptEntry::Byte(0x74),
                ScriptEntry::Byte(0x29),
                ScriptEntry::Byte(0xae),
                ScriptEntry::Byte(0x2a),
                ScriptEntry::Byte(0xbb),
                ScriptEntry::Byte(0x8a),
                ScriptEntry::Byte(0xa9),
                ScriptEntry::Byte(0x40),
                ScriptEntry::Byte(0x4c),
                ScriptEntry::Byte(0xb6),
                ScriptEntry::Byte(0xcb),
                ScriptEntry::Byte(0xc8),
                ScriptEntry::Byte(0x8a),
                ScriptEntry::Byte(0x48),
                ScriptEntry::Byte(0x93),
                ScriptEntry::Byte(0x40),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Float64Array(vec![
                Float64Wrapper(1_234.135_531_6_f64), // le bytes: [0x4c, 0xb6, 0xcb, 0xc8, 0x8a, 0x48, 0x93, 0x40]
            ]),
            VmTerm::Float64Array(vec![
                Float64Wrapper(1_234.135_531_6_f64), // le bytes: [0x4c, 0xb6, 0xcb, 0xc8, 0x8a, 0x48, 0x93, 0x40]
                Float64Wrapper(3269.36556_f64), // le bytes: [0x74, 0x29, 0xae, 0x2a, 0xbb, 0x8a, 0xa9, 0x40]
                Float64Wrapper(1_234.135_531_6_f64), // le bytes: [0x4c, 0xb6, 0xcb, 0xc8, 0x8a, 0x48, 0x93, 0x40]
            ]),
        ];

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_loads_decimal_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::DecimalArrayVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x4e),
                ScriptEntry::Byte(0x61),
                ScriptEntry::Byte(0xbc),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::DecimalArrayVar),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x4e),
                ScriptEntry::Byte(0x61),
                ScriptEntry::Byte(0xbc),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Byte(0xce),
                ScriptEntry::Byte(0xdd),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x4e),
                ScriptEntry::Byte(0x61),
                ScriptEntry::Byte(0xbc),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::DecimalArray(vec![
                dec!(123.45678), // serialized: [0x00, 0x00, 0x05, 0x00, 0x4e, 0x61, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
            ]),
            VmTerm::DecimalArray(vec![
                dec!(123.45678), // serialized: [0x00, 0x00, 0x05, 0x00, 0x4e, 0x61, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
                dec!(313.13579), // serialized: [0x00, 0x00, 0x05, 0x00, 0xab, 0xce, 0xdd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
                dec!(123.45678), // serialized: [0x00, 0x00, 0x05, 0x00, 0x4e, 0x61, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
            ]),
        ];

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_array_len() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::ArrayLen),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x3f),
                ScriptEntry::Byte(0x79),
                ScriptEntry::Byte(0x25),
                ScriptEntry::Byte(0xae),
                ScriptEntry::Byte(0x77),
                ScriptEntry::Byte(0xa1),
                ScriptEntry::Opcode(OP::ArrayLen),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> =
            vec![VmTerm::Unsigned16(0x0004), VmTerm::Unsigned16(0x0006)];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_gets_type() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomHash160Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomHash256Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomHash512Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomUnsigned8Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomUnsigned16Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomUnsigned32Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomUnsigned64Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomUnsigned128Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomSigned8Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomSigned16Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomSigned32Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomSigned64Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomSigned128Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomFloat32Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomFloat64Var),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::RandomDecimalVar),
                ScriptEntry::Opcode(OP::GetType),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x02),
            VmTerm::Unsigned8(0x03),
            VmTerm::Unsigned8(0x04),
            VmTerm::Unsigned8(0x05),
            VmTerm::Unsigned8(0x06),
            VmTerm::Unsigned8(0x07),
            VmTerm::Unsigned8(0x09),
            VmTerm::Unsigned8(0x0a),
            VmTerm::Unsigned8(0x0b),
            VmTerm::Unsigned8(0x0c),
            VmTerm::Unsigned8(0x0d),
            VmTerm::Unsigned8(0x0f),
            VmTerm::Unsigned8(0x10),
            VmTerm::Unsigned8(0x11),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_gets_at_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::GetAtArray),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::GetAtArray),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::GetAtArray),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::GetAtArray),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::GetAtArray),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x04),
            VmTerm::Unsigned8(0x08),
            VmTerm::Unsigned8(0x05),
            VmTerm::Unsigned8(0x06),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_get_at_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::GetAtArray),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::IndexOutOfBounds);
    }

    #[test]
    fn it_pushes_back_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PushBackArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> =
            vec![VmTerm::Unsigned8Array(vec![0x01, 0x02, 0x03, 0x04, 0x0a])];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_to_push_back_array_different_args() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PushBackArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_pushes_front_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PushFrontArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> =
            vec![VmTerm::Unsigned8Array(vec![0x0a, 0x01, 0x02, 0x03, 0x04])];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_to_push_front_array_different_args() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PushFrontArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_pops_back_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PopBackArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x04),
            VmTerm::Unsigned8Array(vec![0x01, 0x02, 0x03]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_to_pop_back_array_different_args_than_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::PopBackArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_pops_front_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PopFrontArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8Array(vec![0x02, 0x03, 0x04]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_to_pop_front_array_different_args_than_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::PopFrontArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_deletes_at_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::DeleteAtArray),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::DeleteAtArray),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8Array(vec![0x02, 0x04])];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_to_delete_at_array_different_args_than_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::DeleteAtArray),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_fails_to_delete_at_array_index_out_of_bound() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::DeleteAtArray),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::IndexOutOfBounds);
    }

    #[test]
    fn it_generates_random_160_hash() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomHash160Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomHash160Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Hash160(rng.gen::<[u8; 20]>()),
            VmTerm::Hash160(rng.gen::<[u8; 20]>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_256_hash() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomHash256Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomHash256Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Hash256(rng.gen::<[u8; 32]>()),
            VmTerm::Hash256(rng.gen::<[u8; 32]>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_512_hash() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomHash512Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomHash512Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let p1 = rng.gen::<[u8; 32]>();
        let p2 = rng.gen::<[u8; 32]>();
        let p3 = rng.gen::<[u8; 32]>();
        let p4 = rng.gen::<[u8; 32]>();

        let mut res1 = [0; 64];
        let mut res2 = [0; 64];

        res1[..32].copy_from_slice(&p1);
        res1[32..64].copy_from_slice(&p2);
        res2[..32].copy_from_slice(&p3);
        res2[32..64].copy_from_slice(&p4);

        let script_output: Vec<VmTerm> = vec![VmTerm::Hash512(res1), VmTerm::Hash512(res2)];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_unsigned_8var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomUnsigned8Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomUnsigned8Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(rng.gen::<u8>()),
            VmTerm::Unsigned8(rng.gen::<u8>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_unsigned_16var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomUnsigned16Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomUnsigned16Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned16(rng.gen::<u16>()),
            VmTerm::Unsigned16(rng.gen::<u16>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_unsigned_32var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomUnsigned32Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomUnsigned32Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned32(rng.gen::<u32>()),
            VmTerm::Unsigned32(rng.gen::<u32>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_unsigned_64var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomUnsigned64Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomUnsigned64Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned64(rng.gen::<u64>()),
            VmTerm::Unsigned64(rng.gen::<u64>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_unsigned_128var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomUnsigned128Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomUnsigned128Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned128(rng.gen::<u128>()),
            VmTerm::Unsigned128(rng.gen::<u128>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_signed_8var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomSigned8Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomSigned8Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed8(rng.gen::<i8>()),
            VmTerm::Signed8(rng.gen::<i8>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_signed_16var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomSigned16Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomSigned16Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed16(rng.gen::<i16>()),
            VmTerm::Signed16(rng.gen::<i16>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_signed_32var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomSigned32Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomSigned32Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed32(rng.gen::<i32>()),
            VmTerm::Signed32(rng.gen::<i32>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_signed_64var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomSigned64Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomSigned64Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed64(rng.gen::<i64>()),
            VmTerm::Signed64(rng.gen::<i64>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_signed_128var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomSigned128Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomSigned128Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Signed128(rng.gen::<i128>()),
            VmTerm::Signed128(rng.gen::<i128>()),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_float_32var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomFloat32Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomFloat32Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Float32(Float32Wrapper(rng.gen::<f32>())),
            VmTerm::Float32(Float32Wrapper(rng.gen::<f32>())),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_float_64var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomFloat64Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomFloat64Var),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Float64(Float64Wrapper(rng.gen::<f64>())),
            VmTerm::Float64(Float64Wrapper(rng.gen::<f64>())),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_generates_random_decimal_var() {
        let seed = [0; 32];
        let mut rng: Pcg64 = Seeder::from(seed).make_rng();

        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::RandomDecimalVar),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::RandomDecimalVar),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Decimal(Decimal::deserialize(rng.gen::<[u8; 16]>())),
            VmTerm::Decimal(Decimal::deserialize(rng.gen::<[u8; 16]>())),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                seed,
                key,
                "",
                VmFlags {
                    can_fail: true,
                    ..VmFlags::default()
                }
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_1_if_eq_and_0_if_not() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Eq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Eq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Opcode(OP::Eq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Eq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_1_if_neq_and_0_if_not() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Neq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Neq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Neq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Neq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_1_if_lt_and_0_if_not() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Lt),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Lt),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Opcode(OP::Lt),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Lt),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_1_if_gt_and_0_if_not() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Gt),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Gt),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Gt),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Gt),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_1_if_leq_and_0_if_not() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Leq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Leq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Leq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Leq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_1_if_geq_and_0_if_not() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Geq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Geq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Geq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Geq),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_ghostrider() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x20),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0x0c),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x0e),
                ScriptEntry::Byte(0x0f),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x13),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x17),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x19),
                ScriptEntry::Byte(0x1a),
                ScriptEntry::Byte(0x1b),
                ScriptEntry::Byte(0x1c),
                ScriptEntry::Byte(0x1d),
                ScriptEntry::Byte(0x1e),
                ScriptEntry::Byte(0x1f),
                ScriptEntry::Byte(0x2a),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::GhostRider),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x20),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0x0c),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x0e),
                ScriptEntry::Byte(0x0f),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x13),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x17),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x19),
                ScriptEntry::Byte(0x1a),
                ScriptEntry::Byte(0x1b),
                ScriptEntry::Byte(0x1c),
                ScriptEntry::Byte(0x1d),
                ScriptEntry::Byte(0x1e),
                ScriptEntry::Byte(0x1f),
                ScriptEntry::Byte(0x2a),
                ScriptEntry::Opcode(OP::Signed8Var), // Value
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::GhostRider),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];
        let new_key: [u8; 32] = [
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x2a,
        ];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::ghostrider256(&term, new_key);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_ghostrider_hashing_with_wrong_key_type() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar), // Key
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::GhostRider),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_fails_ghostrider_hashing_with_wrong_key_length() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x1f),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0x0c),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x0e),
                ScriptEntry::Byte(0x0f),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Byte(0x11),
                ScriptEntry::Byte(0x12),
                ScriptEntry::Byte(0x13),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0x16),
                ScriptEntry::Byte(0x17),
                ScriptEntry::Byte(0x18),
                ScriptEntry::Byte(0x19),
                ScriptEntry::Byte(0x1a),
                ScriptEntry::Byte(0x1b),
                ScriptEntry::Byte(0x1c),
                ScriptEntry::Byte(0x1d),
                ScriptEntry::Byte(0x1e),
                ScriptEntry::Byte(0x1f),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::GhostRider),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_hashes_with_fugue() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Fugue),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Opcode(OP::Fugue),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::Fugue),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xc1),
                ScriptEntry::Opcode(OP::Fugue),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Opcode(OP::Fugue),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x10),
            VmTerm::Unsigned8(0xa5),
            VmTerm::Unsigned8(0xc1),
            VmTerm::Unsigned8(0xff),
        ];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::fugue256(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_jh256() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::JH256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::JH256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::jh256(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_ripemd() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Ripemd160),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Ripemd160),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::ripemd160(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_sha256() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Sha256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Sha256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::sha256(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_sha512() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Sha512),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Sha512),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::sha512(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake2b() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake2b256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake2b256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake2b512),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake2b512),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in &test_terms {
            let hashed_term_256 = bifs::blake2b_256(term);
            script_output.push(hashed_term_256);
        }
        for term in &test_terms {
            let hashed_term_512 = bifs::blake2b_512(term);
            script_output.push(hashed_term_512);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_160() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_160),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_160),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_160(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_256() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_256(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_512() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_512),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_512),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_512(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_256_160() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_256_160),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_256_160),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_256_160(&term);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_256_keyed() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_256Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Signed8Var), // Value
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_256Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];
        let utf_key = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a];
        let utf_key = from_utf8(utf_key.as_slice()).unwrap();

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_256_internal(&term, utf_key);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_256_keyed_with_valid_utf8_key() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_256Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01)];
        let utf_key = vec![0xe2, 0x9d, 0xa4, 0xef, 0xb8, 0x8f];
        let utf_key = from_utf8(utf_key.as_slice()).unwrap();

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_256_internal(&term, utf_key);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_panics_hashing_with_blake3_256_keyed_because_of_invalid_key_type() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar), // Key
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_256Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_panics_hashing_with_blake3_256_keyed_with_invalid_utf8_key() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_256Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_hashes_with_blake3_512_keyed() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_512Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Signed8Var), // Value
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_512Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];
        let utf_key = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a];
        let utf_key = from_utf8(utf_key.as_slice()).unwrap();

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_512_internal(&term, utf_key);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_512_keyed_with_valid_utf8_key() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_512Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Opcode(OP::Signed8Var), // Value
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_512Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];
        let utf_key = vec![0xe2, 0x9d, 0xa4, 0xef, 0xb8, 0x8f];
        let utf_key = from_utf8(utf_key.as_slice()).unwrap();

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_512_internal(&term, utf_key);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_panics_hashing_with_blake3_512_keyed_because_of_invalid_key_type() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar), // Key
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_512Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_panics_hashing_with_blake3_512_keyed_with_invalid_utf8_key() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_512Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_hashes_with_blake3_160_keyed() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_160Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Signed8Var), // Value
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_160Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];
        let utf_key = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a];
        let utf_key = from_utf8(utf_key.as_slice()).unwrap();

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_160_internal(&term, utf_key);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_160_keyed_with_valid_utf8_key() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_160Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Opcode(OP::Signed8Var), // Value
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_160Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];
        let utf_key = vec![0xe2, 0x9d, 0xa4, 0xef, 0xb8, 0x8f];
        let utf_key = from_utf8(utf_key.as_slice()).unwrap();

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_160_internal(&term, utf_key);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_panics_hashing_with_blake3_160_keyed_because_of_invalid_key_type() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar), // Key
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_160Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_panics_hashing_with_blake3_160_keyed_with_invalid_utf8_key() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Key
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Value
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_160Keyed),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_hashes_with_blake3_160internal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_160Internal),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_160Internal),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_160_internal(&term, key);
            assert_eq!(hashed_term.size(), 20);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_256internal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_256Internal),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_256Internal),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_256_internal(&term, key);
            assert_eq!(hashed_term.size(), 32);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_512_internal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_512Internal),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_512Internal),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_512_internal(&term, key);
            assert_eq!(hashed_term.size(), 64);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake3_256_160_internal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake3_256_160Internal),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake3_256_160Internal),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake3_256_160_internal(&term, key);
            assert_eq!(hashed_term.size(), 20);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_hashes_with_blake2s_256() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Blake2s256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Blake2s256),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let test_terms = vec![VmTerm::Unsigned8(0x01), VmTerm::Signed8(-1)];

        let mut script_output: Vec<VmTerm> = vec![];
        for term in test_terms {
            let hashed_term = bifs::blake2s_256(&term);
            assert_eq!(hashed_term.size(), 32);
            script_output.push(hashed_term);
        }

        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_adds_two_numbers() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFE),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x03),
            VmTerm::Signed8(-3),
            VmTerm::Signed8(0),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_panics_if_add_not_same_type() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x03),
            VmTerm::Signed8(-3),
            VmTerm::Signed8(0),
        ];
        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_subs_two_numbers() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Sub),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFE),
                ScriptEntry::Opcode(OP::Sub),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Sub),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01),
            VmTerm::Signed8(1),
            VmTerm::Signed8(-2),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_subs_from_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Sub),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8Array(vec![0x01, 0x02])];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_subs_array_from_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0A),
                ScriptEntry::Byte(0x14),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Sub),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8Array(vec![0x08, 0x11])];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_subs_array_from_array_overflow() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0A),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Sub),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8Array(vec![0x08, 0x11])];
        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_multiples_array_with_number() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Mult),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8Array(vec![0x04, 0x6])];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_multiples_array_with_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Mult),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8Array(vec![0x04, 0x09])];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_multiplies_array_with_array_overflow() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Mult),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8Array(vec![])];
        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_cannot_multiply_two_arrays_with_different_length() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Mult),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_multiplies_two_numbers() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Mult),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFE),
                ScriptEntry::Opcode(OP::Mult),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Mult),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x06),
            VmTerm::Signed8(2),
            VmTerm::Signed8(-1),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_divides_two_numbers() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Div),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFC),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFE),
                ScriptEntry::Opcode(OP::Div),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xFF),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Div),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x02),
            VmTerm::Signed8(0x02),
            VmTerm::Signed8(-1),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_divides_array_with_number() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Div),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8Array(vec![0x02, 0x4])];
        assert_script_ok(ss, script_output, key);

        let ss_2 = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xFE),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Div),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output_2: Vec<VmTerm> = vec![VmTerm::Signed8Array(vec![0x00, -1])];
        assert_script_ok(ss_2, script_output_2, key);
    }

    #[test]
    fn it_divides_array_with_another_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Div),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xFC),
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xFE),
                ScriptEntry::Opcode(OP::Div),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![1, 1]),
            VmTerm::Signed8Array(vec![2]),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_divides_array_with_another_array_overflow() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Div),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_returns_min() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Min),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Min),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xaa),
                ScriptEntry::Byte(0xaa),
                ScriptEntry::Opcode(OP::Min),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xee),
                ScriptEntry::Byte(0xee),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xee),
                ScriptEntry::Byte(0xee),
                ScriptEntry::Opcode(OP::Min),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x05),
            VmTerm::Unsigned8(0x03),
            VmTerm::Unsigned16(0xaaaa),
            VmTerm::Unsigned16(0xeeee),
            VmTerm::Unsigned8(0x02),
            VmTerm::Unsigned8(0x02),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_returns_max() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Max),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Max),
                ScriptEntry::Opcode(OP::Nop),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Byte(0xff),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xaa),
                ScriptEntry::Byte(0xaa),
                ScriptEntry::Opcode(OP::Max),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xee),
                ScriptEntry::Byte(0xee),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xee),
                ScriptEntry::Byte(0xee),
                ScriptEntry::Opcode(OP::Max),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x06),
            VmTerm::Unsigned8(0x09),
            VmTerm::Unsigned16(0xffff),
            VmTerm::Unsigned16(0xeeee),
            VmTerm::Unsigned8(0x02),
            VmTerm::Unsigned8(0x02),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_checks_within() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // Case 1: 2 <= 3 < 4 => true
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Within),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Case 2: 2 <= 2 < 4 => true
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Within),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Case 3: 2 <= 1 < 4 => false
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Within),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Case 4: 2 <= 4 < 4 => false
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Within),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var), // Case 5: 2 <= 5 < 4 => false
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Within),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x01), // true
            VmTerm::Unsigned8(0x01), // true
            VmTerm::Unsigned8(0x00), // false
            VmTerm::Unsigned8(0x00), // false
            VmTerm::Unsigned8(0x00), // false
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_fails_within_check() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Within),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_inverts_bits_primitives() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned64Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned128Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed16Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed32Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed64Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed128Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x1d),
            VmTerm::Unsigned16(0x3c1d),
            VmTerm::Unsigned32(0x3c1d_3c1d),
            VmTerm::Unsigned64(0x3c1d_3c1d_3c1d_3c1d),
            VmTerm::Unsigned128(0x3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d),
            VmTerm::Signed8(0x1d),
            VmTerm::Signed16(0x3c1d),
            VmTerm::Signed32(0x3c1d_3c1d),
            VmTerm::Signed64(0x3c1d_3c1d_3c1d_3c1d),
            VmTerm::Signed128(0x3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_inverts_bits_arrays() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned32ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned64ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned128ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed32ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed64ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed128ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::BitInvert),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0x1d, 0x1d]),
            VmTerm::Unsigned16Array(vec![0x3c1d, 0x3c1d]),
            VmTerm::Unsigned32Array(vec![0x3c1d_3c1d, 0x3c1d_3c1d]),
            VmTerm::Unsigned64Array(vec![0x3c1d_3c1d_3c1d_3c1d, 0x3c1d_3c1d_3c1d_3c1d]),
            VmTerm::Unsigned128Array(vec![
                0x3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d,
                0x3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d,
            ]),
            VmTerm::Signed8Array(vec![0x1d, 0x1d]),
            VmTerm::Signed16Array(vec![0x3c1d, 0x3c1d]),
            VmTerm::Signed32Array(vec![0x3c1d_3c1d, 0x3c1d_3c1d]),
            VmTerm::Signed64Array(vec![0x3c1d_3c1d_3c1d_3c1d, 0x3c1d_3c1d_3c1d_3c1d]),
            VmTerm::Signed128Array(vec![
                0x3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d,
                0x3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d_3c1d,
            ]),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_ands_primitives() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BitAND),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitAND),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> =
            vec![VmTerm::Unsigned8(0xe2), VmTerm::Unsigned16(0x83e2)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_ands_arrays() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BitAND),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitAND),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0xe2, 0xe2]),
            VmTerm::Unsigned16Array(vec![0x83e2, 0x83e2]),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_ors_primitives() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BitOR),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitOR),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> =
            vec![VmTerm::Unsigned8(0xf3), VmTerm::Unsigned16(0xebf3)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_ors_arrays() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BitOR),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitOR),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0xf3, 0xf3]),
            VmTerm::Unsigned16Array(vec![0xebf3, 0xebf3]),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_xors_primitives() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BitXOR),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitXOR),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> =
            vec![VmTerm::Unsigned8(0x11), VmTerm::Unsigned16(0x6811)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_xors_arrays() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BitXOR),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0xc3),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitXOR),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0x11, 0x11]),
            VmTerm::Unsigned16Array(vec![0x6811, 0x6811]),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_shifts_left_primitives() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x6e),
                ScriptEntry::Opcode(OP::BitSHLeft),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitSHLeft),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> =
            vec![VmTerm::Unsigned8(0xb8), VmTerm::Unsigned16(0x5f98)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_shifts_left_arrays() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BitSHLeft),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitSHLeft),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0xcc, 0x98]),
            VmTerm::Unsigned16Array(vec![0x57e6, 0xafcc]),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_shifts_right_primitives() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x6e),
                ScriptEntry::Opcode(OP::BitSHRight),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitSHRight),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> =
            vec![VmTerm::Unsigned8(0x1b), VmTerm::Unsigned16(0x157e)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_shifts_right_arrays() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BitSHRight),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Byte(0xab),
                ScriptEntry::Opcode(OP::BitSHRight),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0x3c, 0x1e]),
            VmTerm::Unsigned16Array(vec![0x55f9, 0x2afc]),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_traps() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Trap),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_traps_if_value_equals_to_one() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIf),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_doesnt_trap_if_value_doenst_equal_one() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIf),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_traps_if_values_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfEq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_doesnt_trap_if_values_are_not_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIfEq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_traps_if_values_are_not_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIfNeq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_doesnt_trap_if_values_are_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfNeq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_traps_if_top_item_is_less_or_equal_to_second() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIfLeq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_traps_if_top_item_is_less_or_equal_to_second_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfLeq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_doesnt_trap_if_top_item_is_not_less_or_equal_to_second() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIfLeq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_traps_if_top_item_is_greater_or_equal_to_second() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIfGeq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_traps_if_top_item_is_greater_or_equal_to_second_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIfGeq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_doesnt_trap_if_top_item_is_not_greater_or_equal_to_second() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfGeq),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_traps_if_top_item_is_less_than_the_second() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfLt),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_doesnt_trap_if_top_item_is_not_less_than_the_second() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfLt),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_doesnt_trap_if_top_item_is_not_less_than_the_second_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIfLt),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_traps_if_top_item_is_greater_than_the_second() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::TrapIfGt),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_doesnt_trap_if_top_item_is_not_greater_than_the_second() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfGt),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_doesnt_trap_if_top_item_is_not_greater_than_the_second_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfGt),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_traps_if_top_item_type_is_not_same_as_given() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfNeqType),
                ScriptEntry::Byte(0xaa),
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned32(0x0404_0404),
            VmTerm::Unsigned32(0x0101_0101),
        ];
        assert_script_fail(ss, script_output, key, ExecutionResult::Panic);
    }

    #[test]
    fn it_doesnt_trap_if_top_item_type_is_same_as_given() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned16Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::TrapIfNeqType),
                ScriptEntry::Byte(0x04), // Type for Unsigned16Var
                ScriptEntry::Opcode(OP::Unsigned32Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned32(0x0404_0404),
            VmTerm::Unsigned32(0x0101_0101),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_substr() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Substr),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Substr),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Substr),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0x75, 0xaf, 0xf6, 0xa5]), // Substr 0 -> 1st 0 elems, 2nd 4 elems (inverted logic)
            VmTerm::Unsigned8Array(vec![]),
            VmTerm::Unsigned8Array(vec![0xf6, 0xa5]), // Substr 2 -> 1st = 2 elems, 2nd = 2 elems (inverted logic)
            VmTerm::Unsigned8Array(vec![0x75, 0xaf]),
            VmTerm::Unsigned8Array(vec![]), // Substr 4 -> 1st 4 elems, 2nd 0 elems (inverted logic)
            VmTerm::Unsigned8Array(vec![0x75, 0xaf, 0xf6, 0xa5]),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_panics_substr_if_mid_greater_than_len() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x75),
                ScriptEntry::Byte(0xaf),
                ScriptEntry::Byte(0xf6),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::Substr),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Substr),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Substr),
                ScriptEntry::Byte(0x05), // Bound overflow
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![0x75, 0xaf, 0xf6, 0xa5]),
            VmTerm::Unsigned8Array(vec![]),
            VmTerm::Unsigned8Array(vec![0xf6, 0xa5]),
            VmTerm::Unsigned8Array(vec![0x75, 0xaf]),
        ];
        assert_script_fail(ss, script_output, key, ExecutionResult::IndexOutOfBounds);
    }

    #[test]
    fn it_verifies_if_values_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::EqVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_less() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::LtVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_less_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::LtVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Opcode(OP::BreakIfLt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_greater() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::GtVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::BreakIfGt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_greater_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::GtVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::BreakIfGt),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 120, vec![], 3, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_less_or_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::LeqVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::BreakIfLeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_less_or_equal_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::LeqVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::BreakIfLeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_greater_or_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::GeqVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::BreakIfGeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_greater_or_equal_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Sub1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::GeqVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::BreakIfGeq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 90, vec![], 2, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_verifies_if_values_not_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Loop),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Add1),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::NeqVerify),
                ScriptEntry::Opcode(OP::Pick), // fail safe, break the loop eventually
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::BreakIfEq),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::Trap),
            ],
            ..Script::default()
        };

        let base: TestBaseArgs = get_test_base_args(&mut ss, 60, vec![], 1, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_validates_utf8_arrays() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Valid  UTF8 sequence
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Byte(0x8f),
                ScriptEntry::Opcode(OP::IsUTF8),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Invalid  UTF8 sequence
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Byte(0x9d),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xef),
                ScriptEntry::Byte(0xb8),
                ScriptEntry::Opcode(OP::IsUTF8),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar), // Invalid  UTF8 sequence
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xe3),
                ScriptEntry::Byte(0x9a),
                ScriptEntry::Byte(0xa2),
                ScriptEntry::Byte(0xe1),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Opcode(OP::IsUTF8),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(1),
            VmTerm::Unsigned8(0),
            VmTerm::Unsigned8(0),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_panics_checking_utf8_sequence_because_of_invalid_type() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned16ArrayVar), // Invalid UTF8 term type
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::IsUTF8),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_concat_arrays() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xa0),
                ScriptEntry::Byte(0xa1),
                ScriptEntry::Byte(0xa2),
                ScriptEntry::Byte(0xa3),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::Concat),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x09),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Concat),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
            ]),
            VmTerm::Signed8Array(vec![
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04,
            ]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_panics_if_cannot_concat() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0xa0),
                ScriptEntry::Byte(0xa1),
                ScriptEntry::Byte(0xa2),
                ScriptEntry::Byte(0xa3),
                ScriptEntry::Byte(0xa4),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Concat),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_panics_if_cannot_concat_test_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xa5),
                ScriptEntry::Opcode(OP::Signed8ArrayVar),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Concat),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_peeks_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PeekArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x04),
            VmTerm::Unsigned8Array(vec![0x01, 0x02, 0x03, 0x04]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_to_peek_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PeekArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_clears_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8ArrayVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Dup),
                ScriptEntry::Opcode(OP::ClearArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8Array(vec![]),
            VmTerm::Unsigned8Array(vec![0x01, 0x02, 0x03, 0x04]),
        ];
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, script_output, 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_fails_to_clear_array() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::ClearArray),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![];

        assert_script_fail(ss, script_output, key, ExecutionResult::InvalidArgs);
    }

    #[test]
    fn it_pushes_out_if_value_equals_1() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00), // stack: [out, out, out, 0, 0, 0, 1, 0]
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments, stack: [out, out, out, 0, 0, 0, 1, 0, out, out, out]
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Roll), // start rolling the values to the top
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::PushOutIf), // 0 == 1 false, continue
                ScriptEntry::Opcode(OP::Roll),      // roll the next value to the top
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::PushOutIf), // 0 == 1 false, continue
                ScriptEntry::Opcode(OP::Roll),      // roll the next value to the top
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::PushOutIf), // 0 == 1 false, continue
                ScriptEntry::Opcode(OP::Roll),      // roll the next value to the top
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::PushOutIf), // 1 == 1 true, will push out, stack: [out, out, out, 0]
                ScriptEntry::Opcode(OP::PushOutIf), // one last false check, 0 == 1 false, will not push out, stack: [out, out, out]
                ScriptEntry::Opcode(OP::Drop),      // drop original arguments
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_out_if_values_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x04), // stack: [out, out, out, 0, 1, 2, 3, 4]
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments, stack: [out, out, out, 0, 1, 2, 3, 4, out, out, out]
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Roll), // start rolling the values to the top
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOutIfEq), // 0 == 3 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOutIfEq), // 1 == 3 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOutIfEq), // 2 == 3 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOutIfEq), // 3 == 3 true, will push out, stack: [out, out, out, 4]
                ScriptEntry::Opcode(OP::Unsigned8Var), // add one last false check
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::PushOutIfEq), // 10 == 4 false, will not push out, stack: [out, out, out]
                ScriptEntry::Opcode(OP::Drop),        // drop original arguments
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_out_if_values_not_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00), // stack: [out, out, out, 0, 0, 0, 10, 0]
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments, stack: [out, out, out, 0, 0, 0, 10, 0, out, out, out]
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Roll), // start rolling the values to the top
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfNeq), // 0 != 0 false, continue
                ScriptEntry::Opcode(OP::Roll),         // roll the next value to the top
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfNeq), // 0 != 0 false, continue
                ScriptEntry::Opcode(OP::Roll),         // roll the next value to the top
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfNeq), // 0 != 0 false, continue
                ScriptEntry::Opcode(OP::Roll),         // roll the next value to the top
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::PushOutIfNeq), // 10 != 11 true, will push out, stack: [out, out, out, 0]
                ScriptEntry::Opcode(OP::Unsigned8Var), // add one last false check
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfNeq), // 0 != 0 false, will not push out, stack: [out, out, out]
                ScriptEntry::Opcode(OP::Drop),         // drop original arguments
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_out_if_value_is_less() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01), // stack: [out, out, out, 1, 1, 1, 1, 1]
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments, stack: [out, out, out, 1, 1, 1, 1, 1, out, out, out]
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Roll), // start rolling the values to the top
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::PushOutIfLt), // 1 < 1 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PushOutIfLt), // 2 < 1 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Opcode(OP::PushOutIfLt), // 3 < 1 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfLt), // 0 < 1 true, will push out, stack: [out, out, out, 1]
                ScriptEntry::Opcode(OP::Unsigned8Var), // add one last false check
                ScriptEntry::Byte(0x0a),
                ScriptEntry::Opcode(OP::PushOutIfLt), // 10 < 1 false, will not push out, stack: [out, out, out]
                ScriptEntry::Opcode(OP::Drop),        // drop original arguments
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_out_if_value_is_greater() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01), // stack: [out, out, out, 1, 1, 1, 1, 1]
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments, stack: [out, out, out, 1, 1, 1, 1, 1, out, out, out]
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Roll), // start rolling the values to the top
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfGt), // 0 > 1 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfGt), // 0 > 1 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x05),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::PushOutIfGt), // 1 > 1 false, continue
                ScriptEntry::Opcode(OP::Roll),        // roll the next value to the top
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PushOutIfGt), // 2 > 1 true, will push out, stack: [out, out, out, 1]
                ScriptEntry::Opcode(OP::Unsigned8Var), // add one last false check
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::PushOutIfGt), // 1 > 1 false, will not push out, stack: [out, out, out]
                ScriptEntry::Opcode(OP::Drop),        // drop original arguments
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 30, vec![], 0, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_out_if_value_is_less_or_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01), // stack: [out, out, out, 1, 1, 1, 1, 1]
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments, stack: [out, out, out, 1, 1, 1, 1, 1, out, out, out]
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Roll), // start rolling the values to the top
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PushOutIfLeq), // 2 <= 1 false, continue
                ScriptEntry::Opcode(OP::Roll),         // roll the next value to the top
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PushOutIfLeq), // 2 <= 1 false, continue
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments because we will push out, stack: [out, out, out, 1, 1, 1, out, out, out, out, out, out]
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Roll), // roll the next value to the top
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfLeq), // 0 <= 1 true, will push out, stack: [out, out, out, 1, 1, out, out, out]
                ScriptEntry::Opcode(OP::Roll),         // roll the next value to the top
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::PushOutIfLeq), // 1 <= 1 true, will push out, stack: [out, out, out, 1]
                ScriptEntry::Opcode(OP::Unsigned8Var), // add one last false check
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PushOutIfLeq), // 2 <= 1 false, will not push out, stack: [out, out, out]
                ScriptEntry::Opcode(OP::Drop),         // drop original arguments
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 60, vec![], 1, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_pushes_out_if_value_is_greater_or_equal() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01), // stack: [out, out, out, 1, 1, 1, 1, 1]
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments, stack: [out, out, out, 1, 1, 1, 1, 1, out, out, out]
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Roll), // start rolling the values to the top
                ScriptEntry::Byte(0x07),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfGeq), // 0 >= 1 false, continue
                ScriptEntry::Opcode(OP::Roll),         // roll the next value to the top
                ScriptEntry::Byte(0x06),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfGeq), // 0 >= 1 false, continue
                ScriptEntry::Opcode(OP::Pick), // duplicate the 3 arguments because we will push out, stack: [out, out, out, 1, 1, 1, out, out, out, out, out, out]
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Pick),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Roll), // roll the next value to the top
                ScriptEntry::Byte(0x08),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::PushOutIfGeq), // 1 >= 1 true, will push out, stack: [out, out, out, 1, 1, out, out, out]
                ScriptEntry::Opcode(OP::Roll),         // roll the next value to the top
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::PushOutIfGeq), // 2 >= 1 true, will push out, stack: [out, out, out, 1]
                ScriptEntry::Opcode(OP::Unsigned8Var), // add one last false check
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PushOutIfGeq), // 0 >= 1 false, will not push out, stack: [out, out, out]
                ScriptEntry::Opcode(OP::Drop),         // drop original arguments
                ScriptEntry::Opcode(OP::Drop2),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };
        let base: TestBaseArgs = get_test_base_args(&mut ss, 60, vec![], 1, key);
        let mut idx_map = HashMap::new();
        let mut outs = vec![];
        let mut verif_stack = VerificationStack::new();

        assert_eq!(
            ss.execute(
                &base.args,
                &base.ins,
                &mut outs,
                &mut idx_map,
                &mut verif_stack,
                [0; 32],
                key,
                "",
                VmFlags::default()
            ),
            Ok(ExecutionResult::OkVerify).into()
        );
        assert_eq!(outs, base.out);
    }

    #[test]
    fn it_bool_ands() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BoolAnd),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::BoolAnd),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::BoolAnd),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::BoolAnd),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::BoolAnd),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x01),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_bool_ors() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xe2),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0xf3),
                ScriptEntry::Opcode(OP::BoolOr),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::BoolOr),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::BoolOr),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::BoolOr),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::BoolOr),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x00),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x01),
            VmTerm::Unsigned8(0x01),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if() {
        /*
        m = 0, n = 1
        if n == 1 {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 2 = 2
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::If),           // true
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x02)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_not() {
        /*
        m = 0, n = 0
        if n != 1 {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 2 = 2
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Ifn),          // true
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x02)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_else() {
        /*
        m = 0, n = 0
        if n == 1 {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 4 = 4
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::If),           // false
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x04)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_less() {
        /*
        m = 0, n = 1, o = 0
        if o < n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 2 = 2
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::IfLt),         // true
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x02)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_less_test_2() {
        /*
        m = 0, n = 0, o = 1
        if o < n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 4 = 4
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::IfLt),         // false
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x04)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_greater() {
        /*
        m = 0, n = 0, o = 1
        if o > n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 2 = 2
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::IfGt),         // true
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x02)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_greater_test_2() {
        /*
        m = 0, n = 1, o = 0
        if o > n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 4 = 4
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::IfGt),         // false
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x04)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_less_or_equal() {
        /*
        m = 0, n = 1, o = 1
        if o <= n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 2 = 2
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::IfLeq),        // true
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x02)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_less_or_equal_test_2() {
        /*
        m = 0, n = 0, o = 1
        if o <= n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 4 = 4
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::IfLeq),        // false
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x04)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_greater_or_equal() {
        /*
        m = 0, n = 0, o = 0
        if o >= n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 2 = 2
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::IfGeq),        // true
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x02)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_greater_or_equal_test_2() {
        /*
        m = 0, n = 1, o = 0
        if o >= n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 4 = 4
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::IfGeq),        // false
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x04)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_equals() {
        /*
        m = 0, n = 0, o = 0
        if o == n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 2 = 2
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::IfEq),         // true
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x02)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_equals_test_2() {
        /*
        m = 0, n = 1, o = 0
        if o == n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 4 = 4
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::IfEq),         // false
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x04)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_not_equals() {
        /*
        m = 0, n = 0, o = 1
        if o != n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 2 = 2
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::IfNeq),        // true
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x02)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_simple_if_not_equals_test_2() {
        /*
        m = 0, n = 1, o = 1
        if o != n {
            m += 2
        } else {
            m += 4
        }
        print m -> 0 + 4 = 4
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // m = 0
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::Unsigned8Var), // n = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::Unsigned8Var), // o = 1
                ScriptEntry::Byte(0x01),
                ScriptEntry::Opcode(OP::IfNeq),        // false
                ScriptEntry::Opcode(OP::Unsigned8Var), // 2
                ScriptEntry::Byte(0x02),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::Else),
                ScriptEntry::Opcode(OP::Unsigned8Var), // 4
                ScriptEntry::Byte(0x04),
                ScriptEntry::Opcode(OP::Add),
                ScriptEntry::Opcode(OP::End),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x04)];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_complex_if_equals() {
        /*
        m = 1, n = 1, o = 1

        if o == n {
            for i = 1...5 {
                if i != 2 {
                    m *= i
                }

                if i == 3 {
                    m *= (i + 1)
                }
            }
        } else {
            if m == 1 {
                m = 10
            }
        }

        print m -> 240
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 0 => // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // 1 => // m = 1
                ScriptEntry::Byte(0x01), // 2
                ScriptEntry::Opcode(OP::Unsigned8Var), // 3 => // n = 1
                ScriptEntry::Byte(0x01), // 4
                ScriptEntry::Opcode(OP::Unsigned8Var), // 5 => // o = 1
                ScriptEntry::Byte(0x01), // 6
                ScriptEntry::Opcode(OP::IfEq), // 7 => // if o == n, true, stack [m]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 8 => // i = 1, stack [m, i]
                ScriptEntry::Byte(0x01), // 9
                ScriptEntry::Opcode(OP::Loop), // 10 => // for i = 1...5
                ScriptEntry::Opcode(OP::Dup), // 11 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 12
                ScriptEntry::Byte(0x02), // 13 => // 2, for the first if inside loop, stack [m, i, i, 2]
                ScriptEntry::Opcode(OP::IfNeq), // 14 => // if i != 2, stack [m, i]
                ScriptEntry::Opcode(OP::Dup), // 15 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Roll), // 16
                ScriptEntry::Byte(0x02), // 17 => // stack [i, i, m]
                ScriptEntry::Opcode(OP::Mult), // 18 => // stack [i, m]
                ScriptEntry::Opcode(OP::Swap), // 19 => // stack [m, i]
                ScriptEntry::Opcode(OP::End), // 20 => // end if i != 2
                ScriptEntry::Opcode(OP::Dup), // 21 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 22
                ScriptEntry::Byte(0x03), // 23 => // 3, for the second if inside loop, stack [m, i, i, 3]
                ScriptEntry::Opcode(OP::IfEq), // 24 => // if i == 3, stack [m, i]
                ScriptEntry::Opcode(OP::Dup), // 25 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Add1), // 26 => // stack [m, i, i + 1]
                ScriptEntry::Opcode(OP::Roll), // 27
                ScriptEntry::Byte(0x02), // 28 => // stack [i, i+1, m]
                ScriptEntry::Opcode(OP::Mult), // 29 => // stack [i, m]
                ScriptEntry::Opcode(OP::Swap), // 30 => // stack [m, i]
                ScriptEntry::Opcode(OP::End), // 31 => // end if i == 3
                ScriptEntry::Opcode(OP::Dup), // 32 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 33
                ScriptEntry::Byte(0x05), // 34 => // 5, condition for loop to break
                ScriptEntry::Opcode(OP::BreakIfEq), // 35
                ScriptEntry::Opcode(OP::Add1), // 36 => // increment for loop counter with 1
                ScriptEntry::Opcode(OP::End), // 37 => // end for
                ScriptEntry::Opcode(OP::Else), // 38 => // else, stack [m]
                ScriptEntry::Opcode(OP::Dup), // 39 => // stack [m, m]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 40 => // i = 1, stack [m, m, 1]
                ScriptEntry::Byte(0x01), // 41
                ScriptEntry::Opcode(OP::IfEq), // 42 => // stack [m]
                ScriptEntry::Opcode(OP::Drop), // 43 => // stack []
                ScriptEntry::Opcode(OP::Unsigned8Var), // 44 => // 10, stack [10]
                ScriptEntry::Byte(0x0a), // 45
                ScriptEntry::Opcode(OP::End), // 46 => // end if m == 1
                ScriptEntry::Opcode(OP::End), // 47 => // end if o == n
                ScriptEntry::Opcode(OP::Drop),
                ScriptEntry::Opcode(OP::PopToScriptOuts), // 48
                ScriptEntry::Opcode(OP::PushOutVerify),   // 49
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0xf0)]; // m == 240
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_complex_if_else() {
        /*
        m = 1, n = 1, o = 0

        if o == n {
            for i = 1...5 {
                if i != 2 {
                    m *= i
                }

                if i == 3 {
                    m *= (i + 1)
                }
            }
        } else {
            if m == 1 {
                m = 10
            }
        }

        print m -> 10
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 0 => // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // 1 => // m = 1
                ScriptEntry::Byte(0x01), // 2
                ScriptEntry::Opcode(OP::Unsigned8Var), // 3 => // n = 1
                ScriptEntry::Byte(0x01), // 4
                ScriptEntry::Opcode(OP::Unsigned8Var), // 5 => // o = 0
                ScriptEntry::Byte(0x00), // 6
                ScriptEntry::Opcode(OP::IfEq), // 7 => // if o == n, true, stack [m]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 8 => // i = 1, stack [m, i]
                ScriptEntry::Byte(0x01), // 9
                ScriptEntry::Opcode(OP::Loop), // 10 => // for i = 1...5
                ScriptEntry::Opcode(OP::Dup), // 11 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 12
                ScriptEntry::Byte(0x02), // 13 => // 2, for the first if inside loop, stack [m, i, i, 2]
                ScriptEntry::Opcode(OP::IfNeq), // 14 => // if i != 2, stack [m, i]
                ScriptEntry::Opcode(OP::Dup), // 15 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Roll), // 16
                ScriptEntry::Byte(0x02), // 17 => // stack [i, i, m]
                ScriptEntry::Opcode(OP::Mult), // 18 => // stack [i, m]
                ScriptEntry::Opcode(OP::Swap), // 19 => // stack [m, i]
                ScriptEntry::Opcode(OP::End), // 20 => // end if i != 2
                ScriptEntry::Opcode(OP::Dup), // 21 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 22
                ScriptEntry::Byte(0x03), // 23 => // 3, for the second if inside loop, stack [m, i, i, 3]
                ScriptEntry::Opcode(OP::IfEq), // 24 => // if i == 3, stack [m, i]
                ScriptEntry::Opcode(OP::Dup), // 25 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Add1), // 26 => // stack [m, i, i + 1]
                ScriptEntry::Opcode(OP::Roll), // 27
                ScriptEntry::Byte(0x02), // 28 => // stack [i, i+1, m]
                ScriptEntry::Opcode(OP::Mult), // 29 => // stack [i, m]
                ScriptEntry::Opcode(OP::Swap), // 30 => // stack [m, i]
                ScriptEntry::Opcode(OP::End), // 31 => // end if i == 3
                ScriptEntry::Opcode(OP::Dup), // 32 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 33
                ScriptEntry::Byte(0x05), // 34 => // 5, condition for loop to break
                ScriptEntry::Opcode(OP::BreakIfEq), // 35
                ScriptEntry::Opcode(OP::Add1), // 36 => // increment for loop counter with 1
                ScriptEntry::Opcode(OP::End), // 37 => // end for
                ScriptEntry::Opcode(OP::Else), // 38 => // else, stack [m]
                ScriptEntry::Opcode(OP::Dup), // 39 => // stack [m, m]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 40 => // i = 1, stack [m, m, 1]
                ScriptEntry::Byte(0x01), // 41
                ScriptEntry::Opcode(OP::IfEq), // 42 => // stack [m]
                ScriptEntry::Opcode(OP::Drop), // 43 => // stack []
                ScriptEntry::Opcode(OP::Unsigned8Var), // 44 => // 10, stack [10]
                ScriptEntry::Byte(0x0a), // 45
                ScriptEntry::Opcode(OP::End), // 46 => // end if m == 1
                ScriptEntry::Opcode(OP::End), // 47 => // end if o == n
                ScriptEntry::Opcode(OP::PopToScriptOuts), // 48
                ScriptEntry::Opcode(OP::PushOut), // 49
                ScriptEntry::Opcode(OP::Verify), // 50
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x0a)]; // m == 10
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn control_operator_complex_if_else_test_2() {
        /*
        m = 1, n = 1, o = 0

        if o == n {
            for i = 1...5 {
                if i != 2 {
                    m *= i
                }

                if i == 3 {
                    m *= (i + 1)
                }
            }
        } else {
            if m == 2 {
                m = 10
            } else {
                m = 20
            }
        }

        print m -> 20
        */
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 0 => // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::Unsigned8Var), // 1 => // m = 1
                ScriptEntry::Byte(0x01), // 2
                ScriptEntry::Opcode(OP::Unsigned8Var), // 3 => // n = 1
                ScriptEntry::Byte(0x01), // 4
                ScriptEntry::Opcode(OP::Unsigned8Var), // 5 => // o = 0
                ScriptEntry::Byte(0x00), // 6
                ScriptEntry::Opcode(OP::IfEq), // 7 => // if o == n, true, stack [m]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 8 => // i = 1, stack [m, i]
                ScriptEntry::Byte(0x01), // 9
                ScriptEntry::Opcode(OP::Loop), // 10 => // for i = 1...5
                ScriptEntry::Opcode(OP::Dup), // 11 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 12
                ScriptEntry::Byte(0x02), // 13 => // 2, for the first if inside loop, stack [m, i, i, 2]
                ScriptEntry::Opcode(OP::IfNeq), // 14 => // if i != 2, stack [m, i]
                ScriptEntry::Opcode(OP::Dup), // 15 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Roll), // 16
                ScriptEntry::Byte(0x02), // 17 => // stack [i, i, m]
                ScriptEntry::Opcode(OP::Mult), // 18 => // stack [i, m]
                ScriptEntry::Opcode(OP::Swap), // 19 => // stack [m, i]
                ScriptEntry::Opcode(OP::End), // 20 => // end if i != 2
                ScriptEntry::Opcode(OP::Dup), // 21 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 22
                ScriptEntry::Byte(0x03), // 23 => // 3, for the second if inside loop, stack [m, i, i, 3]
                ScriptEntry::Opcode(OP::IfEq), // 24 => // if i == 3, stack [m, i]
                ScriptEntry::Opcode(OP::Dup), // 25 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Add1), // 26 => // stack [m, i, i + 1]
                ScriptEntry::Opcode(OP::Roll), // 27
                ScriptEntry::Byte(0x02), // 28 => // stack [i, i+1, m]
                ScriptEntry::Opcode(OP::Mult), // 29 => // stack [i, m]
                ScriptEntry::Opcode(OP::Swap), // 30 => // stack [m, i]
                ScriptEntry::Opcode(OP::End), // 31 => // end if i == 3
                ScriptEntry::Opcode(OP::Dup), // 32 => // stack [m, i, i]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 33
                ScriptEntry::Byte(0x05), // 34 => // 5, condition for loop to break
                ScriptEntry::Opcode(OP::BreakIfEq), // 35
                ScriptEntry::Opcode(OP::Add1), // 36 => // increment for loop counter with 1
                ScriptEntry::Opcode(OP::End), // 37 => // end for
                ScriptEntry::Opcode(OP::Else), // 38 => // else, stack [m]
                ScriptEntry::Opcode(OP::Dup), // 39 => // stack [m, m]
                ScriptEntry::Opcode(OP::Unsigned8Var), // 40 => // i = 1, stack [m, m, 1]
                ScriptEntry::Byte(0x02), // 41
                ScriptEntry::Opcode(OP::IfEq), // 42 => // stack [m]
                ScriptEntry::Opcode(OP::Drop), // 43 => // stack []
                ScriptEntry::Opcode(OP::Unsigned8Var), // 44 => // 10, stack [10]
                ScriptEntry::Byte(0x0a), // 45
                ScriptEntry::Opcode(OP::Else), // 46 => // else
                ScriptEntry::Opcode(OP::Drop), // 47 => // stack []
                ScriptEntry::Opcode(OP::Unsigned8Var), // 48 => // 20, stack [20]
                ScriptEntry::Byte(0x14), // 49
                ScriptEntry::Opcode(OP::End), // 50 => // end if m == 1
                ScriptEntry::Opcode(OP::End), // 51 => // end if o == n
                ScriptEntry::Opcode(OP::PopToScriptOuts), // 52
                ScriptEntry::Opcode(OP::PushOut), // 53
                ScriptEntry::Opcode(OP::Verify), // 54
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::Unsigned8(0x14)]; // m == 20
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_loads_unsigned_big_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::UnsignedBigVar),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0xdf),
                ScriptEntry::Byte(0x96),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0xed),
                ScriptEntry::Byte(0xd0),
                ScriptEntry::Byte(0x99),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x37),
                ScriptEntry::Byte(0x32),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> =
            vec![VmTerm::UnsignedBig(ubig!(13535335215315315311613663))];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_loads_unsigned_big_var_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::UnsignedBigVar),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0xdf),
                ScriptEntry::Byte(0x96),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0xed),
                ScriptEntry::Byte(0xd0),
                ScriptEntry::Byte(0x99),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x37),
                ScriptEntry::Byte(0x32),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::UnsignedBigVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0xcf),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::UnsignedBigVar),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::UnsignedBig(ubig!(13535335215315315311613663)),
            VmTerm::UnsignedBig(ubig!(3535)),
            VmTerm::UnsignedBig(ubig!(0)),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_loads_signed_big_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::SignedBigVar),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0f),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0xdf),
                ScriptEntry::Byte(0x96),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0xed),
                ScriptEntry::Byte(0xd0),
                ScriptEntry::Byte(0x99),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x37),
                ScriptEntry::Byte(0x32),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> =
            vec![VmTerm::SignedBig(ibig!(13535335215315315311613663))];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_loads_signed_big_var_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::SignedBigVar),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0f),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0xdf),
                ScriptEntry::Byte(0x96),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0xed),
                ScriptEntry::Byte(0xd0),
                ScriptEntry::Byte(0x99),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x37),
                ScriptEntry::Byte(0x32),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::UnsignedBigVar),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0f),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0xcf),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::UnsignedBigVar),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![
            VmTerm::SignedBig(ibig!(13535335215315315311613663)),
            VmTerm::SignedBig(ibig!(3535)),
            VmTerm::SignedBig(ibig!(0)),
        ];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_loads_unsigned_big_array_var() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::UnsignedBigArrayVar),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0xdf),
                ScriptEntry::Byte(0x96),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0xed),
                ScriptEntry::Byte(0xd0),
                ScriptEntry::Byte(0x99),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x37),
                ScriptEntry::Byte(0x32),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0xcf),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x08),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::UnsignedBigArray(vec![
            ubig!(13535335215315315311613663),
            ubig!(3535),
            ubig!(0),
        ])];
        assert_script_ok(ss, script_output, key);
    }

    #[test]
    fn it_loads_signed_big_array_var_2() {
        let key = "test_key";
        let mut ss = Script {
            script: vec![
                ScriptEntry::Byte(0x03), // 3 arguments are pushed onto the stack: out_amount, out_address, out_script_hash
                ScriptEntry::Opcode(OP::SignedBigArrayVar),
                ScriptEntry::Byte(0x03),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0f),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0xdf),
                ScriptEntry::Byte(0x96),
                ScriptEntry::Byte(0x15),
                ScriptEntry::Byte(0xed),
                ScriptEntry::Byte(0xd0),
                ScriptEntry::Byte(0x99),
                ScriptEntry::Byte(0x06),
                ScriptEntry::Byte(0xfe),
                ScriptEntry::Byte(0x37),
                ScriptEntry::Byte(0x32),
                ScriptEntry::Byte(0x0b),
                ScriptEntry::Byte(0x04),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x0f),
                ScriptEntry::Byte(0x02),
                ScriptEntry::Byte(0xcf),
                ScriptEntry::Byte(0x0d),
                ScriptEntry::Byte(0x01),
                ScriptEntry::Byte(0x00),
                ScriptEntry::Byte(0x10),
                ScriptEntry::Opcode(OP::PopToScriptOuts),
                ScriptEntry::Opcode(OP::PushOut),
                ScriptEntry::Opcode(OP::Verify),
            ],
            ..Script::default()
        };

        let mut script_output: Vec<VmTerm> = vec![VmTerm::SignedBigArray(vec![
            ibig!(13535335215315315311613663),
            ibig!(3535),
            ibig!(0),
        ])];
        assert_script_ok(ss, script_output, key);
    }
}
