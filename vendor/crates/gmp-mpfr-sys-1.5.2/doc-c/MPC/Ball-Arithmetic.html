<div class="chapter" id="Ball-Arithmetic">
<div class="header">
<p>
Next: <a href="constant.References.html#start" accesskey="n" rel="next">References</a>, Previous: <a href="constant.Complex_Functions.html#Complex-Functions" accesskey="p" rel="prev">Complex Functions</a>, Up: <a href="index.html#start" accesskey="u" rel="up">GNU MPC</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Ball-Arithmetic-1"></span><h2 class="chapter">6 Ball Arithmetic</h2>
<span id="index-Ball-arithmetic"></span>
<p>Since release 1.3.0, GNU MPC contains a simple and very limited
implementation of complex balls (or rather, circles). This part is
experimental, its interface may vary and it may be removed completely
in future releases.
</p>
<span id="index-mpcb_005ft"></span>
<p>A complex ball of the new type <code>mpcb_t</code> is defined by a non-zero centre
<em class='math'>c</em> of the type <code>mpc_t</code> and a relative radius <em class='math'>r</em> of
the new type <code>mpcr_t</code>, and it represents all complex numbers
<em class='math'>z = c (1 + ϑ)</em> with <em class='math'>|ϑ| ≤ r</em>, or equivalently
the closed circle with centre <em class='math'>c</em> and radius <em class='math'>r |c|</em>.
The approach of using a relative error (or radius) instead of an absolute
one simplifies error analyses for multiplicative operations (multiplication,
division, square roots, and the AGM), at the expense of making them more
complicated for additive operations. It has the major drawback of not being
able to represent balls centred at 0; in floating point arithmetic, however,
0 is never reached by rounding, but only through operations with exact
result, which could be handled at a higher, application level. For more
discussion on these issues, see the file <code>algorithms.tex</code>.
</p>
<ul class="section-toc">
<li><a href="#Radius-type-and-functions" accesskey="1">Radius type and functions</a></li>
<li><a href="#Ball-type-and-functions" accesskey="2">Ball type and functions</a></li>
</ul>
<div class="section" id="Radius-type-and-functions">
<h3 class="section">6.1 Radius type and functions</h3>
<span id="index-mpcr_005ft"></span>
<span id="index-mpcr_005fptr"></span>
<span id="index-mpcr_005fsrcptr"></span>
<p>The radius type is defined by
</p><pre class="verbatim">struct {
   int64_t mant;
   int64_t exp;
}
</pre><p>with the usual trick in the GNU multiprecision libraries of defining the
main type <code>mpcr_t</code> as a 1-dimensional array of this struct, and
variable and constant pointers <code>mpcr_ptr</code> and <code>mpcr_srcptr</code>.
It can contain the special values infinity or zero, or floating point
numbers encoded as <em class='math'>m⋅2<sup>e</sup></em> for a positive mantissa
<em class='math'>m</em> and an arbitrary (usually negative) exponent <em class='math'>e</em>.
Normalised finite radii use 31 bits for the mantissa, that is,
<em class='math'>2<sup>30</sup>≤m≤2<sup>31</sup> - 1</em>.
The special values infinity and 0 are encoded through the sign of
<em class='math'>m</em>, but should be tested for and set using dedicated functions.
</p>
<p>Unless indicated otherwise, the following functions
assume radius arguments to be normalised,
they return normalised results, and they round their results up, not
necessarily to the smallest representable number, although reasonable
effort is made to get a tight upper bound: They only guarantee that
their outputs are an upper bound on the true results.
(There may be a trade-off between tightness of the result and speed of
computation. For instance, when a 32-bit mantissa is normalised, an even
mantissa should be divided by 2, an odd mantissa should be divided by 2
and 1 should be added, and then in both cases the exponent must be
increased by 1. It might be more efficient to add 1 all the time instead
of testing the last bit of the mantissa.)
</p>
<dl class="def">
<dt id="index-mpcr_005finf_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpcr_inf_p</strong> <em>(mpcr_srcptr <var>r</var>)</em><a href='#index-mpcr_005finf_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fzero_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpcr_zero_p</strong> <em>(mpcr_srcptr <var>r</var>)</em><a href='#index-mpcr_005fzero_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Test whether <var>r</var> is infinity or zero, respectively, and return a
boolean.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005flt_005fhalf_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpcr_lt_half_p</strong> <em>(mpcr_srcptr <var>r</var>)</em><a href='#index-mpcr_005flt_005fhalf_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return <code>true</code> if <var>r</var>&lt;1/2, and <code>false</code> otherwise.
(Everywhere in this document,
<code>true</code> means any non-zero value, and <code>false</code> means zero.)
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fcmp"><span class="category">Function: </span><span><em>int</em> <strong>mpcr_cmp</strong> <em>(mpcr_srcptr <var>r</var>, mpcr_srcptr <var>s</var>)</em><a href='#index-mpcr_005fcmp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return +1, 0 or -1 depending on whether <var>r</var> is larger than, equal to
or less than <var>s</var>, with the natural total order on the compactified
non-negative real axis letting 0 be smaller and letting infinity be larger
than any finite real number.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fset_005finf"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_set_inf</strong> <em>(mpcr_ptr <var>r</var>)</em><a href='#index-mpcr_005fset_005finf' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fset_005fzero"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_set_zero</strong> <em>(mpcr_ptr <var>r</var>)</em><a href='#index-mpcr_005fset_005fzero' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fset_005fone"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_set_one</strong> <em>(mpcr_ptr <var>r</var>)</em><a href='#index-mpcr_005fset_005fone' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fset"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_set</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>)</em><a href='#index-mpcr_005fset' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fset_005fui64_005f2si64"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_set_ui64_2si64</strong> <em>(mpcr_ptr <var>r</var>, uint64_t <var>mant</var>, int64_t <var>exp</var>)</em><a href='#index-mpcr_005fset_005fui64_005f2si64' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>r</var> to infinity, zero, 1, <var>s</var> or
<var>mant</var>⋅2<sup><var>exp</var></sup>, respectively.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fmax"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_max</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>, mpcr_srcptr <var>t</var>)</em><a href='#index-mpcr_005fmax' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>r</var> to the maximum of <var>s</var> and <var>t</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fget_005fexp"><span class="category">Function: </span><span><em>int64_t</em> <strong>mpcr_get_exp</strong> <em>(mpcr_srcptr <var>r</var>)</em><a href='#index-mpcr_005fget_005fexp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Assuming that <var>r</var> is neither infinity nor 0, return its exponent
<em class='math'>e</em> when writing <em class='math'>r = m⋅2<sup>e</sup></em> with
<em class='math'>1/2 ≤ m &lt; 1</em>. (Notice that this is <em>not</em> the same as the
field <code>exp</code> in the struct representing a radius, but that instead it
is independent of the implementation.)
Otherwise the behaviour is undefined.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fout_005fstr"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_out_str</strong> <em>(FILE *<var>f</var>, mpcr_srcptr <var>r</var>)</em><a href='#index-mpcr_005fout_005fstr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Output <var>r</var> on <var>f</var>, which may be <code>stdout</code>.
Caveat: This function so far serves mainly for debugging purposes, its
behaviour will probably change in the future.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fadd"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_add</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>, mpcr_srcptr <var>t</var>)</em><a href='#index-mpcr_005fadd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fsub"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_sub</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>, mpcr_srcptr <var>t</var>)</em><a href='#index-mpcr_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fmul"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_mul</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>, mpcr_srcptr <var>t</var>)</em><a href='#index-mpcr_005fmul' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fdiv"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_div</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>, mpcr_srcptr <var>t</var>)</em><a href='#index-mpcr_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fmul_005f2ui"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_mul_2ui</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>, unsigned long int <var>t</var>)</em><a href='#index-mpcr_005fmul_005f2ui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fdiv_005f2ui"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_div_2ui</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>, unsigned long int <var>t</var>)</em><a href='#index-mpcr_005fdiv_005f2ui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fsqr"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_sqr</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>)</em><a href='#index-mpcr_005fsqr' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcr_005fsqrt"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_sqrt</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>)</em><a href='#index-mpcr_005fsqrt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>r</var> to the sum, difference, product or quotient of <var>s</var> and
<var>t</var>, or to the product of <var>s</var> by 2<sup><var>t</var></sup> or to the
quotient of <var>s</var> by 2<sup><var>t</var></sup>,
or to the square or the square root of <var>s</var>.
If any of the arguments is infinity, or if a difference is negative,
the result is infinity.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fsub_005frnd"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_sub_rnd</strong> <em>(mpcr_ptr <var>r</var>, mpcr_srcptr <var>s</var>, mpcr_srcptr <var>t</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpcr_005fsub_005frnd' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>r</var> to the difference of <var>s</var> and <var>t</var>, rounded into
direction <var>rnd</var>, which can be one of <code>MPFR_RNDU</code> or
<code>MPFR_RNDD</code>. If one of the arguments is infinity or the difference is
negative, the result is infinity. Calling the function with <code>MPFR_RNDU</code>
is equivalent to calling <code>mpcr_sub</code>.
</p>
<p>This is one out of several functions taking a rounding parameter. Rounding
down may be useful to obtain an upper bound when dividing by the result.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fc_005fabs_005frnd"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_c_abs_rnd</strong> <em>(mpcr_ptr <var>r</var>, mpc_srcptr <var>z</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpcr_005fc_005fabs_005frnd' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>r</var> to the absolute value of the complex number <var>z</var>, rounded
in direction <var>rnd</var>, which may be one of <code>MPFR_RNDU</code> or
<code>MPFR_RNDD</code>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcr_005fadd_005frounding_005ferror"><span class="category">Function: </span><span><em>void</em> <strong>mpcr_add_rounding_error</strong> <em>(mpcr_ptr <var>r</var>, mpfr_prec_t <var>p</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpcr_005fadd_005frounding_005ferror' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>r</var> to <em class='math'>r + (1 + r) 2<sup>-p</sup></em> if <var>rnd</var> equals
<code>MPFR_RNDN</code>, and to <em class='math'>r + (1 + r) 2<sup>1-p</sup></em> otherwise.
The idea is that if a (potentially not representable) centre of an ideal
complex ball of radius <var>r</var> is rounded to a representable complex
number at precision <var>p</var>, this shifts the centre by up to 1/2 ulp
(for rounding to nearest) or 1 ulp (for directed rounding of at least one
of the real or imaginary parts), which increases the radius accordingly.
So this function is typically called internally at the end of each
operation with complex balls to account for the error made by rounding
the centre.
</p></dd></dl>
</div>
<div class="section" id="Ball-type-and-functions">
<h3 class="section">6.2 Ball type and functions</h3>
<span id="index-mpcb_005ft-1"></span>
<span id="index-mpcb_005fptr"></span>
<span id="index-mpcb_005fsrcptr"></span>
<p>The ball type is defined by
</p><pre class="verbatim">typedef struct {
  mpc_t  c;
  mpcr_t r;
}
</pre><p>or, more precisely, <code>mpcb_t</code> is again a 1-dimensional array of such
a struct, and variable and constant pointer types are defined as
<code>mpcb_ptr</code> and <code>mpcb_srcptr</code>, respectively.
As usual, the components should only be accessed through corresponding
functions.
</p>
<p>To understand functions on balls, one needs to consider the balls passed
as arguments as sets of complex values, to which a mathematical function
is applied; the C function &ldquo;rounds up&rdquo; in the sense that it returns a
ball containing all possible values of the function in all the possible
input values. Reasonable effort is made to return small balls, but again
there is no guarantee that the result is the smallest possible one.
In the current implementation, the centre of a ball returned as a value
is obtained by applying the function to the centres of the balls passed
as arguments, and rounding. While this is a natural approach, it is not
the only possible one; however, it also simplifies the error analysis
as already carried out for functions with regular complex arguments.
Whenever the centre of a complex ball has a non-finite real or imaginary
part (positive or negative infinity or NaN) the radius is set to infinity;
this can be interpreted as the &ldquo;useless ball&rdquo;, representing the whole
complex plane, whatever the value of the centre is.
</p>
<p>Unlike for variables of <code>mpc_t</code> type, where the precision needs to
be set explicitly at initialisation, variables of type <code>mpcb_t</code>
handle their precision dynamically. Ball centres always have the same
precision for their real and their imaginary parts (again this is a
choice of the implementation; if they are of very different sizes, one
could theoretically reduce the precision of the part that is smaller
in absolute value, which is more strongly affected by the common error
coded in the radius).
When setting a complex ball from a value of a different type, an
additional precision parameter is passed, which determines the precision
of the centre. Functions on complex balls set the precision of their
result depending on the input. In the current implementation, this is the
minimum of the argument precisions, so if all balls are initially set to
the same precision, this is preserved throughout the computations.
(Notice that the exponent of the radius encodes roughly the number of
correct binary digits of the ball centre; so it would also make sense
to reduce the precision if the radius becomes larger.)
</p>
<p>The following functions on complex balls are currently available; the
eclectic collection is motivated by the desire to provide an implementation
of the arithmetic-geometric mean of complex numbers through the use of
ball arithmetic. As for functions taking complex arguments, there may
be arbitrary overlaps between variables representing arguments and
results; for instance
<code>mpcb_mul (z, z, z)</code> is an allowed way of replacing the ball <var>z</var>
by its square.
</p>
<dl class="def">
<dt id="index-mpcb_005finit"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_init</strong> <em>(mpcb_ptr <var>z</var>)</em><a href='#index-mpcb_005finit' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcb_005fclear"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_clear</strong> <em>(mpcb_ptr <var>z</var>)</em><a href='#index-mpcb_005fclear' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Initialise or free memory for <var>z</var>; <code>mpcb_init</code> must be called once
before using a variable, and <code>mpcb_clear</code> must be called once before
stopping to use a variable. Unlike its <code>mpc_t</code> counterpart,
<code>mpcb_init</code> does not fix the precision of <var>z</var>, but it sets its
radius to infinity, so that <var>z</var> represents the whole complex plane.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcb_005fget_005fprec"><span class="category">Function: </span><span><em>mpfr_prec_t</em> <strong>mpcb_get_prec</strong> <em>(mpcb_srcptr <var>z</var>)</em><a href='#index-mpcb_005fget_005fprec' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the (common) precision of the real and the complex parts of the
centre of <var>z</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcb_005fset"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_set</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>)</em><a href='#index-mpcb_005fset' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>z</var> to <var>z1</var>, preserving the precision of the centre.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcb_005fset_005finf"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_set_inf</strong> <em>(mpcb_ptr <var>z</var>)</em><a href='#index-mpcb_005fset_005finf' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>z</var> to the whole complex plane. This is intended to be used much
in the spirit of an assertion: When a precondition is not satisfied inside
a function, it can set its result to this value, which will propagate
through further computations.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcb_005fset_005fc"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_set_c</strong> <em>(mpcb_ptr <var>z</var>, mpc_srcptr <var>c</var>, mpfr_prec_t <var>prec</var>, unsigned long int <var>err_re</var>, unsigned long int <var>err_im</var>)</em><a href='#index-mpcb_005fset_005fc' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>z</var> to a ball with centre <var>c</var> at precision <var>prec</var>.
If <var>prec</var> is at least the maximum of the precisions of the real and the
imaginary parts of <var>c</var> and <var>err_re</var> and <var>err_im</var> are 0, then
the resulting ball is exact with radius zero. Using a larger value for
<var>prec</var> makes sense if <var>c</var> is considered exact and a larger target
precision for the result is desired, or some leeway for the working
precision is to be taken into account.
If <var>prec</var> is less than the precision of <var>c</var>, then usually some
rounding error occurs when setting the centre, which is taken into account
in the radius.
</p>
<p>If <var>err_re</var> and <var>err_im</var> are non-zero, the argument <var>c</var> is
considered as an inexact complex number, with a bound on the absolute error
of its real part given in <var>err_re</var> as a multiple of 1/2 ulp of the real
part of <var>c</var>, and a bound on the absolute error of its imaginary part
given in <var>err_im</var> as a multiple of 1/2 ulp of the imaginary part of
<var>c</var>. (Notice that if the parts of <var>c</var> have different precisions or
exponents, the absolute values of their ulp differ.)
Then <var>z</var> is created as a ball with centre <var>c</var> and a radius taking
these errors on <var>c</var> as well as the potential additional rounding error
for the centre into account.
If the real part of <var>c</var> is 0, then <var>err_re</var> must be 0, since
ulp of 0 makes no sense; otherwise the radius is set to infinity. The same
remark holds for the imaginary part.
</p>
<p>Using <var>err_re</var> and <var>err_im</var> different from 0 is particularly
useful in two settings: If <var>c</var> is itself the result of a call to an
<code>mpc_</code> function with exact input and rounding mode <code>MPC_RNDNN</code>
of both parts to nearest, then its parts are known with errors of at most
1/2 ulp, and setting <var>err_re</var> and <var>err_im</var> to 1 yields a ball
which is known to contain the exact result (this motivates the strange
unit of 1/2 ulp); if directed rounding was used, <var>err_re</var> and
<var>err_im</var> can be set to 2 instead.
</p>
<p>And if <var>c</var> is the result of a sequence of calls to <code>mpc_</code>
functions for which some error analysis has been carried out (as is
frequently the case internally when implementing complex functions),
again the resulting ball <var>z</var> is known to contain the exact result
when using appropriate values for <var>err_re</var> and <var>err_im</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcb_005fset_005fui_005fui"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_set_ui_ui</strong> <em>(mpcb_ptr <var>z</var>, unsigned long int <var>re</var>, unsigned long int <var>im</var>, mpfr_prec_t <var>prec</var>)</em><a href='#index-mpcb_005fset_005fui_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>z</var> to a ball with centre <var>re</var>+I*<var>im</var> at precision
<var>prec</var> or the size of an <code>unsigned long int</code>, whatever is larger.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcb_005fneg"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_neg</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>)</em><a href='#index-mpcb_005fneg' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcb_005fadd"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_add</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>, mpcb_srcptr <var>z2</var>)</em><a href='#index-mpcb_005fadd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcb_005fmul"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_mul</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>, mpcb_srcptr <var>z2</var>)</em><a href='#index-mpcb_005fmul' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcb_005fsqr"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_sqr</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>)</em><a href='#index-mpcb_005fsqr' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcb_005fpow_005fui"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_pow_ui</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>, unsigned long int <var>e</var>)</em><a href='#index-mpcb_005fpow_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcb_005fsqrt"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_sqrt</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>)</em><a href='#index-mpcb_005fsqrt' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcb_005fdiv"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_div</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>, mpcb_srcptr <var>z2</var>)</em><a href='#index-mpcb_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpcb_005fdiv_005f2ui"><span class="category">Function: </span><span><em>void</em> <strong>mpcb_div_2ui</strong> <em>(mpcb_ptr <var>z</var>, mpcb_srcptr <var>z1</var>, unsigned long int <var>e</var>)</em><a href='#index-mpcb_005fdiv_005f2ui' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>These are the exact counterparts of the corresponding functions
<code>mpc_neg</code>, <code>mpc_add</code> and so on, but on complex balls instead of
complex numbers.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcb_005fcan_005fround"><span class="category">Function: </span><span><em>int</em> <strong>mpcb_can_round</strong> <em>(mpcb_srcptr <var>z</var>, mpfr_prec_t <var>prec_re</var>, mpfr_prec_t <var>prec_im</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpcb_005fcan_005fround' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>If the function returns <code>true</code> (a non-zero number), then rounding
any of the complex numbers in the ball to a complex number with precision
<var>prec_re</var> of its real and precision <var>prec_im</var> of its imaginary
part and rounding mode <var>rnd</var> yields the same result and rounding
direction value, cf. <a href="constant.GNU_MPC_Basics.html#return_002dvalue">return-value</a>.
If the function returns <code>false</code> (that is, 0), then it could not
conclude, or there are two numbers in the ball which would be rounded to
a different complex number or in a different direction. Notice that the
function works in a best effort mode and errs on the side of caution by
potentially returning <code>false</code> on a roundable ball; this is consistent
with computational functions not necessarily returning the smallest
enclosing ball.
</p>
<p>If <var>z</var> contains the result of evaluating some mathematical function
through a sequence of calls to <code>mpcb</code> functions, starting with exact
complex numbers, that is, balls of radius 0, then a return value of
<code>true</code> indicates that rounding any value in the ball (its centre is
readily available) in direction <var>rnd</var> yields the correct result of
the function and the correct rounding direction value with the usual
MPC semantics.
</p>
<p>Notice that when the precision of <var>z</var> is larger than <var>prec_re</var>
or <var>prec_im</var>, the centre need not be representable at the desired
precision, and in fact the ball need not contain a representable number
at all to be &ldquo;roundable&rdquo;. Even worse, when <var>rnd</var> is a directed
rounding mode for the real or the imaginary part and the ball of
non-zero radius contains
a representable number, the return value is necessarily <code>false</code>.
Even worse, when the rounding mode for one part is to nearest, the
corresponding part of the centre of the ball is representable and the ball
has a non-zero radius, then the return value is also necessarily
<code>false</code>, since even if rounding may be possible, the rounding
direction value cannot be determined.
</p></dd></dl>
<dl class="def">
<dt id="index-mpcb_005fround"><span class="category">Function: </span><span><em>int</em> <strong>mpcb_round</strong> <em>(mpc_ptr <var>c</var>, mpcb_srcptr <var>z</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpcb_005fround' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>c</var> to the centre of <var>z</var>, rounded in direction <var>rnd</var>,
and return the corresponding rounding direction value.
If <code>mpcb_can_round</code>, called with <var>z</var>, the precisions of <var>c</var>
and the rounding mode <var>rnd</var> returns <code>true</code>, then this function
does what is expected, it &ldquo;correctly rounds the ball&rdquo; and returns a
rounding direction value that is valid for all of the ball.
As explained above, the result is then not necessarily (in the presence of
directed rounding with radius different from 0, it is rather
necessarily not) an element of the ball.
</p></dd></dl>
</div>
</div>
<hr>
<div class="header">
<p>
Next: <a href="constant.References.html#start" accesskey="n" rel="next">References</a>, Previous: <a href="constant.Complex_Functions.html#Complex-Functions" accesskey="p" rel="prev">Complex Functions</a>, Up: <a href="index.html#start" accesskey="u" rel="up">GNU MPC</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
