<div class="chapter" id="Complex-Functions">
<div class="header">
<p>
Next: <a href="constant.Ball_Arithmetic.html#start" accesskey="n" rel="next">Ball Arithmetic</a>, Previous: <a href="constant.GNU_MPC_Basics.html#start" accesskey="p" rel="prev">GNU MPC Basics</a>, Up: <a href="index.html#start" accesskey="u" rel="up">GNU MPC</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Complex-Functions-1"></span><h2 class="chapter">5 Complex Functions</h2>
<span id="index-Complex-functions"></span>
<p>The complex functions expect arguments of type <code>mpc_t</code>.
</p>
<p>The GNU MPC floating-point functions have an interface that is similar to the
GNU MP
integer functions.  The function prefix for operations on complex numbers is
<code>mpc_</code>.
</p>
<span id="index-User_002ddefined-precision"></span>
<p>The precision of a computation is defined as follows: Compute the requested
operation exactly (with &ldquo;infinite precision&rdquo;), and round the result to
the destination variable precision with the given rounding mode.
</p>
<p>The GNU MPC complex functions are intended to be a smooth extension
of the IEEE P754 arithmetic. The results obtained on one
computer should not differ from the results obtained on a computer with a
different word size.
</p>
<ul class="section-toc">
<li><a href="#Initializing-Complex-Numbers" accesskey="1">Initialization Functions</a></li>
<li><a href="#Assigning-Complex-Numbers" accesskey="2">Assignment Functions</a></li>
<li><a href="#Converting-Complex-Numbers" accesskey="3">Conversion Functions</a></li>
<li><a href="#String-and-Stream-Input-and-Output" accesskey="4">String and Stream Input and Output</a></li>
<li><a href="#Complex-Comparison" accesskey="5">Comparison Functions</a></li>
<li><a href="#Projection-_0026-Decomposing" accesskey="6">Projection and Decomposing Functions</a></li>
<li><a href="#Basic-Arithmetic" accesskey="7">Basic Arithmetic Functions</a></li>
<li><a href="#Power-Functions-and-Logarithm" accesskey="8">Power Functions and Logarithm</a></li>
<li><a href="#Trigonometric-Functions" accesskey="9">Trigonometric Functions</a></li>
<li><a href="#Modular-Functions">Modular Functions</a></li>
<li><a href="#Miscellaneous-Complex-Functions">Miscellaneous Functions</a></li>
<li><a href="#Advanced-Functions">Advanced Functions</a></li>
<li><a href="#Internals">Internals</a></li>
</ul>
<hr>
<div class="section" id="Initializing-Complex-Numbers">
<div class="header">
<p>
Next: <a href="#Assigning-Complex-Numbers" accesskey="n" rel="next">Assignment Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Initialization-Functions"></span><h3 class="section">5.1 Initialization Functions</h3>
<p>An <code>mpc_t</code> object must be initialised before storing the first value in
it.  The functions <code>mpc_init2</code> and <code>mpc_init3</code>
are used for that purpose.
</p>
<dl class="def">
<dt id="index-mpc_005finit2"><span class="category">Function: </span><span><em>void</em> <strong>mpc_init2</strong> <em>(mpc_t <var>z</var>, mpfr_prec_t <var>prec</var>)</em><a href='#index-mpc_005finit2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Initialise <var>z</var> to precision <var>prec</var> bits
and set its real and imaginary parts to NaN.
Normally, a variable should be initialised once only
or at least be cleared, using <code>mpc_clear</code>, between initializations.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005finit3"><span class="category">Function: </span><span><em>void</em> <strong>mpc_init3</strong> <em>(mpc_t <var>z</var>, mpfr_prec_t <var>prec_r</var>, mpfr_prec_t <var>prec_i</var>)</em><a href='#index-mpc_005finit3' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Initialise <var>z</var> with the precision of its real part being
<var>prec_r</var> bits and the precision of its imaginary part being
<var>prec_i</var> bits, and set the real and imaginary parts to NaN.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fclear"><span class="category">Function: </span><span><em>void</em> <strong>mpc_clear</strong> <em>(mpc_t <var>z</var>)</em><a href='#index-mpc_005fclear' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Free the space occupied by <var>z</var>.  Make sure to call this function for all
<code>mpc_t</code> variables when you are done with them.
</p></dd></dl>
<p>Here is an example on how to initialise complex variables:
</p><div class="example">
<pre class="example">{
  mpc_t x, y;
  mpc_init2 (x, 256);		/* precision <em>exactly</em> 256 bits */
  mpc_init3 (y, 100, 50);	/* 100/50 bits for the real/imaginary part */
  &hellip;
  mpc_clear (x);
  mpc_clear (y);
}
</pre></div>
<p>The following function is useful for changing the precision during a
calculation.  A typical use would be for adjusting the precision gradually in
iterative algorithms like Newton-Raphson, making the computation precision
closely match the actual accurate part of the numbers.
</p>
<dl class="def">
<dt id="index-mpc_005fset_005fprec"><span class="category">Function: </span><span><em>void</em> <strong>mpc_set_prec</strong> <em>(mpc_t <var>x</var>, mpfr_prec_t <var>prec</var>)</em><a href='#index-mpc_005fset_005fprec' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Reset the precision of <var>x</var> to be <strong>exactly</strong> <var>prec</var> bits,
and set its real/imaginary parts to NaN.
The previous value stored in <var>x</var> is lost. It is equivalent to
a call to <code>mpc_clear(x)</code> followed by a call to
<code>mpc_init2(x, prec)</code>, but more efficient as no allocation is done in
case the current allocated space for the mantissa of <var>x</var> is sufficient.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fget_005fprec"><span class="category">Function: </span><span><em>mpfr_prec_t</em> <strong>mpc_get_prec</strong> <em>(const mpc_t <var>x</var>)</em><a href='#index-mpc_005fget_005fprec' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>If the real and imaginary part of <var>x</var> have the same precision, it is returned,
otherwise, 0 is returned.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fget_005fprec2"><span class="category">Function: </span><span><em>void</em> <strong>mpc_get_prec2</strong> <em>(mpfr_prec_t* <var>pr</var>, mpfr_prec_t* <var>pi</var>, const mpc_t <var>x</var>)</em><a href='#index-mpc_005fget_005fprec2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Returns the precision of the real part of <var>x</var> via <var>pr</var> and of its imaginary part
via <var>pi</var>.
</p></dd></dl>
<hr>
</div>
<div class="section" id="Assigning-Complex-Numbers">
<div class="header">
<p>
Next: <a href="#Converting-Complex-Numbers" accesskey="n" rel="next">Conversion Functions</a>, Previous: <a href="#Initializing-Complex-Numbers" accesskey="p" rel="prev">Initialization Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Assignment-Functions"></span><h3 class="section">5.2 Assignment Functions</h3>
<span id="index-Complex-assignment-functions"></span>
<p>These functions assign new values to already initialised complex numbers
(see <a href="#Initializing-Complex-Numbers">Initialization Functions</a>).
When using any functions with <code>intmax_t</code> or <code>uintmax_t</code>
parameters, you must include
<code>&lt;stdint.h&gt;</code> or <code>&lt;inttypes.h&gt;</code> <em>before</em> <samp>mpc.h</samp>, to allow
<samp>mpc.h</samp> to define prototypes for these functions.
Similarly, functions with parameters of type <code>complex</code> or
<code>long complex</code> are defined only if <code>&lt;complex.h&gt;</code> is included
<em>before</em> <samp>mpc.h</samp>.
If you need assignment functions that are not in the current API, you can
define them using the <code>MPC_SET_X_Y</code> macro (see <a href="#Advanced-Functions">Advanced Functions</a>).
</p>
<dl class="def">
<dt id="index-mpc_005fset"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set the value of <var>rop</var> from <var>op</var>, rounded to the precision of <var>rop</var>
with the given rounding mode <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fset_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_ui</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_si</strong> <em>(mpc_t <var>rop</var>, long int <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fuj"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_uj</strong> <em>(mpc_t <var>rop</var>, uintmax_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fuj' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fsj"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_sj</strong> <em>(mpc_t <var>rop</var>, intmax_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fsj' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fd"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_d</strong> <em>(mpc_t <var>rop</var>, double <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fld"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_ld</strong> <em>(mpc_t <var>rop</var>, long double <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fld' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fdc"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_dc</strong> <em>(mpc_t <var>rop</var>, double _Complex <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fdc' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fldc"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_ldc</strong> <em>(mpc_t <var>rop</var>, long double _Complex <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fldc' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_z</strong> <em>(mpc_t <var>rop</var>, const mpz_t <var>op</var> mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fq"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_q</strong> <em>(mpc_t <var>rop</var>, const mpq_t <var>op</var> mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fq' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005ff"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_f</strong> <em>(mpc_t <var>rop</var>, const mpf_t <var>op</var> mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005ff' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005ffr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_fr</strong> <em>(mpc_t <var>rop</var>, const mpfr_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005ffr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set the value of <var>rop</var> from <var>op</var>, rounded to the precision of
<var>rop</var> with the given rounding mode <var>rnd</var>.
The argument <var>op</var> is interpreted as real, so the imaginary part of
<var>rop</var> is set to zero with a positive sign.
Please note that even a <code>long int</code> may have to be rounded, if the
destination precision is less than the machine word width.
For <code>mpc_set_d</code>, be careful that the input number <var>op</var> may not be
exactly representable as a double-precision number (this happens for 0.1 for
instance), in which case it is first rounded by the C compiler to a
double-precision number, and then only to a complex number.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fset_005fui_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_ui_ui</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fui_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fsi_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_si_si</strong> <em>(mpc_t <var>rop</var>, long int <var>op1</var>, long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fsi_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fuj_005fuj"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_uj_uj</strong> <em>(mpc_t <var>rop</var>, uintmax_t <var>op1</var>, uintmax_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fuj_005fuj' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fsj_005fsj"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_sj_sj</strong> <em>(mpc_t <var>rop</var>, intmax_t <var>op1</var>, intmax_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fsj_005fsj' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fd_005fd"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_d_d</strong> <em>(mpc_t <var>rop</var>, double <var>op1</var>, double <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fd_005fd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fld_005fld"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_ld_ld</strong> <em>(mpc_t <var>rop</var>, long double <var>op1</var>, long double <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fld_005fld' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fz_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_z_z</strong> <em>(mpc_t <var>rop</var>, const mpz_t <var>op1</var>, const mpz_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fz_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005fq_005fq"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_q_q</strong> <em>(mpc_t <var>rop</var>, const mpq_t <var>op1</var>, const mpq_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005fq_005fq' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005ff_005ff"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_f_f</strong> <em>(mpc_t <var>rop</var>, const mpf_t <var>op1</var>, const mpf_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005ff_005ff' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fset_005ffr_005ffr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_fr_fr</strong> <em>(mpc_t <var>rop</var>, const mpfr_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fset_005ffr_005ffr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set the real part of <var>rop</var> from <var>op1</var>, and its imaginary part from
<var>op2</var>, according to the rounding mode <var>rnd</var>.
</p>
<p>Beware that the behaviour of <code>mpc_set_fr_fr</code> is undefined if <var>op1</var>
or <var>op2</var> is a pointer to the real or imaginary part of <var>rop</var>.
To exchange the real and the imaginary part of a complex number, either use
<code>mpfr_swap (mpc_realref (rop), mpc_imagref (rop))</code>, which also exchanges
the precisions of the two parts; or use a temporary variable.
</p></dd></dl>
<p>For functions assigning complex variables from strings or input streams,
see <a href="#String-and-Stream-Input-and-Output">String and Stream Input and Output</a>.
</p>
<dl class="def">
<dt id="index-mpc_005fset_005fnan"><span class="category">Function: </span><span><em>void</em> <strong>mpc_set_nan</strong> <em>(mpc_t <var>rop</var>)</em><a href='#index-mpc_005fset_005fnan' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to Nan+i*NaN.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fswap"><span class="category">Function: </span><span><em>void</em> <strong>mpc_swap</strong> <em>(mpc_t <var>op1</var>, mpc_t <var>op2</var>)</em><a href='#index-mpc_005fswap' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Swap the values of <var>op1</var> and <var>op2</var> efficiently. Warning: The
precisions are exchanged, too; in case these are different,
<code>mpc_swap</code> is thus not equivalent to three <code>mpc_set</code> calls using a
third auxiliary variable.
</p></dd></dl>
<hr>
</div>
<div class="section" id="Converting-Complex-Numbers">
<div class="header">
<p>
Next: <a href="#String-and-Stream-Input-and-Output" accesskey="n" rel="next">String and Stream Input and Output</a>, Previous: <a href="#Assigning-Complex-Numbers" accesskey="p" rel="prev">Assignment Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Conversion-Functions"></span><h3 class="section">5.3 Conversion Functions</h3>
<span id="index-Conversion-functions"></span>
<p>The following functions are available only if <code>&lt;complex.h&gt;</code>
is included <em>before</em> <samp>mpc.h</samp>.
</p>
<dl class="def">
<dt id="index-_005fComplex"><span class="category">Function: </span><span><em>double</em> <strong>_Complex</strong> <em>mpc_get_dc (const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-_005fComplex' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fget_005fldc"><span class="category">Function: </span><span><em>long double _Complex</em> <strong>mpc_get_ldc</strong> <em>(mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fget_005fldc' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>op</var> to a C complex number, using the rounding mode <var>rnd</var>.
</p></dd></dl>
<p>For functions converting complex variables to strings or stream output,
see <a href="#String-and-Stream-Input-and-Output">String and Stream Input and Output</a>.
</p>
<hr>
</div>
<div class="section" id="String-and-Stream-Input-and-Output">
<div class="header">
<p>
Next: <a href="#Complex-Comparison" accesskey="n" rel="next">Comparison Functions</a>, Previous: <a href="#Converting-Complex-Numbers" accesskey="p" rel="prev">Conversion Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="String-and-Stream-Input-and-Output-1"></span><h3 class="section">5.4 String and Stream Input and Output</h3>
<span id="index-String-and-stream-input-and-output"></span>
<dl class="def">
<dt id="index-mpc_005fstrtoc"><span class="category">Function: </span><span><em>int</em> <strong>mpc_strtoc</strong> <em>(mpc_t <var>rop</var>, const char *<var>nptr</var>, char **<var>endptr</var>, int <var>base</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fstrtoc' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Read a complex number from a string <var>nptr</var> in base <var>base</var>, rounded to
the precision of <var>rop</var> with the given rounding mode <var>rnd</var>.
The <var>base</var> must be either 0 or a number from 2 to 36 (otherwise the
behaviour is undefined).
If <var>nptr</var> starts with valid data, the result is stored in <var>rop</var>,
the usual inexact value is returned (see <a href="constant.GNU_MPC_Basics.html#return_002dvalue">Return
Value</a>) and, if <var>endptr</var> is not the null pointer,
<var>*endptr</var> points to the character just after the valid data.
Otherwise, <var>rop</var> is set to <code>NaN + i * NaN</code>, -1 is returned and,
if <var>endptr</var> is not the null pointer,
the value of <var>nptr</var> is stored in the location referenced by
<var>endptr</var>.
</p>
<p>The expected form of a complex number string is either a real number (an
optional leading whitespace, an optional sign followed by a floating-point
number), or a pair of real numbers in parentheses separated by whitespace. If
a real number is read, the missing imaginary part is set to +0.
The form of a floating-point number depends on the base and is described
in the documentation of <code>mpfr_strtofr</code>
in the GNU MPFR manual.
For instance, <code>&quot;3.1415926&quot;</code>, <code>&quot;(1.25e+7 +.17)&quot;</code>, <code>&quot;(@nan@
2)&quot;</code> and <code>&quot;(-0 -7)&quot;</code> are valid strings for <var>base</var> = 10.
If <var>base</var> = 0, then a prefix may be used to indicate the base in which the
floating-point number is written. Use prefix &rsquo;0b&rsquo; for binary numbers, prefix
&rsquo;0x&rsquo; for hexadecimal numbers, and no prefix for decimal numbers.
The real and imaginary part may then be written in different bases.
For instance, <code>&quot;(1.024e+3 +2.05e+3)&quot;</code> and <code>&quot;(0b1p+10 +0x802)&quot;</code> are
valid strings for <code>base</code>=0 and represent the same value.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fset_005fstr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_set_str</strong> <em>(mpc_t <var>rop</var>, const char *<var>s</var>, int <var>base</var>, mpc_rnd_t rnd)</em><a href='#index-mpc_005fset_005fstr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the string <var>s</var> in base <var>base</var>, rounded
to the precision of <var>rop</var> with the given rounding mode <var>rnd</var>.
See the documentation of <code>mpc_strtoc</code> for a detailed description of the
valid string formats.
Contrarily to <code>mpc_strtoc</code>, <code>mpc_set_str</code> requires the <em>whole</em>
string to represent a valid complex number (potentially followed by
additional white space).
This function returns the usual inexact value (see <a href="constant.GNU_MPC_Basics.html#return_002dvalue">Return
Value</a>) if the entire string up to the final null character is a valid number
in base <var>base</var>; otherwise it returns -1, and <var>rop</var> is set to
NaN+i*NaN.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fget_005fstr"><span class="category">Function: </span><span><em>char *</em> <strong>mpc_get_str</strong> <em>(int <var>b</var>, size_t <var>n</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fget_005fstr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>op</var> to a string containing its real and imaginary parts,
separated by a space and enclosed in a pair of parentheses.
The numbers are written in base <var>b</var> (which may vary from 2 to 36) and
rounded according to <var>rnd</var>. The number of significant digits, at least 2,
is given by <var>n</var>. It is also possible to let
<var>n</var> be zero, in which case the number of digits is chosen large
enough so that re-reading the printed value with the same precision, assuming
both output and input use rounding to nearest, will recover the original value
of <var>op</var>.
Note that <code>mpc_get_str</code> uses the decimal point of the current locale
if available, and &lsquo;<samp>.</samp>&rsquo; otherwise.
</p>
<p>The string is generated using the current memory allocation function
(<code>malloc</code> by default, unless it has been modified using the custom
memory allocation interface of <code>gmp</code>); once it is not needed any more,
it should be freed by calling <code>mpc_free_str</code>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005ffree_005fstr"><span class="category">Function: </span><span><em>void</em> <strong>mpc_free_str</strong> <em>(char *<var>str</var>)</em><a href='#index-mpc_005ffree_005fstr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Free the string <var>str</var>, which needs to have been allocated by
a call to <code>mpc_get_str</code>.
</p></dd></dl>
<p>The following two functions read numbers from input streams and write
them to output streams.
When using any of these functions, you need to include <samp>stdio.h</samp>
<em>before</em> <samp>mpc.h</samp>.
</p>
<dl class="def">
<dt id="index-mpc_005finp_005fstr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_inp_str</strong> <em>(mpc_t <var>rop</var>, FILE *<var>stream</var>, size_t *<var>read</var>, int <var>base</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005finp_005fstr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Input a string in base <var>base</var> in the same format as for <code>mpc_strtoc</code>
from stdio stream <var>stream</var>, rounded according to <var>rnd</var>, and put the
read complex number into <var>rop</var>.
If <var>stream</var> is the null pointer, <var>rop</var> is read from <code>stdin</code>.
Return the usual inexact value; if an error occurs, set <var>rop</var> to <code>NaN
+ i * NaN</code> and return -1.
If <var>read</var> is not the null pointer, it is set to the number of read
characters.
</p>
<p>Unlike <code>mpc_strtoc</code>, the function <code>mpc_inp_str</code> does not possess
perfect knowledge of the string to transform and has to read it
character by character, so it behaves slightly differently: It tries
to read a string describing a complex number and processes this string
through a call to <code>mpc_set_str</code>. Precisely, after skipping optional
whitespace, a minimal string is read according to the regular expression
<code>mpfr | '(' \s* mpfr \s+ mpfr \s* ')'</code>, where <code>\s</code> denotes a whitespace,
and <code>mpfr</code> is either a string containing neither whitespaces nor
parentheses, or <code>nan(n-char-sequence)</code> or <code>@nan@(n-char-sequence)</code>
(regardless of capitalisation) with <code>n-char-sequence</code> a string
of ascii letters, digits or <code>'_'</code>.
</p>
<p>For instance, upon input of <code>&quot;nan(13 1)&quot;</code>, the function
<code>mpc_inp_str</code> starts to recognise a value of NaN followed by an
n-char-sequence indicated by the opening parenthesis; as soon as the
space is reached, it becomes clear that the expression in parentheses
is not an n-char-sequence, and the error flag -1 is returned after 6
characters have been consumed from the stream (the whitespace itself
remaining in the stream).
The function <code>mpc_strtoc</code>, on the other hand, may track back
when reaching the whitespace; it treats the string as the two successive
complex numbers <code>NaN + i * 0</code> and <code>13 + i</code>.
It is thus recommended to have a whitespace follow each floating point number
to avoid this problem.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fout_005fstr"><span class="category">Function: </span><span><em>size_t</em> <strong>mpc_out_str</strong> <em>(FILE *<var>stream</var>, int <var>base</var>, size_t <var>n_digits</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fout_005fstr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Output <var>op</var> on stdio stream <var>stream</var> in
base <var>base</var>, rounded according to <var>rnd</var>, in the same format
as for <code>mpc_strtoc</code>
If <var>stream</var> is the null pointer, <var>rop</var> is written to <code>stdout</code>.
</p>
<p>Return the number of characters written.
</p></dd></dl>
<hr>
</div>
<div class="section" id="Complex-Comparison">
<div class="header">
<p>
Next: <a href="#Projection-_0026-Decomposing" accesskey="n" rel="next">Projection and Decomposing Functions</a>, Previous: <a href="#String-and-Stream-Input-and-Output" accesskey="p" rel="prev">String and Stream Input and Output</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Comparison-Functions"></span><h3 class="section">5.5 Comparison Functions</h3>
<span id="index-Complex-comparisons-functions"></span>
<span id="index-Comparison-functions"></span>
<dl class="def">
<dt id="index-mpc_005fcmp"><span class="category">Function: </span><span><em>int</em> <strong>mpc_cmp</strong> <em>(const mpc_t <var>op1</var>, const mpc_t <var>op2</var>)</em><a href='#index-mpc_005fcmp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fcmp_005fsi_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpc_cmp_si_si</strong> <em>(const mpc_t <var>op1</var>, long int <var>op2r</var>, long int <var>op2i</var>)</em><a href='#index-mpc_005fcmp_005fsi_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fcmp_005fsi"><span class="category">Macro: </span><span><em>int</em> <strong>mpc_cmp_si</strong> <em>(mpc_t <var>op1</var>, long int <var>op2</var>)</em><a href='#index-mpc_005fcmp_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Compare <var>op1</var> and <var>op2</var>, where in the case of <code>mpc_cmp_si_si</code>,
<var>op2</var> is taken to be <var>op2r</var> + i <var>op2i</var>.
The return value <var>c</var> can be decomposed into <code>x = MPC_INEX_RE(c)</code>
and <code>y = MPC_INEX_IM(c)</code>, such that <var>x</var> is
positive if the real part of <var>op1</var> is greater than that of <var>op2</var>,
zero if both real parts are equal, and negative if the real part of <var>op1</var>
is less than that of <var>op2</var>, and likewise for <var>y</var>.
Both <var>op1</var> and <var>op2</var> are considered to their full own precision,
which may differ.
It is not allowed that one of the operands has a NaN (Not-a-Number) part.
</p>
<p>The storage of the return value is such that equality can be simply checked
with <code>mpc_cmp (op1, op2) == 0</code>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fcmp_005fabs"><span class="category">Function: </span><span><em>int</em> <strong>mpc_cmp_abs</strong> <em>(const mpc_t <var>op1</var>, const mpc_t <var>op2</var>)</em><a href='#index-mpc_005fcmp_005fabs' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Compare the absolute values of <var>op1</var> and <var>op2</var>.
The return value is 0 if both are the same (including infinity),
positive if the absolute value of <var>op1</var> is greater than that of <var>op2</var>,
and negative if it is smaller.
If <var>op1</var> or <var>op2</var> has a real or imaginary part which is NaN,
the function behaves like <code>mpfr_cmp</code> on two real numbers of which at least
one is NaN.
</p></dd></dl>
<hr>
</div>
<div class="section" id="Projection-_0026-Decomposing">
<div class="header">
<p>
Next: <a href="#Basic-Arithmetic" accesskey="n" rel="next">Basic Arithmetic Functions</a>, Previous: <a href="#Complex-Comparison" accesskey="p" rel="prev">Comparison Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Projection-and-Decomposing-Functions"></span><h3 class="section">5.6 Projection and Decomposing Functions</h3>
<span id="index-Projection-and-Decomposing-Functions"></span>
<dl class="def">
<dt id="index-mpc_005freal"><span class="category">Function: </span><span><em>int</em> <strong>mpc_real</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005freal' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the real part of <var>op</var> rounded
in the direction <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fimag"><span class="category">Function: </span><span><em>int</em> <strong>mpc_imag</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fimag' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the imaginary part of <var>op</var> rounded in the
direction <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005frealref"><span class="category">Macro: </span><span><em>mpfr_t</em> <strong>mpc_realref</strong> <em>(mpc_t <var>op</var>)</em><a href='#index-mpc_005frealref' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fimagref"><span class="category">Macro: </span><span><em>mpfr_t</em> <strong>mpc_imagref</strong> <em>(mpc_t <var>op</var>)</em><a href='#index-mpc_005fimagref' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return a reference to the real part and imaginary part of <var>op</var>,
respectively. The <code>mpfr</code> functions can be used on the result of these
macros (note that the <code>mpfr_t</code> type is itself a pointer).
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005farg"><span class="category">Function: </span><span><em>int</em> <strong>mpc_arg</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005farg' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the argument of <var>op</var>, with a branch cut along the
negative real axis.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fproj"><span class="category">Function: </span><span><em>int</em> <strong>mpc_proj</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fproj' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute a projection of <var>op</var> onto the Riemann sphere. Set <var>rop</var> to
<var>op</var> rounded in the direction <var>rnd</var>, except when at least one part of
<var>op</var> is infinite (even if the other part is a NaN) in which case the real
part of <var>rop</var> is set to plus infinity and its imaginary part to a signed
zero with the same sign as the imaginary part of <var>op</var>.
</p></dd></dl>
<hr>
</div>
<div class="section" id="Basic-Arithmetic">
<div class="header">
<p>
Next: <a href="#Power-Functions-and-Logarithm" accesskey="n" rel="next">Power Functions and Logarithm</a>, Previous: <a href="#Projection-_0026-Decomposing" accesskey="p" rel="prev">Projection and Decomposing Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Basic-Arithmetic-Functions"></span><h3 class="section">5.7 Basic Arithmetic Functions</h3>
<span id="index-Complex-arithmetic-functions"></span>
<span id="index-Arithmetic-functions"></span>
<p>All the following functions are designed in such a way that, when working
with real numbers instead of complex numbers, their complexity should
essentially be the same as with the GNU MPFR library, with only a marginal
overhead due to the GNU MPC layer.
</p>
<p>For functions taking as input an integer argument
(for example <code>mpc_add_ui</code>), when this argument is zero,
it is considered as an unsigned (that is, exact in this context)
zero, and we follow the MPFR conventions:
(0) + (+0) = +0, (0) - (+0) = -0, (0) - (+0) = -0, (0) - (-0) = +0.
The same applies for functions taking an argument of type <code>mpfr_t</code>,
such as <code>mpc_add_fr</code>, of which the imaginary part is considered
to be an exact, unsigned zero.
</p>
<dl class="def">
<dt id="index-mpc_005fadd"><span class="category">Function: </span><span><em>int</em> <strong>mpc_add</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fadd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fadd_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_add_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fadd_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fadd_005ffr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_add_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fadd_005ffr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> <em class='math'>+</em> <var>op2</var> rounded according to <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fsub"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sub</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fsub_005ffr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sub_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fsub_005ffr' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005ffr_005fsub"><span class="category">Function: </span><span><em>int</em> <strong>mpc_fr_sub</strong> <em>(mpc_t <var>rop</var>, const mpfr_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005ffr_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fsub_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sub_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fsub_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fui_005fsub"><span class="category">Macro: </span><span><em>int</em> <strong>mpc_ui_sub</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fui_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fui_005fui_005fsub"><span class="category">Function: </span><span><em>int</em> <strong>mpc_ui_ui_sub</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>re1</var>, unsigned long int <var>im1</var>, mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fui_005fui_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> - <var>op2</var> rounded according to <var>rnd</var>.
For <code>mpc_ui_ui_sub</code>, <var>op1</var> is <var>re1</var> + <var>im1</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fneg"><span class="category">Function: </span><span><em>int</em> <strong>mpc_neg</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fneg' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to -<var>op</var> rounded according to <var>rnd</var>.
Just changes the sign if <var>rop</var> and <var>op</var> are the same variable.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fsum"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sum</strong> <em>(mpc_t <var>rop</var>, const mpc_ptr* <var>op</var>, unsigned long <var>n</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fsum' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the sum of the elements in the array <var>op</var> of
length <var>n</var>, rounded according to <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fmul"><span class="category">Function: </span><span><em>int</em> <strong>mpc_mul</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fmul' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fmul_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_mul_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fmul_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fmul_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpc_mul_si</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fmul_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fmul_005ffr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_mul_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fmul_005ffr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> times <var>op2</var> rounded according to <var>rnd</var>.
Note: for <code>mpc_mul</code>, in case <var>op1</var> and <var>op2</var> have the same value,
use <code>mpc_sqr</code> for better efficiency.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fmul_005fi"><span class="category">Function: </span><span><em>int</em> <strong>mpc_mul_i</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, int <var>sgn</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fmul_005fi' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op</var> times the imaginary unit i if <var>sgn</var> is
non-negative, set <var>rop</var> to <var>op</var> times -i otherwise,
in both cases rounded according to <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fsqr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sqr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fsqr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the square of <var>op</var> rounded according to <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005ffma"><span class="category">Function: </span><span><em>int</em> <strong>mpc_fma</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, const mpc_t <var>op3</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005ffma' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op1</var>*<var>op2</var>+<var>op3</var>,
rounded according to <var>rnd</var>, with only one final rounding.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fdot"><span class="category">Function: </span><span><em>int</em> <strong>mpc_dot</strong> <em>(mpc_t <var>rop</var>, const mpc_ptr* <var>op1</var>, mpc_ptr* <var>op2</var>, unsigned long <var>n</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fdot' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the dot product of the elements in the arrays <var>op1</var> and
<var>op2</var>, both of length <var>n</var>, rounded according to <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fdiv"><span class="category">Function: </span><span><em>int</em> <strong>mpc_div</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fdiv_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_div_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fdiv_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fdiv_005ffr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_div_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fdiv_005ffr' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fui_005fdiv"><span class="category">Function: </span><span><em>int</em> <strong>mpc_ui_div</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fui_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005ffr_005fdiv"><span class="category">Function: </span><span><em>int</em> <strong>mpc_fr_div</strong> <em>(mpc_t <var>rop</var>, const mpfr_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005ffr_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op1</var>/<var>op2</var> rounded according to <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fconj"><span class="category">Function: </span><span><em>int</em> <strong>mpc_conj</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fconj' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the conjugate of <var>op</var> rounded according to <var>rnd</var>.
Just changes the sign of the imaginary part
if <var>rop</var> and <var>op</var> are the same variable.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fabs"><span class="category">Function: </span><span><em>int</em> <strong>mpc_abs</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fabs' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set the floating-point number <var>rop</var> to the absolute value of <var>op</var>,
rounded in the direction <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fnorm"><span class="category">Function: </span><span><em>int</em> <strong>mpc_norm</strong> <em>(mpfr_t <var>rop</var>, const mpc_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fnorm' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set the floating-point number <var>rop</var> to the norm of <var>op</var>
(i.e., the square of its absolute value),
rounded in the direction <var>rnd</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fmul_005f2ui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_mul_2ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fmul_005f2ui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fmul_005f2si"><span class="category">Function: </span><span><em>int</em> <strong>mpc_mul_2si</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fmul_005f2si' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> times 2 raised to <var>op2</var>
rounded according to <var>rnd</var>. Just modifies the exponents
of the real and imaginary parts by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fdiv_005f2ui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_div_2ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fdiv_005f2ui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fdiv_005f2si"><span class="category">Function: </span><span><em>int</em> <strong>mpc_div_2si</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long int <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fdiv_005f2si' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> divided by 2 raised to <var>op2</var>
rounded according to <var>rnd</var>. Just modifies the exponents
of the real and imaginary parts by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical.
</p></dd></dl>
<hr>
</div>
<div class="section" id="Power-Functions-and-Logarithm">
<div class="header">
<p>
Next: <a href="#Trigonometric-Functions" accesskey="n" rel="next">Trigonometric Functions</a>, Previous: <a href="#Basic-Arithmetic" accesskey="p" rel="prev">Basic Arithmetic Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Power-Functions-and-Logarithm-1"></span><h3 class="section">5.8 Power Functions and Logarithm</h3>
<span id="index-Power-functions"></span>
<span id="index-Logarithm"></span>
<dl class="def">
<dt id="index-mpc_005fsqrt"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sqrt</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fsqrt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the square root of <var>op</var> rounded according to <var>rnd</var>.
The returned value <var>rop</var> has a non-negative real part, and if its real
part is zero, a non-negative imaginary part.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fpow"><span class="category">Function: </span><span><em>int</em> <strong>mpc_pow</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpc_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fpow' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fpow_005fd"><span class="category">Function: </span><span><em>int</em> <strong>mpc_pow_d</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, double <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fpow_005fd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fpow_005fld"><span class="category">Function: </span><span><em>int</em> <strong>mpc_pow_ld</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long double <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fpow_005fld' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fpow_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpc_pow_si</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, long <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fpow_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fpow_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpc_pow_ui</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, unsigned long <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fpow_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fpow_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpc_pow_z</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpz_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fpow_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fpow_005ffr"><span class="category">Function: </span><span><em>int</em> <strong>mpc_pow_fr</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op1</var>, const mpfr_t <var>op2</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fpow_005ffr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <var>op1</var> raised to the power <var>op2</var>, rounded according
to <var>rnd</var>.
For <code>mpc_pow_d</code>, <code>mpc_pow_ld</code>, <code>mpc_pow_si</code>, <code>mpc_pow_ui</code>,
<code>mpc_pow_z</code> and <code>mpc_pow_fr</code>,
the imaginary part of <var>op2</var> is considered as +0.
When both <var>op1</var> and <var>op2</var> are zero, the result has real part 1,
and imaginary part 0, with sign being the opposite of that of <var>op2</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fexp"><span class="category">Function: </span><span><em>int</em> <strong>mpc_exp</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fexp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the exponential of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005flog"><span class="category">Function: </span><span><em>int</em> <strong>mpc_log</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005flog' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005flog10"><span class="category">Function: </span><span><em>int</em> <strong>mpc_log10</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005flog10' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the natural and base-10 logarithm of <var>op</var> respectively,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
The principal branch is chosen, with the branch cut on the negative real axis,
so that the imaginary part of the result lies in
]-Pi , Pi]
and
]-Pi/log(10) , Pi/log(10)]
respectively.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005frootofunity"><span class="category">Function: </span><span><em>int</em> <strong>mpc_rootofunity</strong> <em>(mpc_t <var>rop</var>, unsigned long int <var>n</var>, unsigned long int <var>k</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005frootofunity' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the standard primitive <var>n</var>-th root of unity raised to the power <var>k</var>, that is,
<em class='math'>exp (2 Pi i k / n)</em>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fagm"><span class="category">Function: </span><span><em>int</em> <strong>mpc_agm</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>a</var>, const mpc_t <var>b</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fagm' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the arithmetic-geometric mean (AGM) of <var>a</var> and
<var>b</var>, rounded according to <var>rnd</var> with the precision of <var>rop</var>.
Concerning the branch cut, the function is computed by homogeneity either
as <var>a</var> AGM(1,b0) with b0=<var>b</var>/<var>a</var> if |<var>a</var>|&gt;=|<var>b</var>|,
or as <var>b</var> AGM(1,b0) with b0=<var>a</var>/<var>b</var> otherwise;
then when b0 is real and negative, AGM(1,b0) is chosen to have positive
imaginary part.
</p></dd></dl>
<hr>
</div>
<div class="section" id="Trigonometric-Functions">
<div class="header">
<p>
Next: <a href="#Modular-Functions" accesskey="n" rel="next">Modular Functions</a>, Previous: <a href="#Power-Functions-and-Logarithm" accesskey="p" rel="prev">Power Functions and Logarithm</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Trigonometric-Functions-1"></span><h3 class="section">5.9 Trigonometric Functions</h3>
<span id="index-Trigonometric-functions"></span>
<dl class="def">
<dt id="index-mpc_005fsin"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sin</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fsin' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fcos"><span class="category">Function: </span><span><em>int</em> <strong>mpc_cos</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fcos' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005ftan"><span class="category">Function: </span><span><em>int</em> <strong>mpc_tan</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005ftan' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the sine, cosine, tangent of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fsin_005fcos"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sin_cos</strong> <em>(mpc_t <var>rop_sin</var>, mpc_t <var>rop_cos</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd_sin</var>, mpc_rnd_t <var>rnd_cos</var>)</em><a href='#index-mpc_005fsin_005fcos' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop_sin</var> to the sine of <var>op</var>,
rounded according to <var>rnd_sin</var> with the precision of <var>rop_sin</var>,
and <var>rop_cos</var> to the cosine of <var>op</var>,
rounded according to <var>rnd_cos</var> with the precision of <var>rop_cos</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fsinh"><span class="category">Function: </span><span><em>int</em> <strong>mpc_sinh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fsinh' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fcosh"><span class="category">Function: </span><span><em>int</em> <strong>mpc_cosh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fcosh' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005ftanh"><span class="category">Function: </span><span><em>int</em> <strong>mpc_tanh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005ftanh' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the hyperbolic sine, hyperbolic cosine, hyperbolic tangent of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fasin"><span class="category">Function: </span><span><em>int</em> <strong>mpc_asin</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fasin' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005facos"><span class="category">Function: </span><span><em>int</em> <strong>mpc_acos</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005facos' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fatan"><span class="category">Function: </span><span><em>int</em> <strong>mpc_atan</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fatan' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the inverse sine, inverse cosine, inverse tangent of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fasinh"><span class="category">Function: </span><span><em>int</em> <strong>mpc_asinh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fasinh' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005facosh"><span class="category">Function: </span><span><em>int</em> <strong>mpc_acosh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005facosh' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpc_005fatanh"><span class="category">Function: </span><span><em>int</em> <strong>mpc_atanh</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005fatanh' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the inverse hyperbolic sine, inverse hyperbolic cosine,
inverse hyperbolic tangent of <var>op</var>,
rounded according to <var>rnd</var> with the precision of <var>rop</var>.
The branch cut of <code>mpc_acosh</code> is
(-Inf, 1)
</p></dd></dl>
<hr>
</div>
<div class="section" id="Modular-Functions">
<div class="header">
<p>
Next: <a href="#Miscellaneous-Complex-Functions" accesskey="n" rel="next">Miscellaneous Functions</a>, Previous: <a href="#Trigonometric-Functions" accesskey="p" rel="prev">Trigonometric Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Modular-Functions-1"></span><h3 class="section">5.10 Modular Functions</h3>
<span id="index-Modular-functions"></span>
<p>The following function is experimental, not least because it depends on
the equally experimental ball arithmetic, see <a href="constant.Ball_Arithmetic.html#start">Ball Arithmetic</a>.
So its prototype may change in future releases, and it may be removed
altogether.
</p>
<dl class="def">
<dt id="index-mpc_005feta_005ffund"><span class="category">Function: </span><span><em>int</em> <strong>mpc_eta_fund</strong> <em>(mpc_t <var>rop</var>, const mpc_t <var>op</var>, mpc_rnd_t <var>rnd</var>)</em><a href='#index-mpc_005feta_005ffund' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Assuming that the argument <var>op</var> lies in the fundamental domain for
<em class='math'>Sl_2(Z)</em>, that is, it has real part not below <em class='math'>-1/2</em> and
not above <em class='math'>+1/2</em> and absolute value at least 1,
return the value of the Dedekind eta-function in <var>rop</var>.
For arguments outside the fundamental domain the function is expected to
loop indefinitely.
</p></dd></dl>
<hr>
</div>
<div class="section" id="Miscellaneous-Complex-Functions">
<div class="header">
<p>
Next: <a href="#Advanced-Functions" accesskey="n" rel="next">Advanced Functions</a>, Previous: <a href="#Modular-Functions" accesskey="p" rel="prev">Modular Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Miscellaneous-Functions"></span><h3 class="section">5.11 Miscellaneous Functions</h3>
<span id="index-Miscellaneous-complex-functions"></span>
<dl class="def">
<dt id="index-mpc_005furandom"><span class="category">Function: </span><span><em>int</em> <strong>mpc_urandom</strong> <em>(mpc_t <var>rop</var>, gmp_randstate_t <var>state</var>)</em><a href='#index-mpc_005furandom' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Generate a uniformly distributed random complex in the unit square <em class='math'>[0,
1] x [0, 1]</em>. Return 0, unless an exponent in the real or imaginary part
is not in the current exponent range, in which case that part is set to NaN
and a zero value is returned. The second argument is a <code>gmp_randstate_t</code>
structure which should be created using the GMP <code>rand_init</code> function, see
the GMP manual.
</p></dd></dl>
<dl class="def">
<dt id="index-mpc_005fget_005fversion"><span class="category">Function: </span><span><em>const char *</em> <strong>mpc_get_version</strong> <em>(void)</em><a href='#index-mpc_005fget_005fversion' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the GNU MPC version, as a null-terminated string.
</p></dd></dl>
<dl class="def">
<dt id="index-MPC_005fVERSION"><span class="category">Macro: </span><span><strong>MPC_VERSION</strong><a href='#index-MPC_005fVERSION' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-MPC_005fVERSION_005fMAJOR"><span class="category">Macro: </span><span><strong>MPC_VERSION_MAJOR</strong><a href='#index-MPC_005fVERSION_005fMAJOR' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-MPC_005fVERSION_005fMINOR"><span class="category">Macro: </span><span><strong>MPC_VERSION_MINOR</strong><a href='#index-MPC_005fVERSION_005fMINOR' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-MPC_005fVERSION_005fPATCHLEVEL"><span class="category">Macro: </span><span><strong>MPC_VERSION_PATCHLEVEL</strong><a href='#index-MPC_005fVERSION_005fPATCHLEVEL' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-MPC_005fVERSION_005fSTRING"><span class="category">Macro: </span><span><strong>MPC_VERSION_STRING</strong><a href='#index-MPC_005fVERSION_005fSTRING' class='copiable-anchor'> &para;</a></span></dt>
<dd><p><code>MPC_VERSION</code> is the version of GNU MPC as a preprocessing constant.
<code>MPC_VERSION_MAJOR</code>, <code>MPC_VERSION_MINOR</code> and
<code>MPC_VERSION_PATCHLEVEL</code> are respectively the major, minor and
patch level of GNU MPC version, as preprocessing constants.
<code>MPC_VERSION_STRING</code> is the version as a string constant, which
can be compared to the result of <code>mpc_get_version</code> to check at
run time the header file and library used match:
</p><div class="example">
<pre class="example">if (strcmp (mpc_get_version (), MPC_VERSION_STRING))
  fprintf (stderr, &quot;Warning: header and library do not match\n&quot;);
</pre></div>
<p>Note: Obtaining different strings is not necessarily an error, as in
general, a program compiled with some old GNU MPC version can be
dynamically linked with a newer GNU MPC library version (if allowed by the
library versioning system).
</p></dd></dl>
<dl class="def">
<dt id="index-MPC_005fVERSION_005fNUM"><span class="category">Macro: </span><span><em>long</em> <strong>MPC_VERSION_NUM</strong> <em>(<var>major</var>, <var>minor</var>, <var>patchlevel</var>)</em><a href='#index-MPC_005fVERSION_005fNUM' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Create an integer in the same format as used by <code>MPC_VERSION</code> from the
given <var>major</var>, <var>minor</var> and <var>patchlevel</var>.
Here is an example of how to check the GNU MPC version at compile time:
</p><div class="example">
<pre class="example">#if (!defined(MPC_VERSION) || (MPC_VERSION&lt;MPC_VERSION_NUM(2,1,0)))
# error &quot;Wrong GNU MPC version.&quot;
#endif
</pre></div>
</dd></dl>
<hr>
</div>
<div class="section" id="Advanced-Functions">
<div class="header">
<p>
Next: <a href="#Internals" accesskey="n" rel="next">Internals</a>, Previous: <a href="#Miscellaneous-Complex-Functions" accesskey="p" rel="prev">Miscellaneous Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Advanced-Functions-1"></span><h3 class="section">5.12 Advanced Functions</h3>
<dl class="def">
<dt id="index-MPC_005fSET_005fX_005fY"><span class="category">Macro: </span><span><strong>MPC_SET_X_Y</strong> <em>(<var>real_suffix</var>, <var>imag_suffix</var>, <var>rop</var>, <var>real</var>, <var>imag</var>, <var>rnd</var>)</em><a href='#index-MPC_005fSET_005fX_005fY' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>The macro MPC_SET_X_Y is designed to serve as the body of an assignment
function and cannot be used by itself.
The <var>real_suffix</var> and <var>imag_suffix</var> parameters are the
types of the real and imaginary part, that is, the <code>x</code> in the
<code>mpfr_set_x</code> function one would use to set the part;
for the mpfr type, use <code>fr</code>.
<var>real</var> (respectively <var>imag</var>) is the value you want to assign to the
real (resp. imaginary) part, its type must conform to <var>real_suffix</var>
(resp. <var>imag_suffix</var>).
<var>rnd</var> is the <code>mpc_rnd_t</code> rounding mode.
The return value is the usual inexact value (see <a href="constant.GNU_MPC_Basics.html#return_002dvalue">Return
Value</a>).
</p>
<p>For instance, you can define mpc_set_ui_fr as follows:
</p><div class="example">
<pre class="example">int mpc_set_ui_fr (mpc_t rop, unsigned long int re, mpfr_t im, mpc_rnd_t rnd)
    MPC_SET_X_Y (ui, fr, rop, re, im, rnd);
</pre></div>
</dd></dl>
<hr>
</div>
<div class="section" id="Internals">
<div class="header">
<p>
Previous: <a href="#Advanced-Functions" accesskey="p" rel="prev">Advanced Functions</a>, Up: <a href="#Complex-Functions" accesskey="u" rel="up">Complex Functions</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Internals-1"></span><h3 class="section">5.13 Internals</h3>
<p>These macros and
functions are mainly designed for the implementation of GNU MPC,
but may be useful for users too.
However, no upward compatibility is guaranteed.
You need to include <code>mpc-impl.h</code> to use them.
</p>
<p>The macro <code>MPC_MAX_PREC(z)</code> gives the maximum of the precisions
of the real and imaginary parts of a complex number.
</p>
</div>
</div>
<hr>
<div class="header">
<p>
Next: <a href="constant.Ball_Arithmetic.html#start" accesskey="n" rel="next">Ball Arithmetic</a>, Previous: <a href="constant.GNU_MPC_Basics.html#start" accesskey="p" rel="prev">GNU MPC Basics</a>, Up: <a href="index.html#start" accesskey="u" rel="up">GNU MPC</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
