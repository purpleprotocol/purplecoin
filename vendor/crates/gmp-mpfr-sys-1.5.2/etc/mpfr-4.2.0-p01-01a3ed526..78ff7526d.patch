diff --git a/BUGS b/BUGS
index aa301f9d4..6ed18a951 100644
--- a/BUGS
+++ b/BUGS
@@ -39,6 +39,9 @@ Known bugs:
   between parameters' exponents is near 2*MPFR_EMAX_MAX and on the other hand
   the output precision or the precision of the parameter with greatest
   absolute value is greater than 2*MPFR_EMAX_MAX-4.
+  Note: Such huge precisions are not possible as they would be larger than
+  MPFR_PREC_MAX, unless the types for mpfr_exp_t and/or mpfr_prec_t are
+  changed (only for developers or expert users, not officially supported).
 
 Potential bugs:
 
diff --git a/doc/README.dev b/doc/README.dev
index 49c9676bf..e5b4406e9 100644
--- a/doc/README.dev
+++ b/doc/README.dev
@@ -241,6 +241,7 @@ To make a release (for the MPFR team):
      This should at least be done last, in order to be complete before the
      generation of the tarball.
      Note: First, make sure that all the pending commits have been done.
+     Push the changes with "git push".
 
   5) Create an annotated tag whose name corresponds to the content of
      the VERSION file:
@@ -435,8 +436,13 @@ To make a release (for the MPFR team):
      In case of a new patchlevel release, add a link from the web page
      of the previous release.
 
-     * For the release candidates: Announce the RC in the mpfr-announce,
-     mpfr, gmp-discuss, gcc and platform-testers[2] mailing-lists.
+     * For the release candidates:
+     Upload the tarballs and the signatures to the MPFR web server
+     (via the misc.git repository).
+     Run the tools/announce-text script to do some checking and get
+     the announce text. Edit this text if need be.
+     Announce the RC in the mpfr-announce, mpfr, gmp-discuss, gcc and
+     platform-testers[2] mailing-lists.
      A minimal web page for the MPFR release can be created right now
      (see Git history such as [3] for examples), as the manual already
      contains the new URLs.
diff --git a/src/mpfr-impl.h b/src/mpfr-impl.h
index fe54cecab..613e8c1cf 100644
--- a/src/mpfr-impl.h
+++ b/src/mpfr-impl.h
@@ -1655,8 +1655,10 @@ do {                                                                  \
    this can be found in practice: https://reviews.llvm.org/D27167 says:
    "I found this problem on FreeBSD 11, where thousands_sep in fr_FR.UTF-8
    is a no-break space (U+00A0)."
-   Note, however, that this is not allowed by the C standard, which just
-   says "character" and not "multibyte character".
+   Under Linux, this is U+202F NARROW NO-BREAK SPACE (e2 80 af).
+   And in the ps_AF locale,
+     decimal_point = U+066B ARABIC DECIMAL SEPARATOR (d9 ab)
+     thousands_sep = U+066C ARABIC THOUSANDS SEPARATOR (d9 ac)
    In the mean time, in case of non-single-byte character, revert to the
    default value. */
 #if MPFR_LCONV_DPTS
diff --git a/tests/tfprintf.c b/tests/tfprintf.c
index 5af54b023..6028cb501 100644
--- a/tests/tfprintf.c
+++ b/tests/tfprintf.c
@@ -55,12 +55,18 @@ https://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 #define check_length_with_cmp(num_test, var, value, cmp, var_spec)      \
   if (cmp != 0)                                                         \
     {                                                                   \
-      mpfr_printf ("Error in test #%d, mpfr_vfprintf printed %"         \
+      mpfr_printf ("Error in test #%d: mpfr_vfprintf printed %"         \
                    QUOTE(var_spec) " characters instead of %d\n",       \
                    (num_test), (var), (value));                         \
       exit (1);                                                         \
     }
 
+#if MPFR_LCONV_DPTS
+#define DPLEN ((int) strlen (localeconv()->decimal_point))
+#else
+#define DPLEN 1
+#endif
+
 /* limit for random precision in random() */
 const int prec_max_printf = 5000;
 
@@ -195,12 +201,12 @@ check_mixed (FILE *fout)
                   lo, &ulo);
   check_length (2, ulo, 36, lu);
   check_vfprintf (fout, "a. %hi, b. %*f, c. %Re%hn", ush, 3, f, mpfr, &ush);
-  check_length (3, ush, 46, hu);
+  check_length (3, ush, 45 + DPLEN, hu);
   check_vfprintf (fout, "a. %hi, b. %f, c. %#.2Rf%n", sh, d, mpfr, &i);
-  check_length (4, i, 29, d);
+  check_length (4, i, 28 + DPLEN, d);
   check_vfprintf (fout, "a. %R*A, b. %Fe, c. %i%zn", rnd, mpfr, mpf, sz,
                   &sz);
-  check_length (5, (unsigned long) sz, 34, lu); /* no format specifier "%zu" in C90 */
+  check_length (5, (unsigned long) sz, 33 + DPLEN, lu); /* no format specifier "%zu" in C90 */
   check_vfprintf (fout, "a. %Pu, b. %c, c. %Zi%Zn", prec, ch, mpz, &mpz);
   check_length_with_cmp (6, mpz, 17, mpz_cmp_ui (mpz, 17), Zi);
   check_vfprintf (fout, "%% a. %#.0RNg, b. %Qx%Rn, c. %p", mpfr, mpq, &mpfr,
@@ -212,7 +218,9 @@ check_mixed (FILE *fout)
   check_vfprintf (fout, "%% a. %RNg, b. %Qx, c. %td%tn", mpfr, mpq, p, &p);
   if (p != 20)
     {
-      mpfr_fprintf (stderr, "Error in test 8, got '%% a. %RNg, b. %Qx, c. %td'\n", mpfr, mpq, saved_p);
+      mpfr_fprintf (stderr,
+                    "Error in test #8: got '%% a. %RNg, b. %Qx, c. %td'\n",
+                    mpfr, mpq, saved_p);
 #if defined(__MINGW32__) || defined(__MINGW64__)
       fprintf (stderr,
                "Your MinGW may be too old, in which case compiling GMP\n"
@@ -224,7 +232,7 @@ check_mixed (FILE *fout)
 
 #ifdef PRINTF_L
   check_vfprintf (fout, "a. %RA, b. %Lf, c. %QX%zn", mpfr, ld, mpq, &sz);
-  check_length (9, (unsigned long) sz, 30, lu); /* no format specifier "%zu" in C90 */
+  check_length (9, (unsigned long) sz, 29 + DPLEN, lu); /* no format specifier "%zu" in C90 */
 #endif
 
 #ifndef NPRINTF_HH
diff --git a/tests/tprintf.c b/tests/tprintf.c
index c8a7b90de..66fbfb7fd 100644
--- a/tests/tprintf.c
+++ b/tests/tprintf.c
@@ -62,12 +62,18 @@ https://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 #define check_length_with_cmp(num_test, var, value, cmp, var_spec)      \
   if (cmp != 0)                                                         \
     {                                                                   \
-      mpfr_fprintf (stderr, "Error in test #%d, mpfr_printf printed %"  \
+      mpfr_fprintf (stderr, "Error in test #%d: mpfr_printf printed %"  \
                     QUOTE(var_spec)" characters instead of %d\n",       \
                     (num_test), (var), (value));                        \
       exit (1);                                                         \
     }
 
+#if MPFR_LCONV_DPTS
+#define DPLEN ((int) strlen (localeconv()->decimal_point))
+#else
+#define DPLEN 1
+#endif
+
 /* limit for random precision in random() */
 const int prec_max_printf = 5000;
 /* boolean: is stdout redirected to a file ? */
@@ -316,11 +322,11 @@ check_mixed (void)
   check_vprintf ("a. %c, b. %Rb, c. %u, d. %li%ln", i, mpfr, i, lo, &ulo);
   check_length (2, ulo, 36, lu);
   check_vprintf ("a. %hi, b. %*f, c. %Re%hn", ush, 3, f, mpfr, &ush);
-  check_length (3, ush, 46, hu);
+  check_length (3, ush, 45 + DPLEN, hu);
   check_vprintf ("a. %hi, b. %f, c. %#.2Rf%n", sh, d, mpfr, &i);
-  check_length (4, i, 29, d);
+  check_length (4, i, 28 + DPLEN, d);
   check_vprintf ("a. %R*A, b. %Fe, c. %i%zn", rnd, mpfr, mpf, sz, &sz);
-  check_length (5, (unsigned long) sz, 34, lu); /* no format specifier '%zu' in C90 */
+  check_length (5, (unsigned long) sz, 33 + DPLEN, lu); /* no format specifier '%zu' in C90 */
   check_vprintf ("a. %Pu, b. %c, c. %RUG, d. %Zi%Zn", prec, ch, mpfr, mpz, &mpz);
   check_length_with_cmp (6, mpz, 24, mpz_cmp_ui (mpz, 24), Zi);
   check_vprintf ("%% a. %#.0RNg, b. %Qx%Rn c. %p",
@@ -332,7 +338,9 @@ check_mixed (void)
   check_vprintf ("%% a. %RNg, b. %Qx, c. %td%tn", mpfr, mpq, p, &p);
   if (p != 20)
     {
-      mpfr_fprintf (stderr, "Error in test 8, got '%% a. %RNg, b. %Qx, c. %td'\n", mpfr, mpq, saved_p);
+      mpfr_fprintf (stderr,
+                    "Error in test #8: got '%% a. %RNg, b. %Qx, c. %td'\n",
+                    mpfr, mpq, saved_p);
 #if defined(__MINGW32__) || defined(__MINGW64__)
       fprintf (stderr,
                "Your MinGW may be too old, in which case compiling GMP\n"
@@ -344,7 +352,7 @@ check_mixed (void)
 
 #ifdef PRINTF_L
   check_vprintf ("a. %RA, b. %Lf, c. %QX%zn", mpfr, ld, mpq, &sz);
-  check_length (9, (unsigned long) sz, 30, lu); /* no format specifier '%zu' in C90 */
+  check_length (9, (unsigned long) sz, 29 + DPLEN, lu); /* no format specifier '%zu' in C90 */
 #endif
 
 #ifndef NPRINTF_HH
diff --git a/tests/tsprintf.c b/tests/tsprintf.c
index c7bd74ac5..b5d8951c1 100644
--- a/tests/tsprintf.c
+++ b/tests/tsprintf.c
@@ -1715,7 +1715,23 @@ test_locale (void)
   check_sprintf ("000000001,000", "%'013.4Rg", x);
 
 #ifdef PRINTF_GROUPFLAG
-  check_vsprintf ("+01,234,567  :", "%0+ -'13.10Pd:", (mpfr_prec_t) 1234567);
+  /* Do not test the thousands separator with a precision field larger
+     than the number of digits (thus needing leading zeros), such as
+     "%0+ -'13.10Pd:" (used up to MPFR 4.2.0), since the GNU libc is
+     buggy: https://sourceware.org/bugzilla/show_bug.cgi?id=23432
+     We don't know about the other implementations.
+     This new test works fine with glibc up to 2.36, but fails with 2.37
+     (as reported by Klaus Dittrich in the MPFR mailing-list); this is
+     actually a bug introduced in glibc 2.37, not in MPFR:
+       https://sourceware.org/bugzilla/show_bug.cgi?id=30068
+     Since this bug can yield a buffer overflow (CVE-2023-25139), let us
+     rather wait for a fix in glibc.
+     If we wanted to check that and avoid a failure of the test because of
+     a buggy C library (while MPFR would be consistent with the C library),
+     we could compare the MPFR output with both the correct output and the
+     output from the C library (possibly buggy). But to do that in a clean
+     way, this would require a change in the check_vsprintf() call. */
+  check_vsprintf ("+1,234,567   :", "%0+ -'13Pd:", (mpfr_prec_t) 1234567);
 #endif
 
   mpfr_clear (x);
