<div class="chapter-level-extent" id="Low_002dlevel-Functions">
<div class="nav-panel">
<p>
Next: <a href="constant.Random_Number_Functions.html#Random-Number-Functions" accesskey="n" rel="next">Random Number Functions</a>, Previous: <a href="constant.Floating_point_Functions.html#Floating_002dpoint-Functions" accesskey="p" rel="prev">Floating-point Functions</a>, Up: <a href="index.html#start" accesskey="u" rel="up">GNU MP</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="Low_002dlevel-Functions-1">8 Low-level Functions</h2>
<a class="index-entry-id" id="index-Low_002dlevel-functions"></a>
<p>This chapter describes low-level GMP functions, used to implement the
high-level GMP functions, but also intended for time-critical user code.
</p>
<p>These functions start with the prefix <code class="code">mpn_</code>.
</p>
<p>The <code class="code">mpn</code> functions are designed to be as fast as possible, <strong class="strong">not</strong>
to provide a coherent calling interface.  The different functions have somewhat
similar interfaces, but there are variations that make them hard to use.  These
functions do as little as possible apart from the real multiple precision
computation, so that no time is spent on things that not all callers need.
</p>
<p>A source operand is specified by a pointer to the least significant limb and a
limb count.  A destination operand is specified by just a pointer.  It is the
responsibility of the caller to ensure that the destination has enough space
for storing the result.
</p>
<p>With this way of specifying operands, it is possible to perform computations on
subranges of an argument, and store the result into a subrange of a
destination.
</p>
<p>A common requirement for all functions is that each source area needs at least
one limb.  No size argument may be zero.  Unless otherwise stated, in-place
operations are allowed where source and destination are the same, but not where
they only partly overlap.
</p>
<p>The <code class="code">mpn</code> functions are the base for the implementation of the
<code class="code">mpz_</code>, <code class="code">mpf_</code>, and <code class="code">mpq_</code> functions.
</p>
<p>This example adds the number beginning at <var class="var">s1p</var> and the number beginning at
<var class="var">s2p</var> and writes the sum at <var class="var">destp</var>.  All areas have <var class="var">n</var> limbs.
</p>
<div class="example">
<pre class="example-preformatted">cy = mpn_add_n (destp, s1p, s2p, n)
</pre></div>
<p>It should be noted that the <code class="code">mpn</code> functions make no attempt to identify
high or low zero limbs on their operands, or other special forms.  On random
data such cases will be unlikely and it&rsquo;d be wasteful for every function to
check every time.  An application knowing something about its data can take
steps to trim or perhaps split its calculations.
</p>
<br>
<p>In the notation used below, a source operand is identified by the pointer to
the least significant limb, and the limb count in braces.  For example,
{<var class="var">s1p</var>, <var class="var">s1n</var>}.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fadd_005fn"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_add_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fadd_005fn'> &para;</a></span></dt>
<dd><p>Add {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">s2p</var>, <var class="var">n</var>}, and write the <var class="var">n</var>
least significant limbs of the result to <var class="var">rp</var>.  Return carry, either 0 or
1.
</p>
<p>This is the lowest-level function for addition.  It is the preferred function
for addition, since it is written in assembly for most CPUs.  For addition of
a variable to itself (i.e., <var class="var">s1p</var> equals <var class="var">s2p</var>) use <code class="code">mpn_lshift</code>
with a count of 1 for optimal speed.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fadd_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_add_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>, mp_limb_t <var class="var">s2limb</var>)</code><a class="copiable-link" href='#index-mpn_005fadd_005f1'> &para;</a></span></dt>
<dd><p>Add {<var class="var">s1p</var>, <var class="var">n</var>} and <var class="var">s2limb</var>, and write the <var class="var">n</var> least
significant limbs of the result to <var class="var">rp</var>.  Return carry, either 0 or 1.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fadd"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_add</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">s1n</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">s2n</var>)</code><a class="copiable-link" href='#index-mpn_005fadd'> &para;</a></span></dt>
<dd><p>Add {<var class="var">s1p</var>, <var class="var">s1n</var>} and {<var class="var">s2p</var>, <var class="var">s2n</var>}, and write the
<var class="var">s1n</var> least significant limbs of the result to <var class="var">rp</var>.  Return carry,
either 0 or 1.
</p>
<p>This function requires that <var class="var">s1n</var> is greater than or equal to <var class="var">s2n</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsub_005fn"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_sub_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fsub_005fn'> &para;</a></span></dt>
<dd><p>Subtract {<var class="var">s2p</var>, <var class="var">n</var>} from {<var class="var">s1p</var>, <var class="var">n</var>}, and write the
<var class="var">n</var> least significant limbs of the result to <var class="var">rp</var>.  Return borrow,
either 0 or 1.
</p>
<p>This is the lowest-level function for subtraction.  It is the preferred
function for subtraction, since it is written in assembly for most CPUs.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsub_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_sub_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>, mp_limb_t <var class="var">s2limb</var>)</code><a class="copiable-link" href='#index-mpn_005fsub_005f1'> &para;</a></span></dt>
<dd><p>Subtract <var class="var">s2limb</var> from {<var class="var">s1p</var>, <var class="var">n</var>}, and write the <var class="var">n</var> least
significant limbs of the result to <var class="var">rp</var>.  Return borrow, either 0 or 1.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsub"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_sub</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">s1n</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">s2n</var>)</code><a class="copiable-link" href='#index-mpn_005fsub'> &para;</a></span></dt>
<dd><p>Subtract {<var class="var">s2p</var>, <var class="var">s2n</var>} from {<var class="var">s1p</var>, <var class="var">s1n</var>}, and write the
<var class="var">s1n</var> least significant limbs of the result to <var class="var">rp</var>.  Return borrow,
either 0 or 1.
</p>
<p>This function requires that <var class="var">s1n</var> is greater than or equal to
<var class="var">s2n</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fneg"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_neg</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">sp</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fneg'> &para;</a></span></dt>
<dd><p>Perform the negation of {<var class="var">sp</var>, <var class="var">n</var>}, and write the result to
{<var class="var">rp</var>, <var class="var">n</var>}.  This is equivalent to calling <code class="code">mpn_sub_n</code> with a
<var class="var">n</var>-limb zero minuend and passing {<var class="var">sp</var>, <var class="var">n</var>} as subtrahend.
Return borrow, either 0 or 1.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fmul_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_mul_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fmul_005fn'> &para;</a></span></dt>
<dd><p>Multiply {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">s2p</var>, <var class="var">n</var>}, and write the
2*<var class="var">n</var>-limb result to <var class="var">rp</var>.
</p>
<p>The destination has to have space for 2*<var class="var">n</var> limbs, even if the product&rsquo;s
most significant limb is zero.  No overlap is permitted between the
destination and either source.
</p>
<p>If the two input operands are the same, use <code class="code">mpn_sqr</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fmul"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_mul</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">s1n</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">s2n</var>)</code><a class="copiable-link" href='#index-mpn_005fmul'> &para;</a></span></dt>
<dd><p>Multiply {<var class="var">s1p</var>, <var class="var">s1n</var>} and {<var class="var">s2p</var>, <var class="var">s2n</var>}, and write the
(<var class="var">s1n</var>+<var class="var">s2n</var>)-limb result to <var class="var">rp</var>.  Return the most significant
limb of the result.
</p>
<p>The destination has to have space for <var class="var">s1n</var> + <var class="var">s2n</var> limbs, even if the
product&rsquo;s most significant limb is zero.  No overlap is permitted between the
destination and either source.
</p>
<p>This function requires that <var class="var">s1n</var> is greater than or equal to <var class="var">s2n</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsqr"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_sqr</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fsqr'> &para;</a></span></dt>
<dd><p>Compute the square of {<var class="var">s1p</var>, <var class="var">n</var>} and write the 2*<var class="var">n</var>-limb
result to <var class="var">rp</var>.
</p>
<p>The destination has to have space for 2<var class="var">n</var> limbs, even if the result&rsquo;s
most significant limb is zero.  No overlap is permitted between the
destination and the source.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fmul_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_mul_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>, mp_limb_t <var class="var">s2limb</var>)</code><a class="copiable-link" href='#index-mpn_005fmul_005f1'> &para;</a></span></dt>
<dd><p>Multiply {<var class="var">s1p</var>, <var class="var">n</var>} by <var class="var">s2limb</var>, and write the <var class="var">n</var> least
significant limbs of the product to <var class="var">rp</var>.  Return the most significant
limb of the product.  {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">rp</var>, <var class="var">n</var>} are
allowed to overlap provided <em class="math"><var class="var">rp</var> &lt;= <var class="var">s1p</var></em>.
</p>
<p>This is a low-level function that is a building block for general
multiplication as well as other operations in GMP.  It is written in assembly
for most CPUs.
</p>
<p>Don&rsquo;t call this function if <var class="var">s2limb</var> is a power of 2; use <code class="code">mpn_lshift</code>
with a count equal to the logarithm of <var class="var">s2limb</var> instead, for optimal speed.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005faddmul_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_addmul_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>, mp_limb_t <var class="var">s2limb</var>)</code><a class="copiable-link" href='#index-mpn_005faddmul_005f1'> &para;</a></span></dt>
<dd><p>Multiply {<var class="var">s1p</var>, <var class="var">n</var>} and <var class="var">s2limb</var>, and add the <var class="var">n</var> least
significant limbs of the product to {<var class="var">rp</var>, <var class="var">n</var>} and write the result
to <var class="var">rp</var>.  Return the most significant limb of the product, plus carry-out
from the addition.  {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">rp</var>, <var class="var">n</var>} are
allowed to overlap provided <em class="math"><var class="var">rp</var> &lt;= <var class="var">s1p</var></em>.
</p>
<p>This is a low-level function that is a building block for general
multiplication as well as other operations in GMP.  It is written in assembly
for most CPUs.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsubmul_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_submul_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>, mp_limb_t <var class="var">s2limb</var>)</code><a class="copiable-link" href='#index-mpn_005fsubmul_005f1'> &para;</a></span></dt>
<dd><p>Multiply {<var class="var">s1p</var>, <var class="var">n</var>} and <var class="var">s2limb</var>, and subtract the <var class="var">n</var>
least significant limbs of the product from {<var class="var">rp</var>, <var class="var">n</var>} and write the
result to <var class="var">rp</var>.  Return the most significant limb of the product, plus
borrow-out from the subtraction.  {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">rp</var>,
<var class="var">n</var>} are allowed to overlap provided <em class="math"><var class="var">rp</var> &lt;= <var class="var">s1p</var></em>.
</p>
<p>This is a low-level function that is a building block for general
multiplication and division as well as other operations in GMP.  It is written
in assembly for most CPUs.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005ftdiv_005fqr"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_tdiv_qr</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">qp</var>, mp_limb_t *<var class="var">rp</var>, mp_size_t <var class="var">qxn</var>, const mp_limb_t *<var class="var">np</var>, mp_size_t <var class="var">nn</var>, const mp_limb_t *<var class="var">dp</var>, mp_size_t <var class="var">dn</var>)</code><a class="copiable-link" href='#index-mpn_005ftdiv_005fqr'> &para;</a></span></dt>
<dd><p>Divide {<var class="var">np</var>, <var class="var">nn</var>} by {<var class="var">dp</var>, <var class="var">dn</var>} and put the quotient
at {<var class="var">qp</var>, <var class="var">nn</var>&minus;<var class="var">dn</var>+1} and the remainder at {<var class="var">rp</var>,
<var class="var">dn</var>}.  The quotient is rounded towards 0.
</p>
<p>No overlap is permitted between arguments, except that <var class="var">np</var> might equal
<var class="var">rp</var>.  The dividend size <var class="var">nn</var> must be greater than or equal to divisor
size <var class="var">dn</var>.  The most significant limb of the divisor must be non-zero.  The
<var class="var">qxn</var> operand must be zero.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fdivrem"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_divrem</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">r1p</var>, mp_size_t <var class="var">qxn</var>, mp_limb_t *<var class="var">rs2p</var>, mp_size_t <var class="var">rs2n</var>, const mp_limb_t *<var class="var">s3p</var>, mp_size_t <var class="var">s3n</var>)</code><a class="copiable-link" href='#index-mpn_005fdivrem'> &para;</a></span></dt>
<dd><p>[This function is obsolete.  Please call <code class="code">mpn_tdiv_qr</code> instead for best
performance.]
</p>
<p>Divide {<var class="var">rs2p</var>, <var class="var">rs2n</var>} by {<var class="var">s3p</var>, <var class="var">s3n</var>}, and write the
quotient at <var class="var">r1p</var>, with the exception of the most significant limb, which
is returned.  The remainder replaces the dividend at <var class="var">rs2p</var>; it will be
<var class="var">s3n</var> limbs long (i.e., as many limbs as the divisor).
</p>
<p>In addition to an integer quotient, <var class="var">qxn</var> fraction limbs are developed, and
stored after the integral limbs.  For most usages, <var class="var">qxn</var> will be zero.
</p>
<p>It is required that <var class="var">rs2n</var> is greater than or equal to <var class="var">s3n</var>.  It is
required that the most significant bit of the divisor is set.
</p>
<p>If the quotient is not needed, pass <var class="var">rs2p</var> + <var class="var">s3n</var> as <var class="var">r1p</var>.  Aside
from that special case, no overlap between arguments is permitted.
</p>
<p>Return the most significant limb of the quotient, either 0 or 1.
</p>
<p>The area at <var class="var">r1p</var> needs to be <var class="var">rs2n</var> &minus; <var class="var">s3n</var> + <var class="var">qxn</var>
limbs large.
</p></dd></dl>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-mpn_005fdivrem_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_divrem_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">r1p</var>, mp_size_t <var class="var">qxn</var>, <span class="w-nolinebreak-text">mp_limb_t</span>&nbsp;*<var class="var">s2p</var><!-- /@w -->, mp_size_t <var class="var">s2n</var>, mp_limb_t <var class="var">s3limb</var>)</code><a class="copiable-link" href='#index-mpn_005fdivrem_005f1'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpn_005fdivmod_005f1"><span class="category-def">Macro: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_divmod_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">r1p</var>, mp_limb_t *<var class="var">s2p</var>, <span class="w-nolinebreak-text">mp_size_t</span>&nbsp;<var class="var">s2n</var><!-- /@w -->, <span class="w-nolinebreak-text">mp_limb_t</span>&nbsp;<var class="var">s3limb</var><!-- /@w -->)</code><a class="copiable-link" href='#index-mpn_005fdivmod_005f1'> &para;</a></span></dt>
<dd><p>Divide {<var class="var">s2p</var>, <var class="var">s2n</var>} by <var class="var">s3limb</var>, and write the quotient at
<var class="var">r1p</var>.  Return the remainder.
</p>
<p>The integer quotient is written to {<var class="var">r1p</var>+<var class="var">qxn</var>, <var class="var">s2n</var>} and in
addition <var class="var">qxn</var> fraction limbs are developed and written to {<var class="var">r1p</var>,
<var class="var">qxn</var>}.  Either or both <var class="var">s2n</var> and <var class="var">qxn</var> can be zero.  For most
usages, <var class="var">qxn</var> will be zero.
</p>
<p><code class="code">mpn_divmod_1</code> exists for upward source compatibility and is simply a
macro calling <code class="code">mpn_divrem_1</code> with a <var class="var">qxn</var> of 0.
</p>
<p>The areas at <var class="var">r1p</var> and <var class="var">s2p</var> have to be identical or completely
separate, not partially overlapping.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fdivmod"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_divmod</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">r1p</var>, mp_limb_t *<var class="var">rs2p</var>, mp_size_t <var class="var">rs2n</var>, const mp_limb_t *<var class="var">s3p</var>, mp_size_t <var class="var">s3n</var>)</code><a class="copiable-link" href='#index-mpn_005fdivmod'> &para;</a></span></dt>
<dd><p>[This function is obsolete.  Please call <code class="code">mpn_tdiv_qr</code> instead for best
performance.]
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fdivexact_005f1"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_divexact_1</strong> <code class="def-code-arguments">(mp_limb_t * <var class="var">rp</var>, const mp_limb_t * <var class="var">sp</var>, mp_size_t <var class="var">n</var>, mp_limb_t <var class="var">d</var>)</code><a class="copiable-link" href='#index-mpn_005fdivexact_005f1'> &para;</a></span></dt>
<dd><p>Divide {<var class="var">sp</var>, <var class="var">n</var>} by <var class="var">d</var>, expecting it to divide exactly, and
writing the result to {<var class="var">rp</var>, <var class="var">n</var>}. If <var class="var">d</var> doesn&rsquo;t divide
exactly, the value written to {<var class="var">rp</var>, <var class="var">n</var>} is undefined. The areas at
<var class="var">rp</var> and <var class="var">sp</var> have to be identical or completely separate, not
partially overlapping.
</p></dd></dl>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-mpn_005fdivexact_005fby3"><span class="category-def">Macro: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_divexact_by3</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, mp_limb_t *<var class="var">sp</var>, <span class="w-nolinebreak-text">mp_size_t</span>&nbsp;<var class="var">n</var><!-- /@w -->)</code><a class="copiable-link" href='#index-mpn_005fdivexact_005fby3'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpn_005fdivexact_005fby3c"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_divexact_by3c</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, mp_limb_t *<var class="var">sp</var>, <span class="w-nolinebreak-text">mp_size_t</span>&nbsp;<var class="var">n</var><!-- /@w -->, mp_limb_t <var class="var">carry</var>)</code><a class="copiable-link" href='#index-mpn_005fdivexact_005fby3c'> &para;</a></span></dt>
<dd><p>Divide {<var class="var">sp</var>, <var class="var">n</var>} by 3, expecting it to divide exactly, and writing
the result to {<var class="var">rp</var>, <var class="var">n</var>}.  If 3 divides exactly, the return value is
zero and the result is the quotient.  If not, the return value is non-zero and
the result won&rsquo;t be anything useful.
</p>
<p><code class="code">mpn_divexact_by3c</code> takes an initial carry parameter, which can be the
return value from a previous call, so a large calculation can be done piece by
piece from low to high.  <code class="code">mpn_divexact_by3</code> is simply a macro calling
<code class="code">mpn_divexact_by3c</code> with a 0 carry parameter.
</p>
<p>These routines use a multiply-by-inverse and will be faster than
<code class="code">mpn_divrem_1</code> on CPUs with fast multiplication but slow division.
</p>
<p>The source <em class="math">a</em>, result <em class="math">q</em>, size <em class="math">n</em>, initial carry <em class="math">i</em>,
and return value <em class="math">c</em> satisfy <em class="math">c*b^n + a-i = 3*q</em>, where
<em class="math">b=2^GMP_NUMB_BITS</em>.  The
return <em class="math">c</em> is always 0, 1 or 2, and the initial carry <em class="math">i</em> must also
be 0, 1 or 2 (these are both borrows really).  When <em class="math">c=0</em> clearly
<em class="math">q=(a-i)/3</em>.  When <em class="math">c!=0</em>, the remainder <em class="math">(a-i) mod
3</em> is given by <em class="math">3-c</em>, because <em class="math">b &equiv; 1 mod 3</em> (when
<code class="code">mp_bits_per_limb</code> is even, which is always so currently).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fmod_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_mod_1</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">s1n</var>, mp_limb_t <var class="var">s2limb</var>)</code><a class="copiable-link" href='#index-mpn_005fmod_005f1'> &para;</a></span></dt>
<dd><p>Divide {<var class="var">s1p</var>, <var class="var">s1n</var>} by <var class="var">s2limb</var>, and return the remainder.
<var class="var">s1n</var> can be zero.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005flshift"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_lshift</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">sp</var>, mp_size_t <var class="var">n</var>, unsigned int <var class="var">count</var>)</code><a class="copiable-link" href='#index-mpn_005flshift'> &para;</a></span></dt>
<dd><p>Shift {<var class="var">sp</var>, <var class="var">n</var>} left by <var class="var">count</var> bits, and write the result to
{<var class="var">rp</var>, <var class="var">n</var>}.  The bits shifted out at the left are returned in the
least significant <var class="var">count</var> bits of the return value (the rest of the return
value is zero).
</p>
<p><var class="var">count</var> must be in the range 1 to <code class="code">mp_bits_per_limb</code>&minus;1.  The
regions {<var class="var">sp</var>, <var class="var">n</var>} and {<var class="var">rp</var>, <var class="var">n</var>} may overlap, provided
<em class="math"><var class="var">rp</var> &gt;= <var class="var">sp</var></em>.
</p>
<p>This function is written in assembly for most CPUs.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005frshift"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_rshift</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">sp</var>, mp_size_t <var class="var">n</var>, unsigned int <var class="var">count</var>)</code><a class="copiable-link" href='#index-mpn_005frshift'> &para;</a></span></dt>
<dd><p>Shift {<var class="var">sp</var>, <var class="var">n</var>} right by <var class="var">count</var> bits, and write the result to
{<var class="var">rp</var>, <var class="var">n</var>}.  The bits shifted out at the right are returned in the
most significant <var class="var">count</var> bits of the return value (the rest of the return
value is zero).
</p>
<p><var class="var">count</var> must be in the range 1 to <code class="code">mp_bits_per_limb</code>&minus;1.  The
regions {<var class="var">sp</var>, <var class="var">n</var>} and {<var class="var">rp</var>, <var class="var">n</var>} may overlap, provided
<em class="math"><var class="var">rp</var> &lt;= <var class="var">sp</var></em>.
</p>
<p>This function is written in assembly for most CPUs.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fcmp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpn_cmp</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fcmp'> &para;</a></span></dt>
<dd><p>Compare {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">s2p</var>, <var class="var">n</var>} and return a
positive value if <em class="math"><var class="var">s1</var> &gt; <var class="var">s2</var></em>, 0 if they are equal, or a
negative value if <em class="math"><var class="var">s1</var> &lt; <var class="var">s2</var></em>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fzero_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpn_zero_p</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">sp</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fzero_005fp'> &para;</a></span></dt>
<dd><p>Test {<var class="var">sp</var>, <var class="var">n</var>} and return 1 if the operand is zero, 0 otherwise.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fgcd"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_gcd</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, mp_limb_t *<var class="var">xp</var>, mp_size_t <var class="var">xn</var>, mp_limb_t *<var class="var">yp</var>, mp_size_t <var class="var">yn</var>)</code><a class="copiable-link" href='#index-mpn_005fgcd'> &para;</a></span></dt>
<dd><p>Set {<var class="var">rp</var>, <var class="var">retval</var>} to the greatest common divisor of {<var class="var">xp</var>,
<var class="var">xn</var>} and {<var class="var">yp</var>, <var class="var">yn</var>}.  The result can be up to <var class="var">yn</var> limbs,
the return value is the actual number produced.  Both source operands are
destroyed.
</p>
<p>It is required that <em class="math"><var class="var">xn</var> &gt;= <var class="var">yn</var> &gt; 0</em>, the most significant
limb of {<var class="var">yp</var>, <var class="var">yn</var>} must be non-zero, and at least one of
the two operands must be odd.  No overlap is permitted
between {<var class="var">xp</var>, <var class="var">xn</var>} and {<var class="var">yp</var>, <var class="var">yn</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fgcd_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_gcd_1</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">xp</var>, mp_size_t <var class="var">xn</var>, mp_limb_t <var class="var">ylimb</var>)</code><a class="copiable-link" href='#index-mpn_005fgcd_005f1'> &para;</a></span></dt>
<dd><p>Return the greatest common divisor of {<var class="var">xp</var>, <var class="var">xn</var>} and <var class="var">ylimb</var>.
Both operands must be non-zero.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fgcdext"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_gcdext</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">gp</var>, mp_limb_t *<var class="var">sp</var>, mp_size_t *<var class="var">sn</var>, mp_limb_t *<var class="var">up</var>, mp_size_t <var class="var">un</var>, mp_limb_t *<var class="var">vp</var>, mp_size_t <var class="var">vn</var>)</code><a class="copiable-link" href='#index-mpn_005fgcdext'> &para;</a></span></dt>
<dd><p>Let <em class="math"><var class="var">U</var></em> be defined by {<var class="var">up</var>, <var class="var">un</var>} and let <em class="math"><var class="var">V</var></em> be
defined by {<var class="var">vp</var>, <var class="var">vn</var>}.
</p>
<p>Compute the greatest common divisor <em class="math">G</em> of <em class="math">U</em> and <em class="math">V</em>.  Compute
a cofactor <em class="math">S</em> such that <em class="math">G = US + VT</em>.  The second cofactor <var class="var">T</var>
is not computed but can easily be obtained from <em class="math">(<var class="var">G</var> -
<var class="var">U</var>*<var class="var">S</var>) / <var class="var">V</var></em> (the division will be exact).  It is required that
<em class="math"><var class="var">un</var> &gt;= <var class="var">vn</var> &gt; 0</em>, and the most significant
limb of {<var class="var">vp</var>, <var class="var">vn</var>} must be non-zero.
</p>
<p><em class="math">S</em> satisfies <em class="math">S = 1</em> or <em class="math">abs(S) &lt; V / (2 G)</em>. <em class="math">S =
0</em> if and only if <em class="math">V</em> divides <em class="math">U</em> (i.e., <em class="math">G = V</em>).
</p>
<p>Store <em class="math">G</em> at <var class="var">gp</var> and let the return value define its limb count.
Store <em class="math">S</em> at <var class="var">sp</var> and let |*<var class="var">sn</var>| define its limb count.  <em class="math">S</em>
can be negative; when this happens *<var class="var">sn</var> will be negative.  The area at
<var class="var">gp</var> should have room for <var class="var">vn</var> limbs and the area at <var class="var">sp</var> should
have room for <em class="math"><var class="var">vn</var>+1</em> limbs.
</p>
<p>Both source operands are destroyed.
</p>
<p>Compatibility notes: GMP 4.3.0 and 4.3.1 defined <em class="math">S</em> less strictly.
Earlier as well as later GMP releases define <em class="math">S</em> as described here.
GMP releases before GMP 4.3.0 required additional space for both input and output
areas. More precisely, the areas {<var class="var">up</var>, <em class="math"><var class="var">un</var>+1</em>} and
{<var class="var">vp</var>, <em class="math"><var class="var">vn</var>+1</em>} were destroyed (i.e. the operands plus an
extra limb past the end of each), and the areas pointed to by <var class="var">gp</var> and
<var class="var">sp</var> should each have room for <em class="math"><var class="var">un</var>+1</em> limbs.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsqrtrem"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_sqrtrem</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">r1p</var>, mp_limb_t *<var class="var">r2p</var>, const mp_limb_t *<var class="var">sp</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fsqrtrem'> &para;</a></span></dt>
<dd><p>Compute the square root of {<var class="var">sp</var>, <var class="var">n</var>} and put the result at
{<var class="var">r1p</var>, <em class="math">ceil(<var class="var">n</var>/2)</em>} and the remainder at {<var class="var">r2p</var>,
<var class="var">retval</var>}.  <var class="var">r2p</var> needs space for <var class="var">n</var> limbs, but the return value
indicates how many are produced.
</p>
<p>The most significant limb of {<var class="var">sp</var>, <var class="var">n</var>} must be non-zero.  The
areas {<var class="var">r1p</var>, <em class="math">ceil(<var class="var">n</var>/2)</em>} and {<var class="var">sp</var>, <var class="var">n</var>} must
be completely separate.  The areas {<var class="var">r2p</var>, <var class="var">n</var>} and {<var class="var">sp</var>,
<var class="var">n</var>} must be either identical or completely separate.
</p>
<p>If the remainder is not wanted then <var class="var">r2p</var> can be <code class="code">NULL</code>, and in this
case the return value is zero or non-zero according to whether the remainder
would have been zero or non-zero.
</p>
<p>A return value of zero indicates a perfect square.  See also
<code class="code">mpn_perfect_square_p</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsizeinbase"><span class="category-def">Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">mpn_sizeinbase</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">xp</var>, mp_size_t <var class="var">n</var>, int <var class="var">base</var>)</code><a class="copiable-link" href='#index-mpn_005fsizeinbase'> &para;</a></span></dt>
<dd><p>Return the size of {<var class="var">xp</var>,<var class="var">n</var>} measured in number of digits in the
given <var class="var">base</var>.  <var class="var">base</var> can vary from 2 to 62.  Requires <em class="math"><var class="var">n</var> &gt; 0</em>
and <em class="math"><var class="var">xp</var>[<var class="var">n</var>-1] &gt; 0</em>.  The result will be either exact or
1 too big.  If <var class="var">base</var> is a power of 2, the result is always exact.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fget_005fstr"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_get_str</strong> <code class="def-code-arguments">(unsigned char *<var class="var">str</var>, int <var class="var">base</var>, mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">s1n</var>)</code><a class="copiable-link" href='#index-mpn_005fget_005fstr'> &para;</a></span></dt>
<dd><p>Convert {<var class="var">s1p</var>, <var class="var">s1n</var>} to a raw unsigned char array at <var class="var">str</var> in
base <var class="var">base</var>, and return the number of characters produced.  There may be
leading zeros in the string.  The string is not in ASCII; to convert it to
printable format, add the ASCII codes for &lsquo;<samp class="samp">0</samp>&rsquo; or &lsquo;<samp class="samp">A</samp>&rsquo;, depending on
the base and range.  <var class="var">base</var> can vary from 2 to 256.
</p>
<p>The most significant limb of the input {<var class="var">s1p</var>, <var class="var">s1n</var>} must be
non-zero.  The input {<var class="var">s1p</var>, <var class="var">s1n</var>} is clobbered, except when
<var class="var">base</var> is a power of 2, in which case it&rsquo;s unchanged.
</p>
<p>The area at <var class="var">str</var> has to have space for the largest possible number
represented by a <var class="var">s1n</var> long limb array, plus one extra character.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fset_005fstr"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_set_str</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const unsigned char *<var class="var">str</var>, size_t <var class="var">strsize</var>, int <var class="var">base</var>)</code><a class="copiable-link" href='#index-mpn_005fset_005fstr'> &para;</a></span></dt>
<dd><p>Convert bytes {<var class="var">str</var>,<var class="var">strsize</var>} in the given <var class="var">base</var> to limbs at
<var class="var">rp</var>.
</p>
<p><em class="math"><var class="var">str</var>[0]</em> is the most significant input byte and
<em class="math"><var class="var">str</var>[<var class="var">strsize</var>-1]</em> is the least significant input byte.  Each
byte should be a value in the range 0 to <em class="math"><var class="var">base</var>-1</em>, not an ASCII
character.  <var class="var">base</var> can vary from 2 to 256.
</p>
<p>The converted value is {<var class="var">rp</var>,<var class="var">rn</var>} where <var class="var">rn</var> is the return
value.  If the most significant input byte <em class="math"><var class="var">str</var>[0]</em> is non-zero,
then <em class="math"><var class="var">rp</var>[<var class="var">rn</var>-1]</em> will be non-zero, else
<em class="math"><var class="var">rp</var>[<var class="var">rn</var>-1]</em> and some number of subsequent limbs may be zero.
</p>
<p>The area at <var class="var">rp</var> has to have space for the largest possible number with
<var class="var">strsize</var> digits in the chosen base, plus one extra limb.
</p>
<p>The input must have at least one byte, and no overlap is permitted between
{<var class="var">str</var>,<var class="var">strsize</var>} and the result at <var class="var">rp</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fscan0"><span class="category-def">Function: </span><span><code class="def-type">mp_bitcnt_t</code> <strong class="def-name">mpn_scan0</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">s1p</var>, mp_bitcnt_t <var class="var">bit</var>)</code><a class="copiable-link" href='#index-mpn_005fscan0'> &para;</a></span></dt>
<dd><p>Scan <var class="var">s1p</var> from bit position <var class="var">bit</var> for the next clear bit.
</p>
<p>It is required that there be a clear bit within the area at <var class="var">s1p</var> at or
beyond bit position <var class="var">bit</var>, so that the function has something to return.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fscan1"><span class="category-def">Function: </span><span><code class="def-type">mp_bitcnt_t</code> <strong class="def-name">mpn_scan1</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">s1p</var>, mp_bitcnt_t <var class="var">bit</var>)</code><a class="copiable-link" href='#index-mpn_005fscan1'> &para;</a></span></dt>
<dd><p>Scan <var class="var">s1p</var> from bit position <var class="var">bit</var> for the next set bit.
</p>
<p>It is required that there be a set bit within the area at <var class="var">s1p</var> at or
beyond bit position <var class="var">bit</var>, so that the function has something to return.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005frandom"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_random</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">r1p</var>, mp_size_t <var class="var">r1n</var>)</code><a class="copiable-link" href='#index-mpn_005frandom'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005frandom2"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_random2</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">r1p</var>, mp_size_t <var class="var">r1n</var>)</code><a class="copiable-link" href='#index-mpn_005frandom2'> &para;</a></span></dt>
<dd><p>Generate a random number of length <var class="var">r1n</var> and store it at <var class="var">r1p</var>.  The
most significant limb is always non-zero.  <code class="code">mpn_random</code> generates
uniformly distributed limb data, <code class="code">mpn_random2</code> generates long strings of
zeros and ones in the binary representation.
</p>
<p><code class="code">mpn_random2</code> is intended for testing the correctness of the <code class="code">mpn</code>
routines.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fpopcount"><span class="category-def">Function: </span><span><code class="def-type">mp_bitcnt_t</code> <strong class="def-name">mpn_popcount</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fpopcount'> &para;</a></span></dt>
<dd><p>Count the number of set bits in {<var class="var">s1p</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fhamdist"><span class="category-def">Function: </span><span><code class="def-type">mp_bitcnt_t</code> <strong class="def-name">mpn_hamdist</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fhamdist'> &para;</a></span></dt>
<dd><p>Compute the hamming distance between {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">s2p</var>,
<var class="var">n</var>}, which is the number of bit positions where the two operands have
different bit values.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fperfect_005fsquare_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpn_perfect_square_p</strong> <code class="def-code-arguments">(const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fperfect_005fsquare_005fp'> &para;</a></span></dt>
<dd><p>Return non-zero iff {<var class="var">s1p</var>, <var class="var">n</var>} is a perfect square.
The most significant limb of the input {<var class="var">s1p</var>, <var class="var">n</var>} must be
non-zero.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fand_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_and_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fand_005fn'> &para;</a></span></dt>
<dd><p>Perform the bitwise logical and of {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">s2p</var>,
<var class="var">n</var>}, and write the result to {<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fior_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_ior_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fior_005fn'> &para;</a></span></dt>
<dd><p>Perform the bitwise logical inclusive or of {<var class="var">s1p</var>, <var class="var">n</var>} and
{<var class="var">s2p</var>, <var class="var">n</var>}, and write the result to {<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fxor_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_xor_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fxor_005fn'> &para;</a></span></dt>
<dd><p>Perform the bitwise logical exclusive or of {<var class="var">s1p</var>, <var class="var">n</var>} and
{<var class="var">s2p</var>, <var class="var">n</var>}, and write the result to {<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fandn_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_andn_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fandn_005fn'> &para;</a></span></dt>
<dd><p>Perform the bitwise logical and of {<var class="var">s1p</var>, <var class="var">n</var>} and the bitwise
complement of {<var class="var">s2p</var>, <var class="var">n</var>}, and write the result to {<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fiorn_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_iorn_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fiorn_005fn'> &para;</a></span></dt>
<dd><p>Perform the bitwise logical inclusive or of {<var class="var">s1p</var>, <var class="var">n</var>} and the bitwise
complement of {<var class="var">s2p</var>, <var class="var">n</var>}, and write the result to {<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fnand_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_nand_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fnand_005fn'> &para;</a></span></dt>
<dd><p>Perform the bitwise logical and of {<var class="var">s1p</var>, <var class="var">n</var>} and {<var class="var">s2p</var>,
<var class="var">n</var>}, and write the bitwise complement of the result to {<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fnior_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_nior_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fnior_005fn'> &para;</a></span></dt>
<dd><p>Perform the bitwise logical inclusive or of {<var class="var">s1p</var>, <var class="var">n</var>} and
{<var class="var">s2p</var>, <var class="var">n</var>}, and write the bitwise complement of the result to
{<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fxnor_005fn"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_xnor_n</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fxnor_005fn'> &para;</a></span></dt>
<dd><p>Perform the bitwise logical exclusive or of {<var class="var">s1p</var>, <var class="var">n</var>} and
{<var class="var">s2p</var>, <var class="var">n</var>}, and write the bitwise complement of the result to
{<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fcom"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_com</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">sp</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fcom'> &para;</a></span></dt>
<dd><p>Perform the bitwise complement of {<var class="var">sp</var>, <var class="var">n</var>}, and write the result
to {<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fcopyi"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_copyi</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fcopyi'> &para;</a></span></dt>
<dd><p>Copy from {<var class="var">s1p</var>, <var class="var">n</var>} to {<var class="var">rp</var>, <var class="var">n</var>}, increasingly.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fcopyd"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_copyd</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fcopyd'> &para;</a></span></dt>
<dd><p>Copy from {<var class="var">s1p</var>, <var class="var">n</var>} to {<var class="var">rp</var>, <var class="var">n</var>}, decreasingly.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fzero"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_zero</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fzero'> &para;</a></span></dt>
<dd><p>Zero {<var class="var">rp</var>, <var class="var">n</var>}.
</p></dd></dl>
<br>
<ul class="mini-toc">
<li><a href="#Low_002dlevel-functions-for-cryptography" accesskey="1">Low-level functions for cryptography</a></li>
<li><a href="#Nails" accesskey="2">Nails</a></li>
</ul>
<div class="section-level-extent" id="Low_002dlevel-functions-for-cryptography">
<h3 class="section">8.1 Low-level functions for cryptography</h3>
<a class="index-entry-id" id="index-Low_002dlevel-functions-for-cryptography"></a>
<a class="index-entry-id" id="index-Cryptography-functions_002c-low_002dlevel"></a>
<p>The functions prefixed with <code class="code">mpn_sec_</code> and <code class="code">mpn_cnd_</code> are designed to
perform the exact same low-level operations and have the same cache access
patterns for any two same-size arguments, assuming that function arguments are
placed at the same position and that the machine state is identical upon
function entry.  These functions are intended for cryptographic purposes, where
resilience to side-channel attacks is desired.
</p>
<p>These functions are less efficient than their &ldquo;leaky&rdquo; counterparts; their
performance for operands of the sizes typically used for cryptographic
applications is between 15% and 100% worse.  For larger operands, these
functions might be inadequate, since they rely on asymptotically elementary
algorithms.
</p>
<p>These functions do not make any explicit allocations.  Those of these functions
that need scratch space accept a scratch space operand.  This convention allows
callers to keep sensitive data in designated memory areas.  Note however that
compilers may choose to spill scalar values used within these functions to
their stack frame and that such scalars may contain sensitive data.
</p>
<p>In addition to these specially crafted functions, the following <code class="code">mpn</code>
functions are naturally side-channel resistant: <code class="code">mpn_add_n</code>,
<code class="code">mpn_sub_n</code>, <code class="code">mpn_lshift</code>, <code class="code">mpn_rshift</code>, <code class="code">mpn_zero</code>,
<code class="code">mpn_copyi</code>, <code class="code">mpn_copyd</code>, <code class="code">mpn_com</code>, and the logical function
(<code class="code">mpn_and_n</code>, etc).
</p>
<p>There are some exceptions from the side-channel resilience: (1) Some assembly
implementations of <code class="code">mpn_lshift</code> identify shift-by-one as a special case.
This is a problem iff the shift count is a function of sensitive data.  (2)
Alpha ev6 and Pentium4 using 64-bit limbs have leaky <code class="code">mpn_add_n</code> and
<code class="code">mpn_sub_n</code>.  (3) Alpha ev6 has a leaky <code class="code">mpn_mul_1</code> which also makes
<code class="code">mpn_sec_mul</code> on those systems unsafe.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fcnd_005fadd_005fn"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_cnd_add_n</strong> <code class="def-code-arguments">(mp_limb_t <var class="var">cnd</var>, mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fcnd_005fadd_005fn'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005fcnd_005fsub_005fn"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_cnd_sub_n</strong> <code class="def-code-arguments">(mp_limb_t <var class="var">cnd</var>, mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">s1p</var>, const mp_limb_t *<var class="var">s2p</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fcnd_005fsub_005fn'> &para;</a></span></dt>
<dd><p>These functions do conditional addition and subtraction.  If <var class="var">cnd</var> is
non-zero, they produce the same result as a regular <code class="code">mpn_add_n</code> or
<code class="code">mpn_sub_n</code>, and if <var class="var">cnd</var> is zero, they copy {<var class="var">s1p</var>,<var class="var">n</var>} to
the result area and return zero.  The functions are designed to have timing and
memory access patterns depending only on size and location of the data areas,
but independent of the condition <var class="var">cnd</var>.  Like for <code class="code">mpn_add_n</code> and
<code class="code">mpn_sub_n</code>, on most machines, the timing will also be independent of the
actual limb values.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsec_005fadd_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_sec_add_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">ap</var>, mp_size_t <var class="var">n</var>, mp_limb_t <var class="var">b</var>, mp_limb_t *<var class="var">tp</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fadd_005f1'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005fsec_005fsub_005f1"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_sec_sub_1</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">ap</var>, mp_size_t <var class="var">n</var>, mp_limb_t <var class="var">b</var>, mp_limb_t *<var class="var">tp</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fsub_005f1'> &para;</a></span></dt>
<dd><p>Set <var class="var">R</var> to <var class="var">A</var> + <var class="var">b</var> or <var class="var">A</var> - <var class="var">b</var>, respectively, where
<var class="var">R</var> = {<var class="var">rp</var>,<var class="var">n</var>}, <var class="var">A</var> = {<var class="var">ap</var>,<var class="var">n</var>}, and <var class="var">b</var> is
a single limb. Returns carry.
</p>
<p>These functions take <em class="math">O(N)</em> time, unlike the leaky functions
<code class="code">mpn_add_1</code> which are <em class="math">O(1)</em> on average. They require scratch space
of <code class="code">mpn_sec_add_1_itch(<var class="var">n</var>)</code> and <code class="code">mpn_sec_sub_1_itch(<var class="var">n</var>)</code>
limbs, respectively, to be passed in the <var class="var">tp</var> parameter. The scratch space
requirements are guaranteed to be at most <var class="var">n</var> limbs, and increase
monotonously in the operand size.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fcnd_005fswap"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_cnd_swap</strong> <code class="def-code-arguments">(mp_limb_t <var class="var">cnd</var>, volatile mp_limb_t *<var class="var">ap</var>, volatile mp_limb_t *<var class="var">bp</var>, mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fcnd_005fswap'> &para;</a></span></dt>
<dd><p>If <var class="var">cnd</var> is non-zero, swaps the contents of the areas {<var class="var">ap</var>,<var class="var">n</var>}
and {<var class="var">bp</var>,<var class="var">n</var>}. Otherwise, the areas are left unmodified.
Implemented using logical operations on the limbs, with the same memory
accesses independent of the value of <var class="var">cnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsec_005fmul"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_sec_mul</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">ap</var>, mp_size_t <var class="var">an</var>, const mp_limb_t *<var class="var">bp</var>, mp_size_t <var class="var">bn</var>, mp_limb_t *<var class="var">tp</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fmul'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005fsec_005fmul_005fitch"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_sec_mul_itch</strong> <code class="def-code-arguments">(mp_size_t <var class="var">an</var>, mp_size_t <var class="var">bn</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fmul_005fitch'> &para;</a></span></dt>
<dd><p>Set <var class="var">R</var> to <em class="math">A * B</em>, where <var class="var">A</var> = {<var class="var">ap</var>,<var class="var">an</var>},
<var class="var">B</var> = {<var class="var">bp</var>,<var class="var">bn</var>}, and <var class="var">R</var> =
{<var class="var">rp</var>,<em class="math"><var class="var">an</var>+<var class="var">bn</var></em>}.
</p>
<p>It is required that <em class="math"><var class="var">an</var> &gt;= <var class="var">bn</var> &gt; 0</em>.
</p>
<p>No overlapping between <var class="var">R</var> and the input operands is allowed.  For
<em class="math"><var class="var">A</var> = <var class="var">B</var></em>, use <code class="code">mpn_sec_sqr</code> for optimal performance.
</p>
<p>This function requires scratch space of <code class="code">mpn_sec_mul_itch(<var class="var">an</var>,
<var class="var">bn</var>)</code> limbs to be passed in the <var class="var">tp</var> parameter.  The scratch space
requirements are guaranteed to increase monotonously in the operand sizes.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsec_005fsqr"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_sec_sqr</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">ap</var>, mp_size_t <var class="var">an</var>, mp_limb_t *<var class="var">tp</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fsqr'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005fsec_005fsqr_005fitch"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_sec_sqr_itch</strong> <code class="def-code-arguments">(mp_size_t <var class="var">an</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fsqr_005fitch'> &para;</a></span></dt>
<dd><p>Set <var class="var">R</var> to <em class="math">A^2</em>, where <var class="var">A</var> = {<var class="var">ap</var>,<var class="var">an</var>}, and <var class="var">R</var> =
{<var class="var">rp</var>,<em class="math">2<var class="var">an</var></em>}.
</p>
<p>It is required that <em class="math"><var class="var">an</var> &gt; 0</em>.
</p>
<p>No overlapping between <var class="var">R</var> and the input operands is allowed.
</p>
<p>This function requires scratch space of <code class="code">mpn_sec_sqr_itch(<var class="var">an</var>)</code> limbs
to be passed in the <var class="var">tp</var> parameter.  The scratch space requirements are
guaranteed to increase monotonously in the operand size.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsec_005fpowm"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_sec_powm</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">bp</var>, mp_size_t <var class="var">bn</var>, const mp_limb_t *<var class="var">ep</var>, mp_bitcnt_t <var class="var">enb</var>,  const mp_limb_t *<var class="var">mp</var>, mp_size_t <var class="var">n</var>, mp_limb_t *<var class="var">tp</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fpowm'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005fsec_005fpowm_005fitch"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_sec_powm_itch</strong> <code class="def-code-arguments">(mp_size_t <var class="var">bn</var>, mp_bitcnt_t <var class="var">enb</var>, size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fpowm_005fitch'> &para;</a></span></dt>
<dd><p>Set <var class="var">R</var> to <em class="math">(<var class="var">B</var> raised to <var class="var">E</var>) modulo
<var class="var">M</var></em>, where <var class="var">R</var> = {<var class="var">rp</var>,<var class="var">n</var>}, <var class="var">M</var> = {<var class="var">mp</var>,<var class="var">n</var>},
and <var class="var">E</var> = {<var class="var">ep</var>,<em class="math">ceil(<var class="var">enb</var> /
<code class="code">GMP_NUMB_BITS</code>)</em>}.
</p>
<p>It is required that <em class="math"><var class="var">B</var> &gt; 0</em>, that <em class="math"><var class="var">M</var> &gt; 0</em> is odd, and
that <em class="math"><var class="var">E</var> &lt; 2^<var class="var">enb</var></em>, with <em class="math"><var class="var">enb</var> &gt; 0</em>.
</p>
<p>No overlapping between <var class="var">R</var> and the input operands is allowed.
</p>
<p>This function requires scratch space of <code class="code">mpn_sec_powm_itch(<var class="var">bn</var>,
<var class="var">enb</var>, <var class="var">n</var>)</code> limbs to be passed in the <var class="var">tp</var> parameter.  The scratch
space requirements are guaranteed to increase monotonously in the operand
sizes.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsec_005ftabselect"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_sec_tabselect</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, const mp_limb_t *<var class="var">tab</var>, mp_size_t <var class="var">n</var>, mp_size_t <var class="var">nents</var>, mp_size_t <var class="var">which</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005ftabselect'> &para;</a></span></dt>
<dd><p>Select entry <var class="var">which</var> from table <var class="var">tab</var>, which has <var class="var">nents</var> entries, each <var class="var">n</var>
limbs.  Store the selected entry at <var class="var">rp</var>.
</p>
<p>This function reads the entire table to avoid side-channel information leaks.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsec_005fdiv_005fqr"><span class="category-def">Function: </span><span><code class="def-type">mp_limb_t</code> <strong class="def-name">mpn_sec_div_qr</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">qp</var>, mp_limb_t *<var class="var">np</var>, mp_size_t <var class="var">nn</var>, const mp_limb_t *<var class="var">dp</var>, mp_size_t <var class="var">dn</var>, mp_limb_t *<var class="var">tp</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fdiv_005fqr'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005fsec_005fdiv_005fqr_005fitch"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_sec_div_qr_itch</strong> <code class="def-code-arguments">(mp_size_t <var class="var">nn</var>, mp_size_t <var class="var">dn</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fdiv_005fqr_005fitch'> &para;</a></span></dt>
<dd>
<p>Set <var class="var">Q</var> to <em class="math">the truncated quotient
<var class="var">N</var> / <var class="var">D</var></em> and <var class="var">R</var> to <em class="math"><var class="var">N</var> modulo
<var class="var">D</var></em>, where <var class="var">N</var> = {<var class="var">np</var>,<var class="var">nn</var>}, <var class="var">D</var> =
{<var class="var">dp</var>,<var class="var">dn</var>}, <var class="var">Q</var>&rsquo;s most significant limb is the function return
value and the remaining limbs are {<var class="var">qp</var>,<var class="var">nn-dn</var>}, and <var class="var">R</var> =
{<var class="var">np</var>,<var class="var">dn</var>}.
</p>
<p>It is required that <em class="math"><var class="var">nn</var> &gt;= <var class="var">dn</var> &gt;= 1</em>, and that
<em class="math"><var class="var">dp</var>[<var class="var">dn</var>-1] != 0</em>.  This does not
imply that <em class="math"><var class="var">N</var> &gt;= <var class="var">D</var></em> since <var class="var">N</var> might be zero-padded.
</p>
<p>Note the overlapping between <var class="var">N</var> and <var class="var">R</var>.  No other operand overlapping
is allowed.  The entire space occupied by <var class="var">N</var> is overwritten.
</p>
<p>This function requires scratch space of <code class="code">mpn_sec_div_qr_itch(<var class="var">nn</var>,
<var class="var">dn</var>)</code> limbs to be passed in the <var class="var">tp</var> parameter.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsec_005fdiv_005fr"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpn_sec_div_r</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">np</var>, mp_size_t <var class="var">nn</var>, const mp_limb_t *<var class="var">dp</var>, mp_size_t <var class="var">dn</var>, mp_limb_t *<var class="var">tp</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fdiv_005fr'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005fsec_005fdiv_005fr_005fitch"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_sec_div_r_itch</strong> <code class="def-code-arguments">(mp_size_t <var class="var">nn</var>, mp_size_t <var class="var">dn</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005fdiv_005fr_005fitch'> &para;</a></span></dt>
<dd>
<p>Set <var class="var">R</var> to <em class="math"><var class="var">N</var> modulo <var class="var">D</var></em>, where <var class="var">N</var>
= {<var class="var">np</var>,<var class="var">nn</var>}, <var class="var">D</var> = {<var class="var">dp</var>,<var class="var">dn</var>}, and <var class="var">R</var> =
{<var class="var">np</var>,<var class="var">dn</var>}.
</p>
<p>It is required that <em class="math"><var class="var">nn</var> &gt;= <var class="var">dn</var> &gt;= 1</em>, and that
<em class="math"><var class="var">dp</var>[<var class="var">dn</var>-1] != 0</em>.  This does not
imply that <em class="math"><var class="var">N</var> &gt;= <var class="var">D</var></em> since <var class="var">N</var> might be zero-padded.
</p>
<p>Note the overlapping between <var class="var">N</var> and <var class="var">R</var>.  No other operand overlapping
is allowed.  The entire space occupied by <var class="var">N</var> is overwritten.
</p>
<p>This function requires scratch space of <code class="code">mpn_sec_div_r_itch(<var class="var">nn</var>,
<var class="var">dn</var>)</code> limbs to be passed in the <var class="var">tp</var> parameter.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpn_005fsec_005finvert"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpn_sec_invert</strong> <code class="def-code-arguments">(mp_limb_t *<var class="var">rp</var>, mp_limb_t *<var class="var">ap</var>, const mp_limb_t *<var class="var">mp</var>, mp_size_t <var class="var">n</var>, mp_bitcnt_t <var class="var">nbcnt</var>, mp_limb_t *<var class="var">tp</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005finvert'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpn_005fsec_005finvert_005fitch"><span class="category-def">Function: </span><span><code class="def-type">mp_size_t</code> <strong class="def-name">mpn_sec_invert_itch</strong> <code class="def-code-arguments">(mp_size_t <var class="var">n</var>)</code><a class="copiable-link" href='#index-mpn_005fsec_005finvert_005fitch'> &para;</a></span></dt>
<dd><p>Set <var class="var">R</var> to <em class="math">the inverse of <var class="var">A</var> modulo
<var class="var">M</var></em>, where <var class="var">R</var> = {<var class="var">rp</var>,<var class="var">n</var>}, <var class="var">A</var> = {<var class="var">ap</var>,<var class="var">n</var>},
and <var class="var">M</var> = {<var class="var">mp</var>,<var class="var">n</var>}.  <strong class="strong">This function&rsquo;s interface is
preliminary.</strong>
</p>
<p>If an inverse exists, return 1, otherwise return 0 and leave <var class="var">R</var>
undefined. In either case, the input <var class="var">A</var> is destroyed.
</p>
<p>It is required that <var class="var">M</var> is odd, and that <em class="math"><var class="var">nbcnt</var> &gt;=
ceil(log(<var class="var">A</var>+1)) + ceil(log(<var class="var">M</var>+1))</em>.  A safe choice is
<em class="math"><var class="var">nbcnt</var> = 2
* <var class="var">n</var> * GMP_NUMB_BITS</em>, but a smaller value might improve
performance if <var class="var">M</var> or <var class="var">A</var> are known to have leading zero bits.
</p>
<p>This function requires scratch space of <code class="code">mpn_sec_invert_itch(<var class="var">n</var>)</code>
limbs to be passed in the <var class="var">tp</var> parameter.
</p></dd></dl>
<br>
</div>
<div class="section-level-extent" id="Nails">
<h3 class="section">8.2 Nails</h3>
<a class="index-entry-id" id="index-Nails"></a>
<p><strong class="strong">Everything in this section is highly experimental and may disappear or
be subject to incompatible changes in a future version of GMP.</strong>
</p>
<p>Nails are an experimental feature whereby a few bits are left unused at the
top of each <code class="code">mp_limb_t</code>.  This can significantly improve carry handling
on some processors.
</p>
<p>All the <code class="code">mpn</code> functions accepting limb data will expect the nail bits to
be zero on entry, and will return data with the nails similarly all zero.
This applies both to limb vectors and to single limb arguments.
</p>
<p>Nails can be enabled by configuring with &lsquo;<samp class="samp">--enable-nails</samp>&rsquo;.  By default
the number of bits will be chosen according to what suits the host processor,
but a particular number can be selected with &lsquo;<samp class="samp">--enable-nails=N</samp>&rsquo;.
</p>
<p>At the mpn level, a nail build is neither source nor binary compatible with a
non-nail build, strictly speaking.  But programs acting on limbs only through
the mpn functions are likely to work equally well with either build, and
judicious use of the definitions below should make any program compatible with
either build, at the source level.
</p>
<p>For the higher level routines, meaning <code class="code">mpz</code> etc, a nail build should be
fully source and binary compatible with a non-nail build.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-GMP_005fNAIL_005fBITS"><span class="category-def">Macro: </span><span><strong class="def-name">GMP_NAIL_BITS</strong><a class="copiable-link" href='#index-GMP_005fNAIL_005fBITS'> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-GMP_005fNUMB_005fBITS"><span class="category-def">Macro: </span><span><strong class="def-name">GMP_NUMB_BITS</strong><a class="copiable-link" href='#index-GMP_005fNUMB_005fBITS'> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-GMP_005fLIMB_005fBITS"><span class="category-def">Macro: </span><span><strong class="def-name">GMP_LIMB_BITS</strong><a class="copiable-link" href='#index-GMP_005fLIMB_005fBITS'> &para;</a></span></dt>
<dd><p><code class="code">GMP_NAIL_BITS</code> is the number of nail bits, or 0 when nails are not in
use.  <code class="code">GMP_NUMB_BITS</code> is the number of data bits in a limb.
<code class="code">GMP_LIMB_BITS</code> is the total number of bits in an <code class="code">mp_limb_t</code>.  In
all cases
</p>
<div class="example">
<pre class="example-preformatted">GMP_LIMB_BITS == GMP_NAIL_BITS + GMP_NUMB_BITS
</pre></div>
</dd></dl>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-GMP_005fNAIL_005fMASK"><span class="category-def">Macro: </span><span><strong class="def-name">GMP_NAIL_MASK</strong><a class="copiable-link" href='#index-GMP_005fNAIL_005fMASK'> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-GMP_005fNUMB_005fMASK"><span class="category-def">Macro: </span><span><strong class="def-name">GMP_NUMB_MASK</strong><a class="copiable-link" href='#index-GMP_005fNUMB_005fMASK'> &para;</a></span></dt>
<dd><p>Bit masks for the nail and number parts of a limb.  <code class="code">GMP_NAIL_MASK</code> is 0
when nails are not in use.
</p>
<p><code class="code">GMP_NAIL_MASK</code> is not often needed, since the nail part can be obtained
with <code class="code">x &gt;&gt; GMP_NUMB_BITS</code>, and that means one less large constant, which
can help various RISC chips.
</p></dd></dl>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-GMP_005fNUMB_005fMAX"><span class="category-def">Macro: </span><span><strong class="def-name">GMP_NUMB_MAX</strong><a class="copiable-link" href='#index-GMP_005fNUMB_005fMAX'> &para;</a></span></dt>
<dd><p>The maximum value that can be stored in the number part of a limb.  This is
the same as <code class="code">GMP_NUMB_MASK</code>, but can be used for clarity when doing
comparisons rather than bit-wise operations.
</p></dd></dl>
<p>The term &ldquo;nails&rdquo; comes from finger or toe nails, which are at the ends of a
limb (arm or leg).  &ldquo;numb&rdquo; is short for number, but is also how the
developers felt after trying for a long time to come up with sensible names
for these things.
</p>
<p>In the future (the distant future most likely) a non-zero nail might be
permitted, giving non-unique representations for numbers in a limb vector.
This would help vector processors since carries would only ever need to
propagate one or two limbs.
</p>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="constant.Random_Number_Functions.html#Random-Number-Functions" accesskey="n" rel="next">Random Number Functions</a>, Previous: <a href="constant.Floating_point_Functions.html#Floating_002dpoint-Functions" accesskey="p" rel="prev">Floating-point Functions</a>, Up: <a href="index.html#start" accesskey="u" rel="up">GNU MP</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
