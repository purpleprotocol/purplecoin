<div class="chapter-level-extent" id="MPFR-Interface">
<div class="nav-panel">
<p>
Next: <a href="constant.API_Compatibility.html#API-Compatibility" accesskey="n" rel="next">API Compatibility</a>, Previous: <a href="constant.MPFR_Basics.html#MPFR-Basics" accesskey="p" rel="prev">MPFR Basics</a>, Up: <a href="index.html#start" accesskey="u" rel="up">GNU MPFR</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="MPFR-Interface-1">5 MPFR Interface</h2>
<a class="index-entry-id" id="index-Floating_002dpoint-functions"></a>
<p>The floating-point functions expect arguments of type <code class="code">mpfr_t</code>.
</p>
<p>The MPFR floating-point functions have an interface that is similar to the
GNU MP
functions.  The function prefix for floating-point operations is <code class="code">mpfr_</code>.
</p>
<p>The user has
to specify the precision of each variable.  A computation that assigns a
variable will take place with the precision of the assigned variable; the
cost of that computation should not depend on the
precision of variables used as input (on average).
</p>
<a class="index-entry-id" id="index-Precision-1"></a>
<p>The semantics of a calculation in MPFR is specified as follows: Compute the
requested operation exactly (with &ldquo;infinite accuracy&rdquo;), and round the result
to the precision of the destination variable, with the given rounding mode.
The MPFR floating-point functions are intended to be a smooth extension
of the IEEE&nbsp;754 arithmetic. The results obtained on a given computer are
identical to those obtained on a computer with a different word size,
or with a different compiler or operating system.
</p>
<a class="index-entry-id" id="index-Accuracy"></a>
<p>MPFR <em class="emph">does not keep track</em> of the accuracy of a computation. This is
left to the user or to a higher layer (for example, the MPFI library for
interval arithmetic). As a consequence, if two variables are used to store
only a few significant bits, and their product is stored in a variable with a
large precision, then MPFR will still compute the result with full precision.
</p>
<p>The value of the standard C macro <code class="code">errno</code> may be set to non-zero after
calling any MPFR function or macro, whether or not there is an error. Except
when documented, MPFR will not set <code class="code">errno</code>, but functions called by the
MPFR code (libc functions, memory allocator, etc.) may do so.
</p>
<ul class="mini-toc">
<li><a href="#Initialization-Functions" accesskey="1">Initialization Functions</a></li>
<li><a href="#Assignment-Functions" accesskey="2">Assignment Functions</a></li>
<li><a href="#Combined-Initialization-and-Assignment-Functions" accesskey="3">Combined Initialization and Assignment Functions</a></li>
<li><a href="#Conversion-Functions" accesskey="4">Conversion Functions</a></li>
<li><a href="#Arithmetic-Functions" accesskey="5">Arithmetic Functions</a></li>
<li><a href="#Comparison-Functions" accesskey="6">Comparison Functions</a></li>
<li><a href="#Transcendental-Functions" accesskey="7">Transcendental Functions</a></li>
<li><a href="#Input-and-Output-Functions" accesskey="8">Input and Output Functions</a></li>
<li><a href="#Formatted-Output-Functions" accesskey="9">Formatted Output Functions</a></li>
<li><a href="#Integer-and-Remainder-Related-Functions">Integer and Remainder Related Functions</a></li>
<li><a href="#Rounding_002dRelated-Functions">Rounding-Related Functions</a></li>
<li><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#Exception-Related-Functions">Exception Related Functions</a></li>
<li><a href="#Memory-Handling-Functions">Memory Handling Functions</a></li>
<li><a href="#Compatibility-with-MPF">Compatibility With MPF</a></li>
<li><a href="#Custom-Interface">Custom Interface</a></li>
<li><a href="#Internals">Internals</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Initialization-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Assignment-Functions" accesskey="n" rel="next">Assignment Functions</a>, Previous: <a href="#MPFR-Interface" accesskey="p" rel="prev">MPFR Interface</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Initialization-functions"></a>
<h3 class="section" id="Initialization-Functions-1">5.1 Initialization Functions</h3>
<p>An <code class="code">mpfr_t</code> object must be initialized before storing the first value in
it.  The functions <code class="code">mpfr_init</code> and <code class="code">mpfr_init2</code> are used for that
purpose.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005finit2"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_init2</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_prec_t <var class="var">prec</var>)</code><a class="copiable-link" href='#index-mpfr_005finit2'> &para;</a></span></dt>
<dd><p>Initialize <var class="var">x</var>, set its precision to be <strong class="strong">exactly</strong>
<var class="var">prec</var> bits and its value to NaN. (Warning: the corresponding
MPF function initializes to zero instead.)
</p>
<p>Normally, a variable should be initialized once only or at
least be cleared, using <code class="code">mpfr_clear</code>, between initializations.
To change the precision of a variable that has already been initialized,
use <code class="code">mpfr_set_prec</code> or <code class="code">mpfr_prec_round</code>; note that if the
precision is decreased, the unused memory will not be freed, so that
it may be wise to choose a large enough initial precision in order to
avoid reallocations.
The precision <var class="var">prec</var> must be an integer between <code class="code">MPFR_PREC_MIN</code> and
<code class="code">MPFR_PREC_MAX</code> (otherwise the behavior is undefined).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005finits2"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_inits2</strong> <code class="def-code-arguments">(mpfr_prec_t <var class="var">prec</var>, mpfr_t <var class="var">x</var>, ...)</code><a class="copiable-link" href='#index-mpfr_005finits2'> &para;</a></span></dt>
<dd><p>Initialize all the <code class="code">mpfr_t</code> variables of the given variable
argument <code class="code">va_list</code>, set their precision to be <strong class="strong">exactly</strong>
<var class="var">prec</var> bits and their value to NaN.
See <code class="code">mpfr_init2</code> for more details.
The <code class="code">va_list</code> is assumed to be composed only of type <code class="code">mpfr_t</code>
(or equivalently <code class="code">mpfr_ptr</code>).
It begins from <var class="var">x</var>, and ends when it encounters a null pointer (whose
type must also be <code class="code">mpfr_ptr</code>).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fclear"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clear</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fclear'> &para;</a></span></dt>
<dd><p>Free the space occupied by the significand of
<var class="var">x</var>.  Make sure to call this function for all
<code class="code">mpfr_t</code> variables when you are done with them.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fclears"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clears</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, ...)</code><a class="copiable-link" href='#index-mpfr_005fclears'> &para;</a></span></dt>
<dd><p>Free the space occupied by all the <code class="code">mpfr_t</code> variables of the given
<code class="code">va_list</code>. See <code class="code">mpfr_clear</code> for more details.
The <code class="code">va_list</code> is assumed to be composed only of type <code class="code">mpfr_t</code>
(or equivalently <code class="code">mpfr_ptr</code>).
It begins from <var class="var">x</var>, and ends when it encounters a null pointer (whose
type must also be <code class="code">mpfr_ptr</code>).
</p></dd></dl>
<p>Here is an example of how to use multiple initialization functions
(since <code class="code">NULL</code> is not necessarily defined in this context, we use
<code class="code">(mpfr_ptr) 0</code> instead, but <code class="code">(mpfr_ptr) NULL</code> is also correct).
</p>
<div class="example">
<pre class="example-preformatted">{
  mpfr_t x, y, z, t;
  mpfr_inits2 (256, x, y, z, t, (mpfr_ptr) 0);
  &hellip;
  mpfr_clears (x, y, z, t, (mpfr_ptr) 0);
}
</pre></div>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005finit"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_init</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005finit'> &para;</a></span></dt>
<dd><p>Initialize <var class="var">x</var>, set its precision to the default precision,
and set its value to NaN.
The default precision can be changed by a call to <code class="code">mpfr_set_default_prec</code>.
</p>
<p>Warning! In a given program, some other libraries might change the default
precision and not restore it. Thus it is safer to use <code class="code">mpfr_init2</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005finits"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_inits</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, ...)</code><a class="copiable-link" href='#index-mpfr_005finits'> &para;</a></span></dt>
<dd><p>Initialize all the <code class="code">mpfr_t</code> variables of the given <code class="code">va_list</code>,
set their precision to the default precision and their value to NaN.
See <code class="code">mpfr_init</code> for more details.
The <code class="code">va_list</code> is assumed to be composed only of type <code class="code">mpfr_t</code>
(or equivalently <code class="code">mpfr_ptr</code>).
It begins from <var class="var">x</var>, and ends when it encounters a null pointer (whose
type must also be <code class="code">mpfr_ptr</code>).
</p>
<p>Warning! In a given program, some other libraries might change the default
precision and not restore it. Thus it is safer to use <code class="code">mpfr_inits2</code>.
</p></dd></dl>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MPFR_005fDECL_005fINIT"><span class="category-def">Macro: </span><span><strong class="def-name">MPFR_DECL_INIT</strong> <var class="def-var-arguments">(<var class="var">name</var>, <var class="var">prec</var>)</var><a class="copiable-link" href='#index-MPFR_005fDECL_005fINIT'> &para;</a></span></dt>
<dd><p>This macro declares <var class="var">name</var> as an automatic variable of type <code class="code">mpfr_t</code>,
initializes it and sets its precision to be <strong class="strong">exactly</strong> <var class="var">prec</var> bits
and its value to NaN. <var class="var">name</var> must be a valid identifier.
You must use this macro in the declaration section.
This macro is much faster than using <code class="code">mpfr_init2</code> but has some
drawbacks:
</p>
<ul class="itemize mark-bullet">
<li>You <strong class="strong">must not</strong> call <code class="code">mpfr_clear</code> with variables
created with this macro (the storage is allocated at the point of declaration
and deallocated when the brace-level is exited).
</li><li>You <strong class="strong">cannot</strong> change their precision.
</li><li>You <strong class="strong">should not</strong> create variables with huge precision with this
macro.
</li><li>Your compiler must support &lsquo;<samp class="samp">Non-Constant Initializers</samp>&rsquo; (standard
in C++ and ISO C99) and &lsquo;<samp class="samp">Token Pasting</samp>&rsquo;
(standard in ISO C90). If <var class="var">prec</var> is not a constant expression, your
compiler must support &lsquo;<samp class="samp">variable-length automatic arrays</samp>&rsquo; (standard
in ISO C99). GCC 2.95.3 and above supports all these features.
If you compile your program with GCC in C90 mode and with &lsquo;<samp class="samp">-pedantic</samp>&rsquo;,
you may want to define the <code class="code">MPFR_USE_EXTENSION</code> macro to avoid warnings
due to the <code class="code">MPFR_DECL_INIT</code> implementation.
</li></ul>
</dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fdefault_005fprec"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_default_prec</strong> <code class="def-code-arguments">(mpfr_prec_t <var class="var">prec</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fdefault_005fprec'> &para;</a></span></dt>
<dd><p>Set the default precision to be <strong class="strong">exactly</strong> <var class="var">prec</var> bits, where
<var class="var">prec</var> can be any integer between <code class="code">MPFR_PREC_MIN</code> and
<code class="code">MPFR_PREC_MAX</code>.
The
precision of a variable means the number of bits used to store its significand.
All
subsequent calls to <code class="code">mpfr_init</code> or <code class="code">mpfr_inits</code>
will use this precision, but previously
initialized variables are unaffected.
The default precision is set to 53 bits initially.
</p>
<p>Note: when MPFR is built with the &lsquo;<samp class="samp">--enable-thread-safe</samp>&rsquo; configure option,
the default precision is local to each thread. See <a class="xref" href="constant.MPFR_Basics.html#Memory-Handling">Memory Handling</a>, for
more information.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fdefault_005fprec"><span class="category-def">Function: </span><span><code class="def-type">mpfr_prec_t</code> <strong class="def-name">mpfr_get_default_prec</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005fdefault_005fprec'> &para;</a></span></dt>
<dd><p>Return the current default MPFR precision in bits.
See the documentation of <code class="code">mpfr_set_default_prec</code>.
</p></dd></dl>
<p>Here is an example on how to initialize floating-point variables:
</p>
<div class="example">
<pre class="example-preformatted">{
  mpfr_t x, y;
  mpfr_init (x);                /* use default precision */
  mpfr_init2 (y, 256);          /* precision <em class="emph">exactly</em> 256 bits */
  &hellip;
  /* When the program is about to exit, do ... */
  mpfr_clear (x);
  mpfr_clear (y);
  mpfr_free_cache ();           /* free the cache for constants like pi */
}
</pre></div>
<p>The following functions are useful for changing the precision during a
calculation.  A typical use would be for adjusting the precision gradually in
iterative algorithms like Newton-Raphson, making the computation precision
closely match the actual accurate part of the numbers.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fprec"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_prec</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_prec_t <var class="var">prec</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fprec'> &para;</a></span></dt>
<dd><p>Set the precision of <var class="var">x</var> to be <strong class="strong">exactly</strong> <var class="var">prec</var> bits,
and set its value to NaN.
The previous value stored in <var class="var">x</var> is lost. It is equivalent to
a call to <code class="code">mpfr_clear(<var class="var">x</var>)</code> followed by a call to
<code class="code">mpfr_init2(<var class="var">x</var>, <var class="var">prec</var>)</code>, but more efficient as no allocation
is done in case the current allocated space for the significand of <var class="var">x</var>
is enough.
The precision <var class="var">prec</var> can be any integer between <code class="code">MPFR_PREC_MIN</code> and
<code class="code">MPFR_PREC_MAX</code>.
In case you want to keep the previous value stored in <var class="var">x</var>,
use <code class="code">mpfr_prec_round</code> instead.
</p>
<p>Warning! You must not use this function if <var class="var">x</var> was initialized
with <code class="code">MPFR_DECL_INIT</code> or with <code class="code">mpfr_custom_init_set</code>
(see <a class="pxref" href="#Custom-Interface">Custom Interface</a>).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fprec"><span class="category-def">Function: </span><span><code class="def-type">mpfr_prec_t</code> <strong class="def-name">mpfr_get_prec</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fprec'> &para;</a></span></dt>
<dd><p>Return the precision of <var class="var">x</var>, i.e., the
number of bits used to store its significand.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Assignment-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Combined-Initialization-and-Assignment-Functions" accesskey="n" rel="next">Combined Initialization and Assignment Functions</a>, Previous: <a href="#Initialization-Functions" accesskey="p" rel="prev">Initialization Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Assignment-functions"></a>
<h3 class="section" id="Assignment-Functions-1">5.2 Assignment Functions</h3>
<p>These functions assign new values to already initialized floats
(see <a class="pxref" href="#Initialization-Functions">Initialization Functions</a>).
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fuj"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_uj</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, uintmax_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fuj'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fsj"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_sj</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, intmax_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fsj'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fflt"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_flt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, float <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fflt'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, double <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fd'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fld"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_ld</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long double <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fld'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005ffloat128"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_float128</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, _Float128 <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005ffloat128'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fdecimal64"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_decimal64</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, _Decimal64 <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fdecimal64'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fdecimal128"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_decimal128</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, _Decimal128 <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fdecimal128'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpz_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fz'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpq_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fq'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005ff"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_f</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpf_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005ff'> &para;</a></span></dt>
<dd><p>Set the value of <var class="var">rop</var> from <var class="var">op</var>, rounded
toward the given direction <var class="var">rnd</var>.
Note that the input 0 is converted to +0 by <code class="code">mpfr_set_ui</code>,
<code class="code">mpfr_set_si</code>, <code class="code">mpfr_set_uj</code>, <code class="code">mpfr_set_sj</code>,
<code class="code">mpfr_set_z</code>, <code class="code">mpfr_set_q</code> and
<code class="code">mpfr_set_f</code>, regardless of the rounding mode.
The <code class="code">mpfr_set_float128</code> function is built only with the configure
option &lsquo;<samp class="samp">--enable-float128</samp>&rsquo;, which requires the compiler or
system provides the &lsquo;<samp class="samp">_Float128</samp>&rsquo; data type
(GCC 4.3 or later supports this data type);
to use <code class="code">mpfr_set_float128</code>, one should define the macro
<code class="code">MPFR_WANT_FLOAT128</code> before including <samp class="file">mpfr.h</samp>.
If the system does not support the IEEE&nbsp;754 standard,
<code class="code">mpfr_set_flt</code>, <code class="code">mpfr_set_d</code>, <code class="code">mpfr_set_ld</code>,
<code class="code">mpfr_set_decimal64</code> and <code class="code">mpfr_set_decimal128</code>
might not preserve the signed zeros
(and in any case they don&rsquo;t preserve the sign bit of NaN).
The <code class="code">mpfr_set_decimal64</code> and <code class="code">mpfr_set_decimal128</code>
functions are built only with the configure
option &lsquo;<samp class="samp">--enable-decimal-float</samp>&rsquo;, and when the compiler or
system provides the &lsquo;<samp class="samp">_Decimal64</samp>&rsquo; and &lsquo;<samp class="samp">_Decimal128</samp>&rsquo; data type;
to use those functions, one should define the macro
<code class="code">MPFR_WANT_DECIMAL_FLOATS</code> before including <samp class="file">mpfr.h</samp>.
<code class="code">mpfr_set_q</code> might fail if the numerator (or the
denominator) cannot be represented as a <code class="code">mpfr_t</code>.
</p>
<p>For <code class="code">mpfr_set</code>, the sign of a NaN is propagated in order to mimic the
IEEE&nbsp;754 <code class="code">copy</code> operation. But contrary to IEEE&nbsp;754, the
NaN flag is set as usual.
</p>
<p>Note: If you want to store a floating-point constant to a <code class="code">mpfr_t</code>,
you should use <code class="code">mpfr_set_str</code> (or one of the MPFR constant functions,
such as <code class="code">mpfr_const_pi</code> for Pi) instead of
<code class="code">mpfr_set_flt</code>, <code class="code">mpfr_set_d</code>,
<code class="code">mpfr_set_ld</code>, <code class="code">mpfr_set_decimal64</code> or
<code class="code">mpfr_set_decimal128</code>.
Otherwise the floating-point constant will be first
converted into a reduced-precision (e.g., 53-bit) binary
(or decimal, for <code class="code">mpfr_set_decimal64</code> and <code class="code">mpfr_set_decimal128</code>)
number before MPFR can work with it.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fui_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_ui_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_exp_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fui_005f2exp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fsi_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_si_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op</var>, mpfr_exp_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fsi_005f2exp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fuj_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_uj_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, uintmax_t <var class="var">op</var>, intmax_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fuj_005f2exp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fsj_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_sj_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, intmax_t <var class="var">op</var>, intmax_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fsj_005f2exp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fz_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_z_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpz_t <var class="var">op</var>, mpfr_exp_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fz_005f2exp'> &para;</a></span></dt>
<dd><p>Set the value of <var class="var">rop</var> from <var class="var">op</var> multiplied by
two to the power <var class="var">e</var>, rounded toward the given direction <var class="var">rnd</var>.
Note that the input 0 is converted to +0.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fstr"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_str</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, const char *<var class="var">s</var>, int <var class="var">base</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fstr'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the string <var class="var">s</var> in base <var class="var">base</var>,
rounded in the direction <var class="var">rnd</var>.
See the documentation of <code class="code">mpfr_strtofr</code> for a detailed description
of the valid string formats.
Contrary to <code class="code">mpfr_strtofr</code>, <code class="code">mpfr_set_str</code> requires the
<em class="emph">whole</em> string to represent a valid floating-point number.
</p>
<p>The meaning of the return value differs from other MPFR functions:
it is 0 if the entire string up to the final null character
is a valid number in base <var class="var">base</var>; otherwise it is &minus;1, and
<var class="var">rop</var> may have changed (users interested in the <a class="ref" href="constant.MPFR_Basics.html#ternary-value">ternary value</a>
should use <code class="code">mpfr_strtofr</code> instead).
</p>
<p>Note: it is preferable to use <code class="code">mpfr_strtofr</code> if one wants to distinguish
between an infinite <var class="var">rop</var> value coming from an infinite <var class="var">s</var> or from
an overflow.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fstrtofr"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_strtofr</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, const char *<var class="var">nptr</var>, char **<var class="var">endptr</var>, int <var class="var">base</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fstrtofr'> &para;</a></span></dt>
<dd><p>Read a floating-point number from a string <var class="var">nptr</var> in base <var class="var">base</var>,
rounded in the direction <var class="var">rnd</var>; <var class="var">base</var> must be either 0 (to
detect the base, as described below) or a number from 2 to 62 (otherwise
the behavior is undefined). If <var class="var">nptr</var> starts with valid data, the
result is stored in <var class="var">rop</var> and <code class="code">*<var class="var">endptr</var></code> points to the
character just after the valid data (if <var class="var">endptr</var> is not a null pointer);
otherwise <var class="var">rop</var> is set to zero (for consistency with <code class="code">strtod</code>)
and the value of <var class="var">nptr</var> is stored
in the location referenced by <var class="var">endptr</var> (if <var class="var">endptr</var> is not a null
pointer). The usual ternary value is returned.
</p>
<p>Parsing follows the standard C <code class="code">strtod</code> function with some extensions.
After optional leading whitespace, one has a subject sequence consisting of an
optional sign (&lsquo;<samp class="samp">+</samp>&rsquo; or &lsquo;<samp class="samp">-</samp>&rsquo;), and either numeric data or special
data. The subject sequence is defined as the longest initial subsequence of
the input string, starting with the first non-whitespace character, that is of
the expected form.
</p>
<p>The form of numeric data is a non-empty sequence of significand digits with
an optional decimal-point character, and an optional exponent consisting of
an exponent prefix followed by an optional sign and a non-empty sequence of
decimal digits. A significand digit is either a decimal digit or a Latin
letter (62 possible characters), with &lsquo;<samp class="samp">A</samp>&rsquo; = 10, &lsquo;<samp class="samp">B</samp>&rsquo; = 11, &hellip;,
&lsquo;<samp class="samp">Z</samp>&rsquo; = 35; case is ignored in bases less than or equal to 36, in bases
larger than 36, &lsquo;<samp class="samp">a</samp>&rsquo; = 36, &lsquo;<samp class="samp">b</samp>&rsquo; = 37, &hellip;, &lsquo;<samp class="samp">z</samp>&rsquo; = 61.
The value of a significand digit must be strictly less than the base. The
decimal-point character can be either the one defined by the current locale
or the period (the first one is accepted for consistency with the C standard
and the practice, the second one is accepted to allow the programmer to
provide MPFR numbers from strings in a way that does not depend on the
current locale).
The exponent prefix can be &lsquo;<samp class="samp">e</samp>&rsquo; or &lsquo;<samp class="samp">E</samp>&rsquo; for bases up to 10, or
&lsquo;<samp class="samp">@</samp>&rsquo; in any base; it indicates a multiplication by a power of the
base. In bases 2 and 16, the exponent prefix can also be &lsquo;<samp class="samp">p</samp>&rsquo; or &lsquo;<samp class="samp">P</samp>&rsquo;,
in which case the exponent, called <em class="emph">binary exponent</em>, indicates a
multiplication by a power of 2 instead of the base (there is a difference
only for base 16); in base 16 for example &lsquo;<samp class="samp">1p2</samp>&rsquo; represents 4 whereas
&lsquo;<samp class="samp">1@2</samp>&rsquo; represents 256. The value of an exponent is always written in
base 10.
</p>
<p>If the argument <var class="var">base</var> is 0, then the base is automatically detected
as follows. If the significand starts with &lsquo;<samp class="samp">0b</samp>&rsquo; or &lsquo;<samp class="samp">0B</samp>&rsquo;, base 2
is assumed. If the significand starts with &lsquo;<samp class="samp">0x</samp>&rsquo; or &lsquo;<samp class="samp">0X</samp>&rsquo;, base 16
is assumed. Otherwise base 10 is assumed.
</p>
<p>Note: The exponent (if present)
must contain at least a digit. Otherwise the possible
exponent prefix and sign are not part of the number (which ends with the
significand). Similarly, if &lsquo;<samp class="samp">0b</samp>&rsquo;, &lsquo;<samp class="samp">0B</samp>&rsquo;, &lsquo;<samp class="samp">0x</samp>&rsquo; or &lsquo;<samp class="samp">0X</samp>&rsquo;
is not followed by a binary/hexadecimal digit, then the subject sequence
stops at the character &lsquo;<samp class="samp">0</samp>&rsquo;, thus 0 is read.
</p>
<p>Special data (for infinities and NaN) can be &lsquo;<samp class="samp">@inf@</samp>&rsquo; or
&lsquo;<samp class="samp">@nan@(n-char-sequence-opt)</samp>&rsquo;, and if <var class="var">base</var>&nbsp;&lt;=&nbsp;16<!-- /@w -->,
it can also be &lsquo;<samp class="samp">infinity</samp>&rsquo;, &lsquo;<samp class="samp">inf</samp>&rsquo;, &lsquo;<samp class="samp">nan</samp>&rsquo; or
&lsquo;<samp class="samp">nan(n-char-sequence-opt)</samp>&rsquo;, all case insensitive with the rules of
the C locale.
An &lsquo;<samp class="samp">n-char-sequence-opt</samp>&rsquo; is a possibly empty string containing only digits,
Latin letters and the underscore (0, 1, 2, &hellip;, 9, a, b, &hellip;, z,
A, B, &hellip;, Z, _). Note: one has an optional sign for all data, even
NaN.
For example, &lsquo;<samp class="samp">-@nAn@(This_Is_Not_17)</samp>&rsquo; is a valid representation for NaN
in base 17.
</p>
</dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fnan"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_nan</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fnan'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005finf"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_inf</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, int <var class="var">sign</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005finf'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fzero"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_zero</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, int <var class="var">sign</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fzero'> &para;</a></span></dt>
<dd><p>Set the variable <var class="var">x</var> to NaN (Not-a-Number), infinity or zero respectively.
In <code class="code">mpfr_set_inf</code> or <code class="code">mpfr_set_zero</code>, <var class="var">x</var> is set to positive
infinity (+Inf) or positive zero (+0) iff <var class="var">sign</var> is non-negative;
in <code class="code">mpfr_set_nan</code>, the sign bit of the result is unspecified.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fswap"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_swap</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>)</code><a class="copiable-link" href='#index-mpfr_005fswap'> &para;</a></span></dt>
<dd><p>Swap the structures pointed to by <var class="var">x</var> and <var class="var">y</var>. In particular,
the values are exchanged without rounding (this may be different from
three <code class="code">mpfr_set</code> calls using a third auxiliary variable).
</p>
<p>Warning! Since the precisions are exchanged, this will affect future
assignments. Moreover, since the significand pointers are also exchanged,
you must not use this function if the allocation method used for <var class="var">x</var>
and/or <var class="var">y</var> does not permit it. This is the case when <var class="var">x</var> and/or
<var class="var">y</var> were declared and initialized with <code class="code">MPFR_DECL_INIT</code>, and
possibly with <code class="code">mpfr_custom_init_set</code> (see <a class="pxref" href="#Custom-Interface">Custom Interface</a>).
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Combined-Initialization-and-Assignment-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Conversion-Functions" accesskey="n" rel="next">Conversion Functions</a>, Previous: <a href="#Assignment-Functions" accesskey="p" rel="prev">Assignment Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Combined-initialization-and-assignment-functions"></a>
<h3 class="section" id="Combined-Initialization-and-Assignment-Functions-1">5.3 Combined Initialization and Assignment Functions</h3>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-mpfr_005finit_005fset"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpfr_005finit_005fset_005fui"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset_005fui'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpfr_005finit_005fset_005fsi"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpfr_005finit_005fset_005fd"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, double <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset_005fd'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpfr_005finit_005fset_005fld"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set_ld</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long double <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset_005fld'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpfr_005finit_005fset_005fz"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpz_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset_005fz'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpfr_005finit_005fset_005fq"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpq_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset_005fq'> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-mpfr_005finit_005fset_005ff"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set_f</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpf_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset_005ff'> &para;</a></span></dt>
<dd><p>Initialize <var class="var">rop</var> and set its value from <var class="var">op</var>, rounded in the direction
<var class="var">rnd</var>.
The precision of <var class="var">rop</var> will be taken from the active default precision,
as set by <code class="code">mpfr_set_default_prec</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005finit_005fset_005fstr"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_init_set_str</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, const char *<var class="var">s</var>, int <var class="var">base</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finit_005fset_005fstr'> &para;</a></span></dt>
<dd><p>Initialize <var class="var">x</var> and set its value from
the string <var class="var">s</var> in base <var class="var">base</var>,
rounded in the direction <var class="var">rnd</var>.
See <code class="code">mpfr_set_str</code>.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Conversion-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Arithmetic-Functions" accesskey="n" rel="next">Arithmetic Functions</a>, Previous: <a href="#Combined-Initialization-and-Assignment-Functions" accesskey="p" rel="prev">Combined Initialization and Assignment Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Conversion-functions"></a>
<h3 class="section" id="Conversion-Functions-1">5.4 Conversion Functions</h3>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fflt"><span class="category-def">Function: </span><span><code class="def-type">float</code> <strong class="def-name">mpfr_get_flt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fflt'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005fd"><span class="category-def">Function: </span><span><code class="def-type">double</code> <strong class="def-name">mpfr_get_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fd'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005fld"><span class="category-def">Function: </span><span><code class="def-type">long double</code> <strong class="def-name">mpfr_get_ld</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fld'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005ffloat128"><span class="category-def">Function: </span><span><code class="def-type">_Float128</code> <strong class="def-name">mpfr_get_float128</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005ffloat128'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005fdecimal64"><span class="category-def">Function: </span><span><code class="def-type">_Decimal64</code> <strong class="def-name">mpfr_get_decimal64</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fdecimal64'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005fdecimal128"><span class="category-def">Function: </span><span><code class="def-type">_Decimal128</code> <strong class="def-name">mpfr_get_decimal128</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fdecimal128'> &para;</a></span></dt>
<dd><p>Convert <var class="var">op</var> to a <code class="code">float</code> (respectively <code class="code">double</code>,
<code class="code">long double</code>, <code class="code">_Decimal64</code>, or <code class="code">_Decimal128</code>)
using the rounding mode <var class="var">rnd</var>.
If <var class="var">op</var> is NaN, some NaN (either quiet or signaling) or the result
of 0.0/0.0 is returned (the sign bit is not preserved).
If <var class="var">op</var> is ±Inf, an infinity of the same
sign or the result of ±1.0/0.0 is returned. If <var class="var">op</var> is zero, these
functions return a zero, trying to preserve its sign, if possible.
The <code class="code">mpfr_get_float128</code>, <code class="code">mpfr_get_decimal64</code> and
<code class="code">mpfr_get_decimal128</code> functions are built
only under some conditions: see the documentation of <code class="code">mpfr_set_float128</code>,
<code class="code">mpfr_set_decimal64</code> and <code class="code">mpfr_set_decimal128</code> respectively.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fsi"><span class="category-def">Function: </span><span><code class="def-type">long int</code> <strong class="def-name">mpfr_get_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005fui"><span class="category-def">Function: </span><span><code class="def-type">unsigned long int</code> <strong class="def-name">mpfr_get_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005fsj"><span class="category-def">Function: </span><span><code class="def-type">intmax_t</code> <strong class="def-name">mpfr_get_sj</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fsj'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005fuj"><span class="category-def">Function: </span><span><code class="def-type">uintmax_t</code> <strong class="def-name">mpfr_get_uj</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fuj'> &para;</a></span></dt>
<dd><p>Convert <var class="var">op</var> to a <code class="code">long int</code>, an <code class="code">unsigned long int</code>,
an <code class="code">intmax_t</code> or an <code class="code">uintmax_t</code> (respectively) after rounding
it to an integer with respect to <var class="var">rnd</var>.
If <var class="var">op</var> is NaN, 0 is returned and the <em class="emph">erange</em> flag is set.
If <var class="var">op</var> is too big for the return type, the function returns the maximum
or the minimum of the corresponding C type, depending on the direction
of the overflow; the <em class="emph">erange</em> flag is set too.
When there is no such range error, if the return value differs from
<var class="var">op</var>, i.e., if <var class="var">op</var> is not an integer, the inexact flag is set.
See also <code class="code">mpfr_fits_slong_p</code>, <code class="code">mpfr_fits_ulong_p</code>,
<code class="code">mpfr_fits_intmax_p</code> and <code class="code">mpfr_fits_uintmax_p</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fd_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">double</code> <strong class="def-name">mpfr_get_d_2exp</strong> <code class="def-code-arguments">(long *<var class="var">exp</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fd_005f2exp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005fld_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">long double</code> <strong class="def-name">mpfr_get_ld_2exp</strong> <code class="def-code-arguments">(long *<var class="var">exp</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fld_005f2exp'> &para;</a></span></dt>
<dd><p>Return <var class="var">d</var> and set <var class="var">exp</var>
(formally, the value pointed to by <var class="var">exp</var>)
such that 0.5&nbsp;&lt;=&nbsp;abs(<var class="var">d</var>)&nbsp;&lt;&nbsp;1<!-- /@w -->
and <var class="var">d</var> times 2 raised to <var class="var">exp</var> equals
<var class="var">op</var> rounded to double (resp. long double)
precision, using the given rounding mode.
If <var class="var">op</var> is zero, then a zero of the same sign (or an unsigned zero,
if the implementation does not have signed zeros) is returned, and
<var class="var">exp</var> is set to 0.
If <var class="var">op</var> is NaN or an infinity, then the corresponding double precision
(resp. long-double precision)
value is returned, and <var class="var">exp</var> is undefined.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffrexp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_frexp</strong> <code class="def-code-arguments">(mpfr_exp_t *<var class="var">exp</var>, mpfr_t <var class="var">y</var>, mpfr_t <var class="var">x</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffrexp'> &para;</a></span></dt>
<dd><p>Set <var class="var">exp</var>
(formally, the value pointed to by <var class="var">exp</var>) and <var class="var">y</var>
such that 0.5&nbsp;&lt;=&nbsp;abs(<var class="var">y</var>)&nbsp;&lt;&nbsp;1<!-- /@w -->
and <var class="var">y</var> times 2 raised to <var class="var">exp</var> equals
<var class="var">x</var> rounded to the precision of <var class="var">y</var>, using the given rounding mode.
If <var class="var">x</var> is zero, then <var class="var">y</var> is set to a zero of the same sign and
<var class="var">exp</var> is set to 0.
If <var class="var">x</var> is NaN or an infinity, then <var class="var">y</var> is set to the same value
and <var class="var">exp</var> is undefined.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fz_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_get_z_2exp</strong> <code class="def-code-arguments">(mpz_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fz_005f2exp'> &para;</a></span></dt>
<dd><p>Put the scaled significand of <var class="var">op</var> (regarded as an integer, with the
precision of <var class="var">op</var>) into <var class="var">rop</var>, and return the exponent <var class="var">exp</var>
(which may be outside the current exponent range) such that <var class="var">op</var>
exactly equals <var class="var">rop</var> times 2 raised
to the power <var class="var">exp</var>.
If <var class="var">op</var> is zero, the minimal exponent <var class="var">emin</var> is returned.
If <var class="var">op</var> is NaN or an infinity, the <em class="emph">erange</em> flag is set, <var class="var">rop</var>
is set to 0, and the minimal exponent <var class="var">emin</var> is returned.
The returned exponent may be less than the minimal exponent <var class="var">emin</var>
of MPFR numbers in the current exponent range; in case the exponent is
not representable in the <code class="code">mpfr_exp_t</code> type, the <em class="emph">erange</em> flag
is set and the minimal value of the <code class="code">mpfr_exp_t</code> type is returned.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_get_z</strong> <code class="def-code-arguments">(mpz_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fz'> &para;</a></span></dt>
<dd><p>Convert <var class="var">op</var> to a <code class="code">mpz_t</code>, after rounding it with respect to
<var class="var">rnd</var>. If <var class="var">op</var> is NaN or an infinity, the <em class="emph">erange</em> flag is
set, <var class="var">rop</var> is set to 0, and 0 is returned. Otherwise the return
value is zero when <var class="var">rop</var> is equal to <var class="var">op</var> (i.e., when <var class="var">op</var>
is an integer), positive when it is greater than <var class="var">op</var>, and negative
when it is smaller than <var class="var">op</var>; moreover, if <var class="var">rop</var> differs from
<var class="var">op</var>, i.e., if <var class="var">op</var> is not an integer, the inexact flag is set.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fq"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_get_q</strong> <code class="def-code-arguments">(mpq_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fq'> &para;</a></span></dt>
<dd><p>Convert <var class="var">op</var> to a <code class="code">mpq_t</code>.
If <var class="var">op</var> is NaN or an infinity, the <em class="emph">erange</em> flag is
set and <var class="var">rop</var> is set to 0. Otherwise the conversion is always exact.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005ff"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_get_f</strong> <code class="def-code-arguments">(mpf_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005ff'> &para;</a></span></dt>
<dd><p>Convert <var class="var">op</var> to a <code class="code">mpf_t</code>, after rounding it with respect to
<var class="var">rnd</var>.
The <em class="emph">erange</em> flag is set if <var class="var">op</var> is NaN or an infinity, which
do not exist in MPF.  If <var class="var">op</var> is NaN, then <var class="var">rop</var> is undefined.
If <var class="var">op</var> is +Inf (resp. &minus;Inf), then <var class="var">rop</var> is set to
the maximum (resp. minimum) value in the precision of the MPF number;
if a future MPF version supports infinities, this behavior will be
considered incorrect and will change (portable programs should assume
that <var class="var">rop</var> is set either to this finite number or to an infinite
number).
Note that since MPFR currently has the same exponent type as MPF (but
not with the same radix), the range of values is much larger in MPF
than in MPFR, so that an overflow or underflow is not possible.
</p></dd></dl>
<a class="anchor" id="mpfr_005fget_005fstr_005fndigits"></a><dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fstr_005fndigits"><span class="category-def">Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">mpfr_get_str_ndigits</strong> <code class="def-code-arguments">(int <var class="var">b</var>, mpfr_prec_t <var class="var">p</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fstr_005fndigits'> &para;</a></span></dt>
<dd><p>Return the minimal integer m<!-- /@w --> such that any number
of <var class="var">p</var> bits, when output with m<!-- /@w --> digits in radix <var class="var">b</var> with
rounding to nearest, can be recovered exactly when read again,
still with rounding to nearest.
More precisely, we have
m = 1 + ceil(<var class="var">p</var> times log(2)/log(<var class="var">b</var>)),
with <var class="var">p</var> replaced by <var class="var">p</var>&nbsp;&minus;&nbsp;1<!-- /@w --> if <var class="var">b</var> is a power of 2.
</p>
<p>The argument <var class="var">b</var> must be in the range 2 to 62; this is the range of bases
supported by the <code class="code">mpfr_get_str</code> function. Note that contrary to the base
argument of this function, negative values are not accepted.
</p></dd></dl>
<a class="anchor" id="mpfr_005fget_005fstr"></a><dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fstr"><span class="category-def">Function: </span><span><code class="def-type">char *</code> <strong class="def-name">mpfr_get_str</strong> <code class="def-code-arguments">(char *<var class="var">str</var>, mpfr_exp_t *<var class="var">expptr</var>, int <var class="var">base</var>, size_t <var class="var">n</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fstr'> &para;</a></span></dt>
<dd><p>Convert <var class="var">op</var> to a string of digits in base abs(<var class="var">base</var>),
with rounding in the direction <var class="var">rnd</var>, where <var class="var">n</var> is either zero
(see below) or the number of significant digits output in the string.
The argument <var class="var">base</var> may vary from 2 to 62 or from &minus;2 to &minus;36;
otherwise the function does nothing and immediately returns a null pointer.
</p>
<p>For <var class="var">base</var> in the range 2 to 36, digits and lower-case letters are used;
for &minus;2 to &minus;36, digits and upper-case letters are used; for
37 to 62, digits, upper-case letters, and lower-case letters, in that
significance order, are used. Warning! This implies that for
<var class="var">base</var>&nbsp;&gt;&nbsp;10<!-- /@w -->, the successor of the digit 9 depends on <var class="var">base</var>.
This choice has been done for compatibility with GMP&rsquo;s <code class="code">mpf_get_str</code>
function. Users who wish a more consistent behavior should write a simple
wrapper.
</p>
<p>If the input is NaN, then the returned string is &lsquo;<samp class="samp">@NaN@</samp>&rsquo; and the
NaN flag is set. If the input is +Inf (resp. &minus;Inf), then the
returned string is &lsquo;<samp class="samp">@Inf@</samp>&rsquo; (resp. &lsquo;<samp class="samp">-@Inf@</samp>&rsquo;).
</p>
<p>If the input number is a finite number, the exponent is written through
the pointer <var class="var">expptr</var> (for input 0, the current minimal exponent is
written); the type <code class="code">mpfr_exp_t</code> is large enough to hold the exponent
in all cases.
</p>
<p>The generated string is a fraction, with an implicit radix point immediately
to the left of the first digit.  For example, the number &minus;3.1416 would
be returned as &lsquo;<samp class="samp">-31416</samp>&rsquo; in the string and 1 written at <var class="var">expptr</var>.
If <var class="var">rnd</var> is to nearest, and <var class="var">op</var> is exactly in the middle of two
consecutive possible outputs, the one with an even significand is chosen,
where both significands are considered with the exponent of <var class="var">op</var>.
Note that for an odd base, this may not correspond to an even last digit:
for example, with 2 digits in base 7, (14) and a half is rounded to (15),
which is 12 in decimal, (16) and a half is rounded to (20), which is 14
in decimal,
and (26) and a half is rounded to (26), which is 20 in decimal.
</p>
<p>If <var class="var">n</var> is zero, the number of digits of the significand is taken as
<code class="code">mpfr_get_str_ndigits (<var class="var">base</var>, <var class="var">p</var>)</code>, where <var class="var">p</var> is the
precision of <var class="var">op</var> (see <a class="pxref" href="#mpfr_005fget_005fstr_005fndigits">mpfr_get_str_ndigits</a>).
</p>
<p>If <var class="var">str</var> is a null pointer, space for the significand is allocated using
the allocation function (see <a class="pxref" href="constant.MPFR_Basics.html#Memory-Handling">Memory Handling</a>) and a pointer to the string
is returned (unless the base is invalid).
To free the returned string, you must use <code class="code">mpfr_free_str</code>.
</p>
<p>If <var class="var">str</var> is not a null pointer, it should point to a block of storage
large enough for the significand. A safe block size (sufficient for any value)
is max(<var class="var">n</var>&nbsp;+&nbsp;2,&nbsp;7)<!-- /@w --> if <var class="var">n</var> is not zero; if <var class="var">n</var> is
zero, replace it by <code class="code">mpfr_get_str_ndigits (<var class="var">base</var>, <var class="var">p</var>)</code>, where
<var class="var">p</var> is the precision of <var class="var">op</var>, as mentioned above.
The extra two bytes are
for a possible minus sign, and for the terminating null character, and the
value 7 accounts for &lsquo;<samp class="samp">-@Inf@</samp>&rsquo; plus the terminating null character.
The pointer to the string <var class="var">str</var> is returned (unless the base is invalid).
</p>
<p>Like in usual functions, the inexact flag is set iff the result is inexact.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffree_005fstr"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_free_str</strong> <code class="def-code-arguments">(char *<var class="var">str</var>)</code><a class="copiable-link" href='#index-mpfr_005ffree_005fstr'> &para;</a></span></dt>
<dd><p>Free a string allocated by <code class="code">mpfr_get_str</code> using the unallocation
function (see <a class="pxref" href="constant.MPFR_Basics.html#Memory-Handling">Memory Handling</a>).
The block is assumed to be <code class="code">strlen(<var class="var">str</var>)+1</code> bytes.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffits_005fulong_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fits_ulong_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffits_005fulong_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffits_005fslong_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fits_slong_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffits_005fslong_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffits_005fuint_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fits_uint_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffits_005fuint_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffits_005fsint_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fits_sint_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffits_005fsint_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffits_005fushort_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fits_ushort_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffits_005fushort_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffits_005fsshort_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fits_sshort_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffits_005fsshort_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffits_005fuintmax_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fits_uintmax_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffits_005fuintmax_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffits_005fintmax_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fits_intmax_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffits_005fintmax_005fp'> &para;</a></span></dt>
<dd><p>Return non-zero if <var class="var">op</var> would fit in the respective C data type,
respectively <code class="code">unsigned long int</code>, <code class="code">long int</code>, <code class="code">unsigned int</code>,
<code class="code">int</code>, <code class="code">unsigned short</code>, <code class="code">short</code>, <code class="code">uintmax_t</code>,
<code class="code">intmax_t</code>, when rounded to an integer in the direction <var class="var">rnd</var>.
For instance, with the <code class="code">MPFR_RNDU</code> rounding mode on &minus;0.5,
the result will be non-zero for all these functions.
For <code class="code">MPFR_RNDF</code>, those functions return non-zero when it is guaranteed
that the corresponding conversion function (for example <code class="code">mpfr_get_ui</code>
for <code class="code">mpfr_fits_ulong_p</code>), when called with faithful rounding,
will always return a number that is representable in the corresponding type.
As a consequence, for <code class="code">MPFR_RNDF</code>, <code class="code">mpfr_fits_ulong_p</code> will return
non-zero for a non-negative number less than or equal to <code class="code">ULONG_MAX</code>.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Arithmetic-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Comparison-Functions" accesskey="n" rel="next">Comparison Functions</a>, Previous: <a href="#Conversion-Functions" accesskey="p" rel="prev">Conversion Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Arithmetic-functions"></a>
<h3 class="section" id="Arithmetic-Functions-1">5.5 Arithmetic Functions</h3>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fadd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fd'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fz'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fq'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var>&nbsp;+&nbsp;<var class="var">op2</var><!-- /@w --> rounded in the direction
<var class="var">rnd</var>.  The IEEE&nbsp;754 rules are used, in particular for signed zeros.
But for types having no signed zeros, 0 is considered unsigned
(i.e., (+0)&nbsp;+&nbsp;0&nbsp;=&nbsp;(+0)<!-- /@w --> and (&minus;0)&nbsp;+&nbsp;0&nbsp;=&nbsp;(&minus;0)<!-- /@w -->).
The <code class="code">mpfr_add_d</code> function assumes that the radix of the <code class="code">double</code> type
is a power of 2, with a precision at most that declared by the C implementation
(macro <code class="code">IEEE_DBL_MANT_DIG</code>, and if not defined 53 bits).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fui_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_ui_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fui_005fsub'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsi_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_si_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsi_005fsub'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fd_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_d_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, double <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fd_005fsub'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fd'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fz_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_z_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpz_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fz_005fsub'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fz'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fq'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var>&nbsp;&minus;&nbsp;<var class="var">op2</var><!-- /@w --> rounded in the direction
<var class="var">rnd</var>.  The IEEE&nbsp;754 rules are used, in particular for signed zeros.
But for types having no signed zeros, 0 is considered unsigned
(i.e., (+0)&nbsp;&minus;&nbsp;0&nbsp;=&nbsp;(+0)<!-- /@w -->, (&minus;0)&nbsp;&minus;&nbsp;0&nbsp;=&nbsp;(&minus;0)<!-- /@w -->,
0&nbsp;&minus;&nbsp;(+0)&nbsp;=&nbsp;(&minus;0)<!-- /@w --> and 0&nbsp;&minus;&nbsp;(&minus;0)&nbsp;=&nbsp;(+0)<!-- /@w -->).
The same restrictions as for <code class="code">mpfr_add_d</code> apply to <code class="code">mpfr_d_sub</code>
and <code class="code">mpfr_sub_d</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmul"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fd'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fz'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fq'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var>&nbsp;times&nbsp;<var class="var">op2</var><!-- /@w --> rounded in the
direction <var class="var">rnd</var>.
When a result is zero, its sign is the product of the signs of the operands
(for types having no signed zeros, 0 is considered positive).
The same restrictions as for <code class="code">mpfr_add_d</code> apply to <code class="code">mpfr_mul_d</code>.
Note: when <var class="var">op1</var> and <var class="var">op2</var> are equal, use <code class="code">mpfr_sqr</code> instead of
<code class="code">mpfr_mul</code> for better efficiency.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsqr"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sqr</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsqr'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the square of <var class="var">op</var>
rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdiv"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fui_005fdiv"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_ui_div</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fui_005fdiv'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsi_005fdiv"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_si_div</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsi_005fdiv'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fd_005fdiv"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_d_div</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, double <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fd_005fdiv'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fd'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fz'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fq'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var>&nbsp;/&nbsp;<var class="var">op2</var><!-- /@w --> rounded in the direction <var class="var">rnd</var>.
When a result is zero, its sign is the product of the signs of the operands.
For types having no signed zeros, 0 is considered positive; but note that if
<var class="var">op1</var> is non-zero and <var class="var">op2</var> is zero, the result might change from
±Inf to NaN in future MPFR versions if there is an opposite decision
on the IEEE&nbsp;754 side.
The same restrictions as for <code class="code">mpfr_add_d</code> apply to <code class="code">mpfr_d_div</code>
and <code class="code">mpfr_div_d</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsqrt"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sqrt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsqrt'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsqrt_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sqrt_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsqrt_005fui'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the square root of <var class="var">op</var>
rounded in the direction <var class="var">rnd</var>.  Set <var class="var">rop</var> to &minus;0 if
<var class="var">op</var> is &minus;0, to be consistent with the IEEE&nbsp;754 standard
(thus this differs from <code class="code">mpfr_rootn_ui</code> and <code class="code">mpfr_rootn_si</code>
with <var class="var">n</var>&nbsp;=&nbsp;2<!-- /@w -->).
Set <var class="var">rop</var> to NaN if <var class="var">op</var> is negative.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005frec_005fsqrt"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rec_sqrt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frec_005fsqrt'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the reciprocal square root of <var class="var">op</var>
rounded in the direction <var class="var">rnd</var>.  Set <var class="var">rop</var> to +Inf if <var class="var">op</var> is
±0, +0 if <var class="var">op</var> is +Inf, and NaN if <var class="var">op</var> is negative.
Warning!  Therefore the result on &minus;0 is different from the one of the
rSqrt function recommended by the IEEE&nbsp;754 standard (Section&nbsp;9.2.1),
which is &minus;Inf instead of +Inf. However, <code class="code">mpfr_rec_sqrt</code> is
equivalent to <code class="code">mpfr_rootn_si</code> with <var class="var">n</var>&nbsp;=&nbsp;&minus;2<!-- /@w -->.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcbrt"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cbrt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcbrt'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005frootn_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rootn_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frootn_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005frootn_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rootn_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frootn_005fsi'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the <var class="var">n</var>th root (with <var class="var">n</var>&nbsp;=&nbsp;3<!-- /@w -->, the cubic root,
for <code class="code">mpfr_cbrt</code>) of <var class="var">op</var> rounded in the direction <var class="var">rnd</var>.
For <var class="var">n</var>&nbsp;=&nbsp;0<!-- /@w -->, set <var class="var">rop</var> to NaN.
For <var class="var">n</var> odd (resp. even) and <var class="var">op</var> negative (including &minus;Inf),
set <var class="var">rop</var> to a negative number (resp. NaN).
If <var class="var">op</var> is zero, set <var class="var">rop</var> to zero with the sign obtained by the
usual limit rules, i.e., the same sign as <var class="var">op</var> if <var class="var">n</var> is odd, and
positive if <var class="var">n</var> is even.
</p>
<p>These functions agree with the rootn operation of the IEEE&nbsp;754 standard.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005froot"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_root</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005froot'> &para;</a></span></dt>
<dd><p>This function is the same as <code class="code">mpfr_rootn_ui</code> except when <var class="var">op</var>
is &minus;0 and <var class="var">n</var> is even: the result is &minus;0 instead of +0
(the reason was to be consistent with <code class="code">mpfr_sqrt</code>). Said otherwise,
if <var class="var">op</var> is zero, set <var class="var">rop</var> to <var class="var">op</var>.
</p>
<p>This function predates IEEE&nbsp;754-2008, where rootn was introduced, and
behaves differently from the IEEE&nbsp;754 rootn operation. It is marked as
deprecated and will be removed in a future release.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fneg"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_neg</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fneg'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fabs"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_abs</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fabs'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to &minus;<var class="var">op</var><!-- /@w --> and the absolute value of <var class="var">op</var>
respectively, rounded in the direction <var class="var">rnd</var>.
Just changes or adjusts
the sign if <var class="var">rop</var> and <var class="var">op</var> are the same variable,
otherwise a rounding might occur if the precision of <var class="var">rop</var> is less than
that of <var class="var">op</var>.
</p>
<p>The sign rule also applies to NaN in order to mimic the IEEE&nbsp;754
<code class="code">negate</code> and <code class="code">abs</code> operations, i.e., for <code class="code">mpfr_neg</code>, the
sign is reversed, and for <code class="code">mpfr_abs</code>, the sign is set to positive.
But contrary to IEEE&nbsp;754, the NaN flag is set as usual.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdim"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_dim</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdim'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the positive difference of <var class="var">op1</var> and <var class="var">op2</var>, i.e.,
<var class="var">op1</var>&nbsp;&minus;&nbsp;<var class="var">op2</var><!-- /@w --> rounded in the direction <var class="var">rnd</var>
if <var class="var">op1</var>&nbsp;&gt;&nbsp;<var class="var">op2</var><!-- /@w -->, +0 if <var class="var">op1</var>&nbsp;&lt;=&nbsp;<var class="var">op2</var><!-- /@w -->,
and NaN if <var class="var">op1</var> or <var class="var">op2</var> is NaN.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmul_005f2ui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_2ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005f2ui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005f2si"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_2si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005f2si'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> times 2 raised
to <var class="var">op2</var>
rounded in the direction <var class="var">rnd</var>. Just increases the exponent by <var class="var">op2</var>
when <var class="var">rop</var> and <var class="var">op1</var> are identical.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdiv_005f2ui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_2ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005f2ui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005f2si"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_2si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005f2si'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> divided by 2 raised
to <var class="var">op2</var>
rounded in the direction <var class="var">rnd</var>. Just decreases the exponent by <var class="var">op2</var>
when <var class="var">rop</var> and <var class="var">op1</var> are identical.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffac_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fac_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffac_005fui'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the factorial of <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffma"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fma</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_t <var class="var">op3</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffma'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffms"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fms</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_t <var class="var">op3</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffms'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to (<var class="var">op1</var>&nbsp;times&nbsp;<var class="var">op2</var>)&nbsp;+&nbsp;<var class="var">op3</var><!-- /@w -->
(resp. (<var class="var">op1</var>&nbsp;times&nbsp;<var class="var">op2</var>)&nbsp;&minus;&nbsp;<var class="var">op3</var><!-- /@w -->)
rounded in the direction <var class="var">rnd</var>.  Concerning special values (signed zeros,
infinities, NaN), these functions behave like a multiplication followed by a
separate addition or subtraction.  That is, the fused operation matters only
for rounding.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffmma"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fmma</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_t <var class="var">op3</var>, mpfr_t <var class="var">op4</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffmma'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffmms"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fmms</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_t <var class="var">op3</var>, mpfr_t <var class="var">op4</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffmms'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to
(<var class="var">op1</var>&nbsp;times&nbsp;<var class="var">op2</var>)&nbsp;+&nbsp;(<var class="var">op3</var>&nbsp;times&nbsp;<var class="var">op4</var>)<!-- /@w -->
(resp.
(<var class="var">op1</var>&nbsp;times&nbsp;<var class="var">op2</var>)&nbsp;&minus;&nbsp;(<var class="var">op3</var>&nbsp;times&nbsp;<var class="var">op4</var>)<!-- /@w -->)
rounded in the direction <var class="var">rnd</var>.
In case the computation of <var class="var">op1</var>&nbsp;times&nbsp;<var class="var">op2</var><!-- /@w --> overflows or
underflows (or that of <var class="var">op3</var>&nbsp;times&nbsp;<var class="var">op4</var><!-- /@w -->), the result
<var class="var">rop</var> is computed as if the two intermediate products were computed with
rounding toward zero.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fhypot"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_hypot</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fhypot'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the Euclidean norm of <var class="var">x</var> and <var class="var">y</var>, i.e.,
the square root of the sum of the squares
of <var class="var">x</var> and <var class="var">y</var>, rounded in the direction <var class="var">rnd</var>.
Special values are handled as described in the ISO C99 (Section&nbsp;F.9.4.3)
and IEEE&nbsp;754 (Section&nbsp;9.2.1) standards:
If <var class="var">x</var> or <var class="var">y</var> is an infinity, then +Inf is returned in <var class="var">rop</var>,
even if the other number is NaN.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsum"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sum</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, const mpfr_ptr <var class="var">tab</var>[], unsigned long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsum'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the sum of all elements of <var class="var">tab</var>, whose size is <var class="var">n</var>,
correctly rounded in the direction <var class="var">rnd</var>. Warning: for efficiency reasons,
<var class="var">tab</var> is an array of pointers
to <code class="code">mpfr_t</code>, not an array of <code class="code">mpfr_t</code>.
If <var class="var">n</var>&nbsp;=&nbsp;0<!-- /@w -->, then the result is +0, and if <var class="var">n</var>&nbsp;=&nbsp;1<!-- /@w -->,
then the function is equivalent to <code class="code">mpfr_set</code>.
For the special exact cases, the result is the same as the one obtained
with a succession of additions (<code class="code">mpfr_add</code>) in infinite precision.
In particular, if the result is an exact zero and <var class="var">n</var>&nbsp;&gt;=&nbsp;1<!-- /@w -->:
</p><ul class="itemize mark-bullet">
<li>if all the inputs have the same sign (i.e., all +0 or
all &minus;0), then the result has the same sign as the inputs;
</li><li>otherwise, either because all inputs are zeros with at least
a +0 and a &minus;0, or because some inputs are non-zero
(but they globally cancel), the result is +0, except for the
<code class="code">MPFR_RNDD</code> rounding mode, where it is &minus;0.
</li></ul>
</dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdot"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_dot</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, const mpfr_ptr <var class="var">a</var>[], const mpfr_ptr <var class="var">b</var>[], unsigned long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdot'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the dot product of elements of <var class="var">a</var> by those of <var class="var">b</var>,
whose common size is <var class="var">n</var>,
correctly rounded in the direction <var class="var">rnd</var>. Warning: for efficiency reasons,
<var class="var">a</var> and <var class="var">b</var> are arrays of pointers to <code class="code">mpfr_t</code>.
This function is experimental, and does not yet handle intermediate overflows
and underflows.
</p></dd></dl>
<p>For the power functions (with an integer exponent or not), see <a class="ref" href="#mpfr_005fpow">mpfr_pow</a>
in <a class="ref" href="#Transcendental-Functions">Transcendental Functions</a>.
</p>
<hr>
</div>
<div class="section-level-extent" id="Comparison-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Transcendental-Functions" accesskey="n" rel="next">Transcendental Functions</a>, Previous: <a href="#Arithmetic-Functions" accesskey="p" rel="prev">Arithmetic Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Comparison-functions"></a>
<h3 class="section" id="Comparison-Functions-1">5.6 Comparison Functions</h3>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcmp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmp_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmp_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmp_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005fd'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmp_005fld"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_ld</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, long double <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005fld'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmp_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005fz'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmp_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005fq'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmp_005ff"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_f</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpf_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005ff'> &para;</a></span></dt>
<dd><p>Compare <var class="var">op1</var> and <var class="var">op2</var>.
Return a positive value if <var class="var">op1</var>&nbsp;&gt;&nbsp;<var class="var">op2</var><!-- /@w -->,
zero if <var class="var">op1</var>&nbsp;=&nbsp;<var class="var">op2</var><!-- /@w -->, and
a negative value if <var class="var">op1</var>&nbsp;&lt;&nbsp;<var class="var">op2</var><!-- /@w -->.
Both <var class="var">op1</var> and <var class="var">op2</var> are considered to their full own precision,
which may differ.
If one of the operands is NaN, set the <em class="emph">erange</em> flag and return zero.
</p>
<p>Note: These functions may be useful to distinguish the three possible cases.
If you need to distinguish two cases only, it is recommended to use the
predicate functions (e.g., <code class="code">mpfr_equal_p</code> for the equality) described
below; they behave like the IEEE&nbsp;754 comparisons, in particular when one
or both arguments are NaN. But only floating-point numbers can be compared
(you may need to do a conversion first).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcmp_005fui_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_ui_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_exp_t <var class="var">e</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005fui_005f2exp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmp_005fsi_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmp_si_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_exp_t <var class="var">e</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmp_005fsi_005f2exp'> &para;</a></span></dt>
<dd><p>Compare <var class="var">op1</var> and <var class="var">op2</var> multiplied by two to
the power <var class="var">e</var>. Similar as above.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcmpabs"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmpabs</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmpabs'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcmpabs_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cmpabs_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fcmpabs_005fui'> &para;</a></span></dt>
<dd><p>Compare |<var class="var">op1</var>|<!-- /@w --> and |<var class="var">op2</var>|<!-- /@w -->.
Return a positive value if |<var class="var">op1</var>|&nbsp;&gt;&nbsp;|<var class="var">op2</var>|<!-- /@w -->,
zero if |<var class="var">op1</var>|&nbsp;=&nbsp;|<var class="var">op2</var>|<!-- /@w -->, and
a negative value if |<var class="var">op1</var>|&nbsp;&lt;&nbsp;|<var class="var">op2</var>|<!-- /@w -->.
If one of the operands is NaN, set the <em class="emph">erange</em> flag and return zero.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fnan_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_nan_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fnan_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005finf_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_inf_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005finf_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fnumber_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_number_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fnumber_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fzero_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_zero_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fzero_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fregular_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_regular_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fregular_005fp'> &para;</a></span></dt>
<dd><p>Return non-zero if <var class="var">op</var> is respectively NaN, an infinity, an ordinary
number (i.e., neither NaN nor an infinity), zero, or a regular number
(i.e., neither NaN, nor an infinity nor zero). Return zero otherwise.
</p></dd></dl>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-mpfr_005fsgn"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sgn</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fsgn'> &para;</a></span></dt>
<dd><p>Return a positive value if <var class="var">op</var>&nbsp;&gt;&nbsp;0<!-- /@w -->, zero if <var class="var">op</var>&nbsp;=&nbsp;0<!-- /@w -->,
and a negative value if <var class="var">op</var>&nbsp;&lt;&nbsp;0<!-- /@w -->.
If the operand is NaN, set the <em class="emph">erange</em> flag and return zero.
This is equivalent to <code class="code">mpfr_cmp_ui (<var class="var">op</var>, 0)</code>, but more efficient.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fgreater_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_greater_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fgreater_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fgreaterequal_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_greaterequal_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fgreaterequal_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fless_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_less_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fless_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005flessequal_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_lessequal_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005flessequal_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fequal_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_equal_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005fequal_005fp'> &para;</a></span></dt>
<dd><p>Return non-zero if
<var class="var">op1</var>&nbsp;&gt;&nbsp;<var class="var">op2</var><!-- /@w -->,
<var class="var">op1</var>&nbsp;&gt;=&nbsp;<var class="var">op2</var><!-- /@w -->,
<var class="var">op1</var>&nbsp;&lt;&nbsp;<var class="var">op2</var><!-- /@w -->,
<var class="var">op1</var>&nbsp;&lt;=&nbsp;<var class="var">op2</var><!-- /@w -->,
<var class="var">op1</var>&nbsp;=&nbsp;<var class="var">op2</var><!-- /@w --> respectively,
and zero otherwise.
Those functions return zero whenever <var class="var">op1</var> and/or <var class="var">op2</var> is NaN.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005flessgreater_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_lessgreater_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005flessgreater_005fp'> &para;</a></span></dt>
<dd><p>Return non-zero if <var class="var">op1</var>&nbsp;&lt;&nbsp;<var class="var">op2</var><!-- /@w --> or <var class="var">op1</var>&nbsp;&gt;&nbsp;<var class="var">op2</var><!-- /@w -->
(i.e., neither <var class="var">op1</var>, nor <var class="var">op2</var> is NaN, and
<var class="var">op1</var>&nbsp;&lt;&gt;&nbsp;<var class="var">op2</var><!-- /@w -->), zero otherwise (i.e., <var class="var">op1</var>
and/or <var class="var">op2</var> is NaN, or <var class="var">op1</var>&nbsp;=&nbsp;<var class="var">op2</var><!-- /@w -->).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005funordered_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_unordered_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>)</code><a class="copiable-link" href='#index-mpfr_005funordered_005fp'> &para;</a></span></dt>
<dd><p>Return non-zero if <var class="var">op1</var> or <var class="var">op2</var> is a NaN (i.e., they cannot be
compared), zero otherwise.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ftotal_005forder_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_total_order_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>)</code><a class="copiable-link" href='#index-mpfr_005ftotal_005forder_005fp'> &para;</a></span></dt>
<dd><p>This function implements the totalOrder predicate from IEEE&nbsp;754,
where &minus;NaN &lt; &minus;Inf &lt; negative finite numbers
&lt; &minus;0 &lt; +0 &lt; positive finite numbers
&lt; +Inf &lt; +NaN.
It returns a non-zero value (true) when <var class="var">x</var> is smaller than or equal
to <var class="var">y</var> for this order relation, and zero (false) otherwise.
Contrary to <code class="code">mpfr_cmp (<var class="var">x</var>, <var class="var">y</var>)</code>, which returns a ternary value,
<code class="code">mpfr_total_order_p</code> returns a binary value (zero or non-zero).
In particular, <code class="code">mpfr_total_order_p (<var class="var">x</var>, <var class="var">x</var>)</code> returns true,
<code class="code">mpfr_total_order_p (-0, +0)</code> returns true and
<code class="code">mpfr_total_order_p (+0, -0)</code> returns false.
The sign bit of NaN also matters.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Transcendental-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Input-and-Output-Functions" accesskey="n" rel="next">Input and Output Functions</a>, Previous: <a href="#Comparison-Functions" accesskey="p" rel="prev">Comparison Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Transcendental-functions"></a>
<h3 class="section" id="Transcendental-Functions-1">5.7 Transcendental Functions</h3>
<p>All those functions, except explicitly stated (for example
<code class="code">mpfr_sin_cos</code>), return a <a class="ref" href="constant.MPFR_Basics.html#ternary-value">ternary value</a>, i.e., zero for an
exact return value, a positive value for a return value larger than the
exact result, and a negative value otherwise.
</p>
<p>Important note: In some domains, computing transcendental functions
(even more with correct rounding) is expensive, even in small precision,
for example the trigonometric and Bessel functions with a large argument.
For some functions, the algorithm complexity and memory usage does not
depend only on the output precision: for instance, the memory usage of
<code class="code">mpfr_rootn_ui</code> is also linear in the argument <var class="var">k</var>, and the
memory usage of the incomplete Gamma function also depends on the
precision of the input <var class="var">op</var>. It is also theoretically possible that
some functions on some particular inputs might be very hard to round
(i.e. the Table Maker&rsquo;s Dilemma occurs in much larger precisions than
normally expected from the context), meaning that the internal precision
needs to be increased even more; but it is conjectured that the needed
precision has a reasonable bound (and in particular, that potentially
exact cases are known and can be detected efficiently).
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005flog"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_log</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flog'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005flog_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_log_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flog_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005flog2"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_log2</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flog2'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005flog10"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_log10</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flog10'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the natural logarithm of <var class="var">op</var>,
log2(<var class="var">op</var>) or
log10(<var class="var">op</var>), respectively,
rounded in the direction <var class="var">rnd</var>.
Set <var class="var">rop</var> to +0 if <var class="var">op</var> is 1 (in all rounding modes),
for consistency with the ISO C99 and IEEE&nbsp;754 standards.
Set <var class="var">rop</var> to &minus;Inf if <var class="var">op</var> is ±0
(i.e., the sign of the zero has no influence on the result).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005flog1p"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_log1p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flog1p'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005flog2p1"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_log2p1</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flog2p1'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005flog10p1"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_log10p1</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flog10p1'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the logarithm of one plus <var class="var">op</var> (in radix two for
<code class="code">mpfr_log2p1</code>, and in radix ten for <code class="code">mpfr_log10p1</code>), rounded in the
direction <var class="var">rnd</var>.
Set <var class="var">rop</var> to &minus;Inf if <var class="var">op</var> is &minus;1.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fexp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fexp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fexp2"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_exp2</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fexp2'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fexp10"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_exp10</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fexp10'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the exponential of <var class="var">op</var>,
 to 2 power of <var class="var">op</var>
or to 10 power of <var class="var">op</var>, respectively,
rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fexpm1"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_expm1</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fexpm1'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fexp2m1"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_exp2m1</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fexp2m1'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fexp10m1"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_exp10m1</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fexp10m1'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the exponential of <var class="var">op</var> followed by a
subtraction by one
(resp. 2 power of <var class="var">op</var> followed by a
subtraction by one,
and 10 power of <var class="var">op</var> followed by a subtraction by one),
rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<a class="anchor" id="mpfr_005fpow"></a><dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fpow"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_pow</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fpow'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fpowr"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_powr</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fpowr'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fpow_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_pow_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fpow_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fpow_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_pow_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fpow_005fsi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fpow_005fuj"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_pow_uj</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, uintmax_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fpow_005fuj'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fpow_005fsj"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_pow_sj</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, intmax_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fpow_005fsj'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fpown"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_pown</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, intmax_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fpown'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fpow_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_pow_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fpow_005fz'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fui_005fpow_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_ui_pow_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fui_005fpow_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fui_005fpow"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_ui_pow</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fui_005fpow'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> raised to <var class="var">op2</var>,
rounded in the direction <var class="var">rnd</var>.
The <code class="code">mpfr_powr</code> function corresponds to the <code class="code">powr</code> function
from IEEE&nbsp;754, i.e., it computes the exponential of
<var class="var">op2</var> multiplied by the logarithm of <var class="var">op1</var>.
The <code class="code">mpfr_pown</code> function is just an alias for <code class="code">mpfr_pow_sj</code>
(defined with <code class="code">#define mpfr_pown mpfr_pow_sj</code>), to follow the
C2x function <code class="code">pown</code>.
Special values are handled as described in the ISO C99 and IEEE&nbsp;754
standards for the <code class="code">pow</code> function:
</p><ul class="itemize mark-bullet">
<li><code class="code">pow(±0, <var class="var">y</var>)</code> returns ±Inf for <var class="var">y</var> a negative odd integer.
</li><li><code class="code">pow(±0, <var class="var">y</var>)</code> returns +Inf for <var class="var">y</var> negative and not an odd integer.
</li><li><code class="code">pow(±0, <var class="var">y</var>)</code> returns ±0 for <var class="var">y</var> a positive odd integer.
</li><li><code class="code">pow(±0, <var class="var">y</var>)</code> returns +0 for <var class="var">y</var> positive and not an odd integer.
</li><li><code class="code">pow(-1, ±Inf)</code> returns 1.
</li><li><code class="code">pow(+1, <var class="var">y</var>)</code> returns 1 for any <var class="var">y</var>, even a NaN.
</li><li><code class="code">pow(<var class="var">x</var>, ±0)</code> returns 1 for any <var class="var">x</var>, even a NaN.
</li><li><code class="code">pow(<var class="var">x</var>, <var class="var">y</var>)</code> returns NaN for finite negative <var class="var">x</var> and finite non-integer <var class="var">y</var>.
</li><li><code class="code">pow(<var class="var">x</var>, -Inf)</code> returns +Inf for 0&nbsp;&lt;&nbsp;abs(x)&nbsp;&lt;&nbsp;1<!-- /@w -->, and +0 for abs(x)&nbsp;&gt;&nbsp;1<!-- /@w -->.
</li><li><code class="code">pow(<var class="var">x</var>, +Inf)</code> returns +0 for 0&nbsp;&lt;&nbsp;abs(x)&nbsp;&lt;&nbsp;1<!-- /@w -->, and +Inf for abs(x)&nbsp;&gt;&nbsp;1<!-- /@w -->.
</li><li><code class="code">pow(-Inf, <var class="var">y</var>)</code> returns &minus;0 for <var class="var">y</var> a negative odd integer.
</li><li><code class="code">pow(-Inf, <var class="var">y</var>)</code> returns +0 for <var class="var">y</var> negative and not an odd integer.
</li><li><code class="code">pow(-Inf, <var class="var">y</var>)</code> returns &minus;Inf for <var class="var">y</var> a positive odd integer.
</li><li><code class="code">pow(-Inf, <var class="var">y</var>)</code> returns +Inf for <var class="var">y</var> positive and not an odd integer.
</li><li><code class="code">pow(+Inf, <var class="var">y</var>)</code> returns +0 for <var class="var">y</var> negative, and +Inf for <var class="var">y</var> positive.
</li></ul>
<p>Note: When 0 is of integer type, it is regarded as +0 by these functions.
We do not use the usual limit rules in this case, as these rules are not
used for <code class="code">pow</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcompound_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_compound_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcompound_005fsi'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the power <var class="var">n</var> of one plus <var class="var">op</var>,
following IEEE&nbsp;754 for the special cases and exceptions.
When <var class="var">n</var> is zero and <var class="var">op</var> is NaN or greater or equal to &minus;1,
<var class="var">rop</var> is set to 1.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcos"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cos</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcos'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsin"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sin</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsin'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ftan"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_tan</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ftan'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the cosine of <var class="var">op</var>, sine of <var class="var">op</var>,
tangent of <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcosu"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cosu</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">u</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcosu'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsinu"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sinu</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">u</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsinu'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ftanu"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_tanu</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">u</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ftanu'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the cosine (resp. sine and tangent) of
<var class="var">op</var> multiplied by 2&nbsp;Pi and divided
by <var class="var">u</var>. For example, if <var class="var">u</var> equals 360, one gets the cosine
(resp. sine and tangent) for <var class="var">op</var> in degrees. For <code class="code">mpfr_cosu</code>, when
<var class="var">op</var> multiplied by 2 and divided by <var class="var">u</var>
is a half-integer, the result is +0, following IEEE&nbsp;754 (cosPi),
so that the function is even. For <code class="code">mpfr_sinu</code>, when
<var class="var">op</var> multiplied by 2 and divided by <var class="var">u</var>
is an integer, the result is zero with the same sign as <var class="var">op</var>, following
IEEE&nbsp;754 (sinPi), so that the function is odd.
Similarly, the function <code class="code">mpfr_tanu</code> follows IEEE&nbsp;754 (tanPi).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcospi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cospi</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcospi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsinpi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sinpi</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsinpi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ftanpi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_tanpi</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ftanpi'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the cosine (resp. sine and tangent) of
<var class="var">op</var> multiplied by Pi. See the description of
<code class="code">mpfr_sinu</code>, <code class="code">mpfr_cosu</code> and <code class="code">mpfr_tanu</code> for special values.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsin_005fcos"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sin_cos</strong> <code class="def-code-arguments">(mpfr_t <var class="var">sop</var>, mpfr_t <var class="var">cop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsin_005fcos'> &para;</a></span></dt>
<dd><p>Set simultaneously <var class="var">sop</var> to the sine of <var class="var">op</var> and <var class="var">cop</var> to the
cosine of <var class="var">op</var>, rounded in the direction <var class="var">rnd</var> with the corresponding
precisions of <var class="var">sop</var> and <var class="var">cop</var>, which must be different variables.
Return 0 iff both results are exact, more precisely it returns s&nbsp;+&nbsp;4c<!-- /@w -->
where s&nbsp;=&nbsp;0<!-- /@w --> if <var class="var">sop</var> is exact, s&nbsp;=&nbsp;1<!-- /@w --> if <var class="var">sop</var> is larger
than the sine of <var class="var">op</var>, s&nbsp;=&nbsp;2<!-- /@w --> if <var class="var">sop</var> is smaller than the sine
of <var class="var">op</var>, and similarly for c<!-- /@w --> and the cosine of <var class="var">op</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsec"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sec</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsec'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcsc"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_csc</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcsc'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcot"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cot</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcot'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the secant of <var class="var">op</var>, cosecant of <var class="var">op</var>,
cotangent of <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005facos"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_acos</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005facos'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fasin"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_asin</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fasin'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fatan"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_atan</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fatan'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the arc-cosine, arc-sine or arc-tangent of <var class="var">op</var>,
rounded in the direction <var class="var">rnd</var>.
Note that since <code class="code">acos(-1)</code> returns the floating-point number closest to
Pi according to the given rounding mode, this number might not be
in the output range 0 &lt;= <var class="var">rop</var> &lt; Pi
of the arc-cosine function;
still, the result lies in the image of the output range
by the rounding function.
The same holds for <code class="code">asin(-1)</code>, <code class="code">asin(1)</code>, <code class="code">atan(-Inf)</code>,
<code class="code">atan(+Inf)</code> or for <code class="code">atan(<var class="var">op</var>)</code> with large <var class="var">op</var> and
small precision of <var class="var">rop</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005facosu"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_acosu</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">u</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005facosu'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fasinu"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_asinu</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">u</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fasinu'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fatanu"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_atanu</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">u</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fatanu'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">a</var> multiplied
by <var class="var">u</var> and divided by 2&nbsp;Pi, where <var class="var">a</var> is the arc-cosine
(resp. arc-sine and arc-tangent) of <var class="var">op</var>.
For example, if <var class="var">u</var> equals 360, <code class="code">mpfr_acosu</code> yields the arc-cosine in
degrees.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005facospi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_acospi</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005facospi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fasinpi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_asinpi</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fasinpi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fatanpi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_atanpi</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fatanpi'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <code class="code">acos(<var class="var">op</var>)</code> (resp. <code class="code">asin(<var class="var">op</var>)</code> and
<code class="code">atan(<var class="var">op</var>)</code>) divided by Pi.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fatan2"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_atan2</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">y</var>, mpfr_t <var class="var">x</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fatan2'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fatan2u"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_atan2u</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">y</var>, mpfr_t <var class="var">x</var>, unsigned long int <var class="var">u</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fatan2u'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fatan2pi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_atan2pi</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">y</var>, mpfr_t <var class="var">x</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fatan2pi'> &para;</a></span></dt>
<dd><p>For <code class="code">mpfr_atan2</code>, set <var class="var">rop</var> to the arc-tangent2 of <var class="var">y</var> and
<var class="var">x</var>, rounded in the direction <var class="var">rnd</var>:
if <var class="var">x</var>&nbsp;&gt;&nbsp;0<!-- /@w -->, then <code class="code">atan2(<var class="var">y</var>, <var class="var">x</var>)</code> returns
atan(<var class="var">y</var>/<var class="var">x</var>)<!-- /@w -->;
if <var class="var">x</var>&nbsp;&lt;&nbsp;0<!-- /@w -->, then <code class="code">atan2(<var class="var">y</var>, <var class="var">x</var>)</code> returns
the sign
of <var class="var">y</var> multiplied by Pi&nbsp;&minus;&nbsp;atan(abs(<var class="var">y</var>/<var class="var">x</var>))<!-- /@w -->,
thus a number from &minus;Pi to Pi.
As for <code class="code">atan</code>, in case the exact mathematical result is +Pi or
&minus;Pi,
its rounded result might be outside the function output range.
The function <code class="code">mpfr_atan2u</code> behaves similarly, except the result is
multiplied by <var class="var">u</var> and divided by 2&nbsp;Pi; and
<code class="code">mpfr_atan2pi</code> is the same as <code class="code">mpfr_atan2u</code> with <var class="var">u</var>&nbsp;=&nbsp;2<!-- /@w -->.
For example, if <var class="var">u</var> equals 360, <code class="code">mpfr_atan2u</code> returns the
arc-tangent in degrees, with values from &minus;180 to 180.
</p>
<p><code class="code">atan2(<var class="var">y</var>, 0)</code> does not raise any floating-point exception.
Special values are handled as described in the ISO C99 and IEEE&nbsp;754
standards for the <code class="code">atan2</code> function:
</p><ul class="itemize mark-bullet">
<li><code class="code">atan2(+0, -0)</code> returns +Pi.
</li><li><code class="code">atan2(-0, -0)</code> returns &minus;Pi.
</li><li><code class="code">atan2(+0, +0)</code> returns +0.
</li><li><code class="code">atan2(-0, +0)</code> returns &minus;0.
</li><li><code class="code">atan2(+0, <var class="var">x</var>)</code> returns +Pi for <var class="var">x</var>&nbsp;&lt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(-0, <var class="var">x</var>)</code> returns &minus;Pi for <var class="var">x</var>&nbsp;&lt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(+0, <var class="var">x</var>)</code> returns +0 for <var class="var">x</var>&nbsp;&gt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(-0, <var class="var">x</var>)</code> returns &minus;0 for <var class="var">x</var>&nbsp;&gt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(<var class="var">y</var>, 0)</code> returns &minus;Pi/2 for <var class="var">y</var>&nbsp;&lt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(<var class="var">y</var>, 0)</code> returns +Pi/2 for <var class="var">y</var>&nbsp;&gt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(+Inf, -Inf)</code> returns +3*Pi/4.
</li><li><code class="code">atan2(-Inf, -Inf)</code> returns &minus;3*Pi/4.
</li><li><code class="code">atan2(+Inf, +Inf)</code> returns +Pi/4.
</li><li><code class="code">atan2(-Inf, +Inf)</code> returns &minus;Pi/4.
</li><li><code class="code">atan2(+Inf, <var class="var">x</var>)</code> returns +Pi/2 for finite <var class="var">x</var><!-- /@w -->.
</li><li><code class="code">atan2(-Inf, <var class="var">x</var>)</code> returns &minus;Pi/2 for finite <var class="var">x</var><!-- /@w -->.
</li><li><code class="code">atan2(<var class="var">y</var>, -Inf)</code> returns +Pi for finite <var class="var">y</var>&nbsp;&gt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(<var class="var">y</var>, -Inf)</code> returns &minus;Pi for finite <var class="var">y</var>&nbsp;&lt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(<var class="var">y</var>, +Inf)</code> returns +0 for finite <var class="var">y</var>&nbsp;&gt;&nbsp;0<!-- /@w -->.
</li><li><code class="code">atan2(<var class="var">y</var>, +Inf)</code> returns &minus;0 for finite <var class="var">y</var>&nbsp;&lt;&nbsp;0<!-- /@w -->.
</li></ul>
</dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcosh"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cosh</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcosh'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsinh"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sinh</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsinh'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ftanh"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_tanh</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ftanh'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the hyperbolic cosine, sine or tangent of <var class="var">op</var>,
rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsinh_005fcosh"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sinh_cosh</strong> <code class="def-code-arguments">(mpfr_t <var class="var">sop</var>, mpfr_t <var class="var">cop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsinh_005fcosh'> &para;</a></span></dt>
<dd><p>Set simultaneously <var class="var">sop</var> to the hyperbolic sine of <var class="var">op</var> and
<var class="var">cop</var> to the hyperbolic cosine of <var class="var">op</var>,
rounded in the direction <var class="var">rnd</var> with the corresponding precision of
<var class="var">sop</var> and <var class="var">cop</var>, which must be different variables.
Return 0 iff both results are exact (see <code class="code">mpfr_sin_cos</code> for a more
detailed description of the return value).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsech"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sech</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsech'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcsch"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_csch</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcsch'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fcoth"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_coth</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcoth'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the hyperbolic secant of <var class="var">op</var>, cosecant of <var class="var">op</var>,
cotangent of <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005facosh"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_acosh</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005facosh'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fasinh"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_asinh</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fasinh'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fatanh"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_atanh</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fatanh'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the inverse hyperbolic cosine, sine or tangent of <var class="var">op</var>,
rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005feint"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_eint</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005feint'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the exponential integral of <var class="var">op</var>,
rounded in the direction <var class="var">rnd</var>.
This is the sum of Euler&rsquo;s constant, of the logarithm
of the absolute value of <var class="var">op</var>, and of the sum for k<!-- /@w -->
from 1 to infinity of <var class="var">op</var> to the power k, divided by k and the factorial of k.
For positive <var class="var">op</var>, it corresponds to the Ei function at <var class="var">op</var>
(see formula 5.1.10 from the Handbook of Mathematical Functions from
Abramowitz and Stegun),
and for negative <var class="var">op</var>, to the opposite of the
E1 function (sometimes called eint1)
at &minus;<var class="var">op</var> (formula 5.1.1 from the same reference).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fli2"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_li2</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fli2'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to real part of the dilogarithm of <var class="var">op</var>, rounded in the
direction <var class="var">rnd</var>. MPFR defines the dilogarithm function as
the integral of
&minus;log(1&minus;t)/t from 0 to <var class="var">op</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fgamma"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_gamma</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fgamma'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fgamma_005finc"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_gamma_inc</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fgamma_005finc'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the Gamma function on <var class="var">op</var>, resp. the
incomplete Gamma function on <var class="var">op</var> and <var class="var">op2</var>,
rounded in the direction <var class="var">rnd</var>.
(In the literature, <code class="code">mpfr_gamma_inc</code> is called upper
incomplete Gamma function,
or sometimes complementary incomplete Gamma function.)
For <code class="code">mpfr_gamma</code> (and <code class="code">mpfr_gamma_inc</code> when <var class="var">op2</var> is zero),
when <var class="var">op</var> is a negative integer, <var class="var">rop</var> is set to NaN.
</p>
<p>Note: the current implementation of <code class="code">mpfr_gamma_inc</code> is slow for
large values of <var class="var">rop</var> or <var class="var">op</var>, in which case some internal overflow
might also occur.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005flngamma"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_lngamma</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flngamma'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the logarithm of the Gamma function on <var class="var">op</var>,
rounded in the direction <var class="var">rnd</var>.
When <var class="var">op</var> is 1 or 2, set <var class="var">rop</var> to +0 (in all rounding modes).
When <var class="var">op</var> is an infinity or a non-positive integer, set <var class="var">rop</var> to
+Inf, following the general rules on special values.
When &minus;2k&nbsp;&minus;&nbsp;1&nbsp;&lt;&nbsp;<var class="var">op</var>&nbsp;&lt;&nbsp;&minus;2k<!-- /@w -->,
k<!-- /@w --> being a non-negative integer, set <var class="var">rop</var> to NaN.
See also <code class="code">mpfr_lgamma</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005flgamma"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_lgamma</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, int *<var class="var">signp</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005flgamma'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the logarithm of the absolute value of the
Gamma function on <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>. The sign
(1 or &minus;1) of Gamma(<var class="var">op</var>) is returned in the object pointed to
by <var class="var">signp</var>.
When <var class="var">op</var> is 1 or 2, set <var class="var">rop</var> to +0 (in all rounding modes).
When <var class="var">op</var> is an infinity or a non-positive integer, set <var class="var">rop</var> to
+Inf.
When <var class="var">op</var> is NaN, &minus;Inf or a negative integer, *<var class="var">signp</var> is
undefined, and when <var class="var">op</var> is ±0, *<var class="var">signp</var> is the sign of the zero.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdigamma"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_digamma</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdigamma'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the Digamma (sometimes also called Psi)
function on <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>.
When <var class="var">op</var> is a negative integer, set <var class="var">rop</var> to NaN.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fbeta"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_beta</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fbeta'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the Beta function at arguments <var class="var">op1</var> and
<var class="var">op2</var>.
Note: the current code does not try to avoid internal overflow or underflow,
and might use a huge internal precision in some cases.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fzeta"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_zeta</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fzeta'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fzeta_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_zeta_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fzeta_005fui'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the Riemann Zeta function on <var class="var">op</var>,
rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ferf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_erf</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ferf'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ferfc"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_erfc</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ferfc'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the error function on <var class="var">op</var>
(resp. the complementary error function on <var class="var">op</var>)
rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fj0"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_j0</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fj0'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fj1"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_j1</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fj1'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fjn"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_jn</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">n</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fjn'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the first kind Bessel function of order 0,
(resp. 1 and <var class="var">n</var>)
on <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>. When <var class="var">op</var> is NaN,
<var class="var">rop</var> is always set to NaN. When <var class="var">op</var> is positive or negative infinity,
<var class="var">rop</var> is set to +0. When <var class="var">op</var> is zero, and <var class="var">n</var> is not zero,
<var class="var">rop</var> is set to +0 or &minus;0 depending on the parity and sign of
<var class="var">n</var>, and the sign of <var class="var">op</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fy0"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_y0</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fy0'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fy1"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_y1</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fy1'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fyn"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_yn</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">n</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fyn'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the second kind Bessel function of order 0
(resp. 1 and <var class="var">n</var>)
on <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>. When <var class="var">op</var> is
NaN or negative, <var class="var">rop</var> is always set to NaN. When <var class="var">op</var> is +Inf,
<var class="var">rop</var> is set to +0. When <var class="var">op</var> is zero, <var class="var">rop</var> is set to
+Inf or &minus;Inf depending on the parity and sign of <var class="var">n</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fagm"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_agm</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fagm'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the arithmetic-geometric mean of <var class="var">op1</var> and <var class="var">op2</var>,
rounded in the direction <var class="var">rnd</var>.
The arithmetic-geometric mean is the common limit of the sequences
u_n and v_n, where <span class="w-nolinebreak-text">u_0</span>&nbsp;=&nbsp;<var class="var">op1</var><!-- /@w -->, <span class="w-nolinebreak-text">v_0</span>&nbsp;=&nbsp;<var class="var">op2</var><!-- /@w -->,
u_(n+1) is the arithmetic mean of u_n and v_n, and
v_(n+1) is the geometric mean of u_n and v_n.
If any operand is negative and the other one is not zero,
set <var class="var">rop</var> to NaN.
If any operand is zero and the other one is finite (resp. infinite),
set <var class="var">rop</var> to +0 (resp. NaN).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fai"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_ai</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">x</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fai'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the Airy function Ai
 on <var class="var">x</var>, rounded in the direction <var class="var">rnd</var>.
When <var class="var">x</var> is
NaN,
<var class="var">rop</var> is always set to NaN. When <var class="var">x</var> is +Inf or &minus;Inf,
<var class="var">rop</var> is +0.
The current implementation is not intended to be used with large arguments.
It works with abs(<var class="var">x</var>) typically smaller than 500. For larger arguments,
other methods should be used and will be implemented in a future version.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fconst_005flog2"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_const_log2</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fconst_005flog2'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fconst_005fpi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_const_pi</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fconst_005fpi'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fconst_005feuler"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_const_euler</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fconst_005feuler'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fconst_005fcatalan"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_const_catalan</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fconst_005fcatalan'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the logarithm of 2, the value of Pi,
of Euler&rsquo;s constant 0.577&hellip;, of Catalan&rsquo;s constant 0.915&hellip;,
respectively, rounded in the direction
<var class="var">rnd</var>. These functions cache the computed values to avoid other
calculations if a lower or equal precision is requested. To free these caches,
use <code class="code">mpfr_free_cache</code> or <code class="code">mpfr_free_cache2</code>.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Input-and-Output-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Formatted-Output-Functions" accesskey="n" rel="next">Formatted Output Functions</a>, Previous: <a href="#Transcendental-Functions" accesskey="p" rel="prev">Transcendental Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Input-functions"></a>
<a class="index-entry-id" id="index-Output-functions"></a>
<a class="index-entry-id" id="index-I_002fO-functions"></a>
<h3 class="section" id="Input-and-Output-Functions-1">5.8 Input and Output Functions</h3>
<p>This section describes functions that perform input from an input/output
stream, and functions that output to an input/output stream.
Passing a null pointer for a <code class="code">stream</code> to any of these functions will make
them read from <code class="code">stdin</code> and write to <code class="code">stdout</code>, respectively.
</p>
<p>When using a function that takes a <code class="code">FILE *</code> argument, you must
include the <code class="code">&lt;stdio.h&gt;</code> standard header before <samp class="file">mpfr.h</samp>,
to allow <samp class="file">mpfr.h</samp> to define prototypes for these functions.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fout_005fstr"><span class="category-def">Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">mpfr_out_str</strong> <code class="def-code-arguments">(FILE *<var class="var">stream</var>, int <var class="var">base</var>, size_t <var class="var">n</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fout_005fstr'> &para;</a></span></dt>
<dd><p>Output <var class="var">op</var> on stream <var class="var">stream</var> as a text string in
base abs(<var class="var">base</var>), rounded in the direction <var class="var">rnd</var>.
The base may vary from 2 to 62 or from &minus;2 to &minus;36
(any other value yields undefined behavior). The argument <var class="var">n</var> has
the same meaning as in <code class="code">mpfr_get_str</code> (see <a class="pxref" href="#mpfr_005fget_005fstr">mpfr_get_str</a>):
Print <var class="var">n</var> significant digits exactly, or if <var class="var">n</var> is 0, the number
<code class="code">mpfr_get_str_ndigits (<var class="var">base</var>, <var class="var">p</var>)</code>, where <var class="var">p</var> is the
precision of <var class="var">op</var> (see <a class="pxref" href="#mpfr_005fget_005fstr_005fndigits">mpfr_get_str_ndigits</a>).
</p>
<p>If the input is NaN, +Inf, &minus;Inf, +0, or &minus;0, then
&lsquo;<samp class="samp">@NaN@</samp>&rsquo;, &lsquo;<samp class="samp">@Inf@</samp>&rsquo;, &lsquo;<samp class="samp">-@Inf@</samp>&rsquo;, &lsquo;<samp class="samp">0</samp>&rsquo;, or
&lsquo;<samp class="samp">-0</samp>&rsquo; is output, respectively.
</p>
<p>For the regular numbers, the format of the output is the following: the
most significant digit, then a decimal-point character (defined by the
current locale), then the remaining <var class="var">n</var>&nbsp;&minus;&nbsp;1<!-- /@w --> digits (including
trailing zeros), then the exponent prefix, then the exponent in decimal.
The exponent prefix is &lsquo;<samp class="samp">e</samp>&rsquo; when abs(<var class="var">base</var>)&nbsp;&lt;=&nbsp;10<!-- /@w -->,
and &lsquo;<samp class="samp">@</samp>&rsquo; when abs(<var class="var">base</var>)&nbsp;&gt;&nbsp;10<!-- /@w -->. See <a class="xref" href="#mpfr_005fget_005fstr">mpfr_get_str</a> for
information on the digits depending on the base.
</p>
<p>Return the number of characters written, or if an error occurred, return 0.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005finp_005fstr"><span class="category-def">Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">mpfr_inp_str</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, FILE *<var class="var">stream</var>, int <var class="var">base</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005finp_005fstr'> &para;</a></span></dt>
<dd><p>Input a string in base <var class="var">base</var> from stream <var class="var">stream</var>,
rounded in the direction <var class="var">rnd</var>, and put the
read float in <var class="var">rop</var>.
</p>
<p>This function reads a word (defined as a sequence of characters between
whitespace) and parses it using <code class="code">mpfr_set_str</code>.
See the documentation of <code class="code">mpfr_strtofr</code> for a detailed description
of the valid string formats.
</p>
<p>Return the number of bytes read, or if an error occurred, return 0.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffpif_005fexport"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fpif_export</strong> <code class="def-code-arguments">(FILE *<var class="var">stream</var>, mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005ffpif_005fexport'> &para;</a></span></dt>
<dd><p>Export the number <var class="var">op</var> to the stream <var class="var">stream</var> in a floating-point
interchange format.
In particular one can export on a 32-bit computer and import on a 64-bit
computer, or export on a little-endian computer and import on a big-endian
computer.
The precision of <var class="var">op</var> and the sign bit of a NaN are stored too.
Return 0 iff the export was successful.
</p>
<p>Note: this function is experimental and its interface might change in future
versions.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffpif_005fimport"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fpif_import</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>, FILE *<var class="var">stream</var>)</code><a class="copiable-link" href='#index-mpfr_005ffpif_005fimport'> &para;</a></span></dt>
<dd><p>Import the number <var class="var">op</var> from the stream <var class="var">stream</var> in a floating-point
interchange format (see <code class="code">mpfr_fpif_export</code>).
Note that the precision of <var class="var">op</var> is set to the one read from the stream,
and the sign bit is always retrieved (even for NaN).
If the stored precision is zero or greater than <code class="code">MPFR_PREC_MAX</code>, the
function fails (it returns non-zero) and <var class="var">op</var> is unchanged. If the
function fails for another reason, <var class="var">op</var> is set to NaN and it is
unspecified whether the precision of <var class="var">op</var> has changed to the one
read from the file.
Return 0 iff the import was successful.
</p>
<p>Note: this function is experimental and its interface might change in future
versions.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdump"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_dump</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fdump'> &para;</a></span></dt>
<dd><p>Output <var class="var">op</var> on <code class="code">stdout</code> in some unspecified format, then a newline
character. This function is mainly for debugging purpose. Thus invalid data
may be supported. Everything that is not specified may change without
breaking the ABI and may depend on the environment.
</p>
<p>The current output format is the following: a minus sign if the sign bit
is set (even for NaN); &lsquo;<samp class="samp">@NaN@</samp>&rsquo;, &lsquo;<samp class="samp">@Inf@</samp>&rsquo; or &lsquo;<samp class="samp">0</samp>&rsquo; if the
argument is NaN, an infinity or zero, respectively; otherwise the remaining
of the output is as follows: &lsquo;<samp class="samp">0.</samp>&rsquo; then the p<!-- /@w --> bits of the binary
significand, where p<!-- /@w --> is the precision of the number; if the trailing
bits are not all zeros (which must not occur with valid data), they are
output enclosed by square brackets; the character &lsquo;<samp class="samp">E</samp>&rsquo; followed by
the exponent written in base 10; in case of invalid data or out-of-range
exponent, this function outputs three exclamation marks (&lsquo;<samp class="samp">!!!</samp>&rsquo;),
followed by flags, followed by three exclamation marks (&lsquo;<samp class="samp">!!!</samp>&rsquo;) again.
These flags are: &lsquo;<samp class="samp">N</samp>&rsquo; if the most significant bit of the significand
is 0 (i.e., the number is not normalized); &lsquo;<samp class="samp">T</samp>&rsquo; if there are non-zero
trailing bits; &lsquo;<samp class="samp">U</samp>&rsquo; if this is an UBF number (internal use only);
&lsquo;<samp class="samp">&lt;</samp>&rsquo; if the exponent is less than the current minimum exponent;
&lsquo;<samp class="samp">&gt;</samp>&rsquo; if the exponent is greater than the current maximum exponent.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Formatted-Output-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Integer-and-Remainder-Related-Functions" accesskey="n" rel="next">Integer and Remainder Related Functions</a>, Previous: <a href="#Input-and-Output-Functions" accesskey="p" rel="prev">Input and Output Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Output-functions-1"></a>
<a class="index-entry-id" id="index-I_002fO-functions-1"></a>
<h3 class="section" id="Formatted-Output-Functions-1">5.9 Formatted Output Functions</h3>
<ul class="mini-toc">
<li><a href="#Requirements" accesskey="1">Requirements</a></li>
<li><a href="#Format-String" accesskey="2">Format String</a></li>
<li><a href="#Functions" accesskey="3">Functions</a></li>
</ul>
<div class="subsection-level-extent" id="Requirements">
<h4 class="subsection">5.9.1 Requirements</h4>
<p>The class of <code class="code">mpfr_printf</code> functions provides formatted output in a
similar manner as the standard C <code class="code">printf</code>. These functions are defined
only if your system supports ISO C variadic functions and the corresponding
argument access macros.
</p>
<p>When using any of these functions, you must include the <code class="code">&lt;stdio.h&gt;</code>
standard header before <samp class="file">mpfr.h</samp>, to allow <samp class="file">mpfr.h</samp> to define
prototypes for these functions.
</p>
</div>
<div class="subsection-level-extent" id="Format-String">
<h4 class="subsection">5.9.2 Format String</h4>
<p>The format specification accepted by <code class="code">mpfr_printf</code> is an extension of
the <code class="code">gmp_printf</code> one (itself, an extension of the <code class="code">printf</code> one).
The conversion specification is of the form:
</p>
<div class="example">
<pre class="example-preformatted">% [flags] [width] [.[precision]] [type] [rounding] conv
</pre></div>
<p>&lsquo;<samp class="samp">flags</samp>&rsquo;, &lsquo;<samp class="samp">width</samp>&rsquo;, and &lsquo;<samp class="samp">precision</samp>&rsquo; have the same meaning as for
the standard <code class="code">printf</code> (in particular, notice that the precision is
related to the number of digits displayed in the base chosen by &lsquo;<samp class="samp">conv</samp>&rsquo;
and not related to the internal precision of the <code class="code">mpfr_t</code> variable), but
note that for &lsquo;<samp class="samp">Re</samp>&rsquo;, the default precision is not the same as the one for
&lsquo;<samp class="samp">e</samp>&rsquo;.
<code class="code">mpfr_printf</code> accepts the same &lsquo;<samp class="samp">type</samp>&rsquo; specifiers as GMP (except the
non-standard and deprecated &lsquo;<samp class="samp">q</samp>&rsquo;, use &lsquo;<samp class="samp">ll</samp>&rsquo; instead), namely the
length modifiers defined in the C standard:
</p>
<blockquote class="quotation">
<table class="multitable">
<tbody><tr><td>&lsquo;<samp class="samp">h</samp>&rsquo;</td><td><code class="code">short</code></td></tr>
<tr><td>&lsquo;<samp class="samp">hh</samp>&rsquo;</td><td><code class="code">char</code></td></tr>
<tr><td>&lsquo;<samp class="samp">j</samp>&rsquo;</td><td><code class="code">intmax_t</code> or <code class="code">uintmax_t</code></td></tr>
<tr><td>&lsquo;<samp class="samp">l</samp>&rsquo;</td><td><code class="code">long</code> or <code class="code">wchar_t</code></td></tr>
<tr><td>&lsquo;<samp class="samp">ll</samp>&rsquo;</td><td><code class="code">long long</code></td></tr>
<tr><td>&lsquo;<samp class="samp">L</samp>&rsquo;</td><td><code class="code">long double</code></td></tr>
<tr><td>&lsquo;<samp class="samp">t</samp>&rsquo;</td><td><code class="code">ptrdiff_t</code></td></tr>
<tr><td>&lsquo;<samp class="samp">z</samp>&rsquo;</td><td><code class="code">size_t</code></td></tr>
</tbody>
</table>
</blockquote>
<p>and the &lsquo;<samp class="samp">type</samp>&rsquo; specifiers defined in GMP, plus &lsquo;<samp class="samp">R</samp>&rsquo; and &lsquo;<samp class="samp">P</samp>&rsquo;,
which are specific to MPFR (the second column in the table below shows the
type of the argument read in the argument list and the kind of &lsquo;<samp class="samp">conv</samp>&rsquo;
specifier to use after the &lsquo;<samp class="samp">type</samp>&rsquo; specifier):
</p>
<blockquote class="quotation">
<table class="multitable">
<tbody><tr><td>&lsquo;<samp class="samp">F</samp>&rsquo;</td><td><code class="code">mpf_t</code>, float conversions</td></tr>
<tr><td>&lsquo;<samp class="samp">Q</samp>&rsquo;</td><td><code class="code">mpq_t</code>, integer conversions</td></tr>
<tr><td>&lsquo;<samp class="samp">M</samp>&rsquo;</td><td><code class="code">mp_limb_t</code>, integer conversions</td></tr>
<tr><td>&lsquo;<samp class="samp">N</samp>&rsquo;</td><td><code class="code">mp_limb_t</code> array, integer conversions</td></tr>
<tr><td>&lsquo;<samp class="samp">Z</samp>&rsquo;</td><td><code class="code">mpz_t</code>, integer conversions</td></tr>
<tr><td>&lsquo;<samp class="samp">P</samp>&rsquo;</td><td><code class="code">mpfr_prec_t</code>, integer conversions</td></tr>
<tr><td>&lsquo;<samp class="samp">R</samp>&rsquo;</td><td><code class="code">mpfr_t</code>, float conversions</td></tr>
</tbody>
</table>
</blockquote>
<p>The &lsquo;<samp class="samp">type</samp>&rsquo; specifiers have the same restrictions as those
mentioned in the GMP documentation:
see Section &ldquo;Formatted Output Strings&rdquo; in <cite class="cite">GNU MP</cite>.
In particular, the &lsquo;<samp class="samp">type</samp>&rsquo; specifiers (except &lsquo;<samp class="samp">R</samp>&rsquo; and &lsquo;<samp class="samp">P</samp>&rsquo;) are
supported only if they are supported by <code class="code">gmp_printf</code> in your GMP build;
this implies that the standard specifiers, such as &lsquo;<samp class="samp">t</samp>&rsquo;, must <em class="emph">also</em>
be supported by your C library if you want to use them.
</p>
<p>The &lsquo;<samp class="samp">rounding</samp>&rsquo; field is specific to <code class="code">mpfr_t</code> arguments and should
not be used with other types.
</p>
<p>With conversion specification not involving &lsquo;<samp class="samp">P</samp>&rsquo; and &lsquo;<samp class="samp">R</samp>&rsquo; types,
<code class="code">mpfr_printf</code> behaves exactly as <code class="code">gmp_printf</code>.
</p>
<p>Thus the &lsquo;<samp class="samp">conv</samp>&rsquo; specifier &lsquo;<samp class="samp">F</samp>&rsquo; is not supported (due to the use
of &lsquo;<samp class="samp">F</samp>&rsquo; as the &lsquo;<samp class="samp">type</samp>&rsquo; specifier for <code class="code">mpf_t</code>), except for
the &lsquo;<samp class="samp">type</samp>&rsquo; specifier &lsquo;<samp class="samp">R</samp>&rsquo; (i.e., for <code class="code">mpfr_t</code> arguments).
</p>
<p>The &lsquo;<samp class="samp">P</samp>&rsquo; type specifies that a following &lsquo;<samp class="samp">d</samp>&rsquo;, &lsquo;<samp class="samp">i</samp>&rsquo;,
&lsquo;<samp class="samp">o</samp>&rsquo;, &lsquo;<samp class="samp">u</samp>&rsquo;, &lsquo;<samp class="samp">x</samp>&rsquo;, or &lsquo;<samp class="samp">X</samp>&rsquo; conversion specifier applies
to a <code class="code">mpfr_prec_t</code> argument.
It is needed because the <code class="code">mpfr_prec_t</code> type does not necessarily
correspond to an <code class="code">int</code> or any fixed standard type.
The &lsquo;<samp class="samp">precision</samp>&rsquo; value specifies the minimum number of digits to
appear. The default precision is 1.
For example:
</p><div class="example">
<pre class="example-preformatted">mpfr_t x;
mpfr_prec_t p;
mpfr_init (x);
&hellip;
p = mpfr_get_prec (x);
mpfr_printf (&quot;variable x with %Pu bits&quot;, p);
</pre></div>
<p>The &lsquo;<samp class="samp">R</samp>&rsquo; type specifies that a following &lsquo;<samp class="samp">a</samp>&rsquo;, &lsquo;<samp class="samp">A</samp>&rsquo;, &lsquo;<samp class="samp">b</samp>&rsquo;,
&lsquo;<samp class="samp">e</samp>&rsquo;, &lsquo;<samp class="samp">E</samp>&rsquo;, &lsquo;<samp class="samp">f</samp>&rsquo;, &lsquo;<samp class="samp">F</samp>&rsquo;, &lsquo;<samp class="samp">g</samp>&rsquo;, &lsquo;<samp class="samp">G</samp>&rsquo;, or &lsquo;<samp class="samp">n</samp>&rsquo;
conversion specifier applies to a <code class="code">mpfr_t</code> argument.
The &lsquo;<samp class="samp">R</samp>&rsquo; type can be followed by a &lsquo;<samp class="samp">rounding</samp>&rsquo; specifier denoted by
one of the following characters:
</p>
<blockquote class="quotation">
<table class="multitable">
<tbody><tr><td>&lsquo;<samp class="samp">U</samp>&rsquo;</td><td>round toward positive infinity</td></tr>
<tr><td>&lsquo;<samp class="samp">D</samp>&rsquo;</td><td>round toward negative infinity</td></tr>
<tr><td>&lsquo;<samp class="samp">Y</samp>&rsquo;</td><td>round away from zero</td></tr>
<tr><td>&lsquo;<samp class="samp">Z</samp>&rsquo;</td><td>round toward zero</td></tr>
<tr><td>&lsquo;<samp class="samp">N</samp>&rsquo;</td><td>round to nearest (with ties to even)</td></tr>
<tr><td>&lsquo;<samp class="samp">*</samp>&rsquo;</td><td>rounding mode indicated by the <code class="code">mpfr_rnd_t</code> argument
just before the corresponding <code class="code">mpfr_t</code> variable.</td></tr>
</tbody>
</table>
</blockquote>
<p>The default rounding mode is rounding to nearest.
The following three examples are equivalent:
</p><div class="example">
<pre class="example-preformatted">mpfr_t x;
mpfr_init (x);
&hellip;
mpfr_printf (&quot;%.128Rf&quot;, x);
mpfr_printf (&quot;%.128RNf&quot;, x);
mpfr_printf (&quot;%.128R*f&quot;, MPFR_RNDN, x);
</pre></div>
<p>Note that the rounding away from zero mode is specified with &lsquo;<samp class="samp">Y</samp>&rsquo;
because ISO C reserves the &lsquo;<samp class="samp">A</samp>&rsquo; specifier for hexadecimal output (see
below).
</p>
<p>The output &lsquo;<samp class="samp">conv</samp>&rsquo; specifiers allowed with <code class="code">mpfr_t</code> parameter are:
</p>
<blockquote class="quotation">
<table class="multitable">
<tbody><tr><td>&lsquo;<samp class="samp">a</samp>&rsquo; &lsquo;<samp class="samp">A</samp>&rsquo;</td><td>hex float, C99 style</td></tr>
<tr><td>&lsquo;<samp class="samp">b</samp>&rsquo;</td><td>binary output</td></tr>
<tr><td>&lsquo;<samp class="samp">e</samp>&rsquo; &lsquo;<samp class="samp">E</samp>&rsquo;</td><td>scientific-format float</td></tr>
<tr><td>&lsquo;<samp class="samp">f</samp>&rsquo; &lsquo;<samp class="samp">F</samp>&rsquo;</td><td>fixed-point float</td></tr>
<tr><td>&lsquo;<samp class="samp">g</samp>&rsquo; &lsquo;<samp class="samp">G</samp>&rsquo;</td><td>fixed-point or scientific float</td></tr>
</tbody>
</table>
</blockquote>
<p>The conversion specifier &lsquo;<samp class="samp">b</samp>&rsquo;, which displays the argument in binary, is
specific to <code class="code">mpfr_t</code> arguments and should not be used with other types.
Other conversion specifiers have the same meaning as for a <code class="code">double</code>
argument.
</p>
<p>In case of non-decimal output, only the significand is written in the
specified base, the exponent is always displayed in decimal.
Special values are always displayed as &lsquo;<samp class="samp">nan</samp>&rsquo;, &lsquo;<samp class="samp">-inf</samp>&rsquo;, and &lsquo;<samp class="samp">inf</samp>&rsquo;
for &lsquo;<samp class="samp">a</samp>&rsquo;, &lsquo;<samp class="samp">b</samp>&rsquo;, &lsquo;<samp class="samp">e</samp>&rsquo;, &lsquo;<samp class="samp">f</samp>&rsquo;, and &lsquo;<samp class="samp">g</samp>&rsquo; specifiers and
&lsquo;<samp class="samp">NAN</samp>&rsquo;, &lsquo;<samp class="samp">-INF</samp>&rsquo;, and &lsquo;<samp class="samp">INF</samp>&rsquo; for &lsquo;<samp class="samp">A</samp>&rsquo;, &lsquo;<samp class="samp">E</samp>&rsquo;, &lsquo;<samp class="samp">F</samp>&rsquo;, and
&lsquo;<samp class="samp">G</samp>&rsquo; specifiers.
</p>
<p>The <code class="code">mpfr_t</code> number is rounded to the given precision in the direction
specified by the rounding mode (see below if the precision is missing).
Similarly to the native C types, the precision is the number of digits output
after the decimal-point character, except for the &lsquo;<samp class="samp">g</samp>&rsquo; and &lsquo;<samp class="samp">G</samp>&rsquo;
conversion specifiers, where it is the number of significant digits
(but trailing zeros of the fractional part are not output by default),
or 1 if the precision is zero.
If the precision is zero with rounding to nearest mode and one of the
following conversion specifiers: &lsquo;<samp class="samp">a</samp>&rsquo;, &lsquo;<samp class="samp">A</samp>&rsquo;, &lsquo;<samp class="samp">b</samp>&rsquo;, &lsquo;<samp class="samp">e</samp>&rsquo;,
&lsquo;<samp class="samp">E</samp>&rsquo;, tie case is rounded to even when it lies between two consecutive
values at the
wanted precision which have the same exponent, otherwise, it is rounded away
from zero.
For instance, 85 is displayed as &lsquo;<samp class="samp">8e+1</samp>&rsquo; and 95 is displayed as
&lsquo;<samp class="samp">1e+2</samp>&rsquo; with the format specification <code class="code">&quot;%.0RNe&quot;</code>.
This also applies when the &lsquo;<samp class="samp">g</samp>&rsquo; (resp. &lsquo;<samp class="samp">G</samp>&rsquo;) conversion specifier
uses the &lsquo;<samp class="samp">e</samp>&rsquo; (resp. &lsquo;<samp class="samp">E</samp>&rsquo;) style.
If the precision is set to a value greater than the maximum value for an
<code class="code">int</code>, it will be silently reduced down to <code class="code">INT_MAX</code>.
</p>
<p>If the precision is missing, it is chosen as follows, depending on the
conversion specifier.
</p><ul class="itemize mark-bullet">
<li>With &lsquo;<samp class="samp">a</samp>&rsquo;, &lsquo;<samp class="samp">A</samp>&rsquo;, and &lsquo;<samp class="samp">b</samp>&rsquo;, it is chosen to have
an exact representation with no trailing zeros.
</li><li>With &lsquo;<samp class="samp">e</samp>&rsquo; and &lsquo;<samp class="samp">E</samp>&rsquo;, it is
ceil(p times
log(2)/log(10)),
where p<!-- /@w --> is the precision of the input variable, matching the choice
done for <code class="code">mpfr_get_str</code>; thus, if rounding to nearest is used,
outputting the value with a missing precision and reading it back will
yield the original value.
</li><li>With &lsquo;<samp class="samp">f</samp>&rsquo;, &lsquo;<samp class="samp">F</samp>&rsquo;, &lsquo;<samp class="samp">g</samp>&rsquo;, and &lsquo;<samp class="samp">G</samp>&rsquo;, it is 6.
</li></ul>
</div>
<div class="subsection-level-extent" id="Functions">
<h4 class="subsection">5.9.3 Functions</h4>
<p>For all the following functions, if the number of characters that ought to be
written exceeds the maximum limit <code class="code">INT_MAX</code> for an <code class="code">int</code>, nothing is
written in the stream (resp. to <code class="code">stdout</code>, to <var class="var">buf</var>, to <var class="var">str</var>),
the function returns &minus;1, sets the <em class="emph">erange</em> flag, and <code class="code">errno</code>
is set to <code class="code">EOVERFLOW</code> if the <code class="code">EOVERFLOW</code> macro is defined (such as
on POSIX systems). Note, however, that <code class="code">errno</code> might be changed to
another value by some internal library call if another error occurs there
(currently, this would come from the unallocation function).
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fprintf</strong> <code class="def-code-arguments">(FILE *<var class="var">stream</var>, const char *<var class="var">template</var>, &hellip;)</code><a class="copiable-link" href='#index-mpfr_005ffprintf'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fvfprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_vfprintf</strong> <code class="def-code-arguments">(FILE *<var class="var">stream</var>, const char *<var class="var">template</var>, va_list <var class="var">ap</var>)</code><a class="copiable-link" href='#index-mpfr_005fvfprintf'> &para;</a></span></dt>
<dd><p>Print to the stream <var class="var">stream</var> the optional arguments under the control of
the template string <var class="var">template</var>.
Return the number of characters written or a negative value if an error
occurred.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_printf</strong> <code class="def-code-arguments">(const char *<var class="var">template</var>, &hellip;)</code><a class="copiable-link" href='#index-mpfr_005fprintf'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fvprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_vprintf</strong> <code class="def-code-arguments">(const char *<var class="var">template</var>, va_list <var class="var">ap</var>)</code><a class="copiable-link" href='#index-mpfr_005fvprintf'> &para;</a></span></dt>
<dd><p>Print to <code class="code">stdout</code> the optional arguments under the control of the
template string <var class="var">template</var>.
Return the number of characters written or a negative value if an error
occurred.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sprintf</strong> <code class="def-code-arguments">(char *<var class="var">buf</var>, const char *<var class="var">template</var>, &hellip;)</code><a class="copiable-link" href='#index-mpfr_005fsprintf'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fvsprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_vsprintf</strong> <code class="def-code-arguments">(char *<var class="var">buf</var>, const char *<var class="var">template</var>, va_list <var class="var">ap</var>)</code><a class="copiable-link" href='#index-mpfr_005fvsprintf'> &para;</a></span></dt>
<dd><p>Form a null-terminated string corresponding to the optional arguments under
the control of the template string <var class="var">template</var>, and print it in
<var class="var">buf</var>. No overlap is permitted between
<var class="var">buf</var> and the other arguments.
Return the number of characters written in the array <var class="var">buf</var>
<em class="emph">not counting</em>
the terminating null character or a negative value if an error occurred.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsnprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_snprintf</strong> <code class="def-code-arguments">(char *<var class="var">buf</var>, size_t <var class="var">n</var>, const char *<var class="var">template</var>, &hellip;)</code><a class="copiable-link" href='#index-mpfr_005fsnprintf'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fvsnprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_vsnprintf</strong> <code class="def-code-arguments">(char *<var class="var">buf</var>, size_t <var class="var">n</var>, const char *<var class="var">template</var>, va_list <var class="var">ap</var>)</code><a class="copiable-link" href='#index-mpfr_005fvsnprintf'> &para;</a></span></dt>
<dd><p>Form a null-terminated string corresponding to the optional arguments under
the control of the template string <var class="var">template</var>, and print it in
<var class="var">buf</var>. If <var class="var">n</var> is zero, nothing is
written and <var class="var">buf</var> may be a null pointer, otherwise, the first
<var class="var">n</var>&nbsp;&minus;&nbsp;1<!-- /@w --> characters are written in <var class="var">buf</var> and the
<var class="var">n</var>-th one is a null character.
Return the number of characters that would have been written had <var class="var">n</var> been
sufficiently large, <em class="emph">not counting</em>
the terminating null character, or a negative value if an error occurred.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fasprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_asprintf</strong> <code class="def-code-arguments">(char **<var class="var">str</var>, const char *<var class="var">template</var>, &hellip;)</code><a class="copiable-link" href='#index-mpfr_005fasprintf'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fvasprintf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_vasprintf</strong> <code class="def-code-arguments">(char **<var class="var">str</var>, const char *<var class="var">template</var>, va_list <var class="var">ap</var>)</code><a class="copiable-link" href='#index-mpfr_005fvasprintf'> &para;</a></span></dt>
<dd><p>Write their output as a null terminated string in a block of memory allocated
using the allocation function (see <a class="pxref" href="constant.MPFR_Basics.html#Memory-Handling">Memory Handling</a>). A pointer to the
block is stored in
<var class="var">str</var>. The block of memory must be freed using <code class="code">mpfr_free_str</code>.
The return value is the number of characters written in the string, excluding
the null-terminator, or a negative value if an error occurred, in which case
the contents of <var class="var">str</var> are undefined.
</p></dd></dl>
<hr>
</div>
</div>
<div class="section-level-extent" id="Integer-and-Remainder-Related-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Rounding_002dRelated-Functions" accesskey="n" rel="next">Rounding-Related Functions</a>, Previous: <a href="#Formatted-Output-Functions" accesskey="p" rel="prev">Formatted Output Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Integer-related-functions"></a>
<a class="index-entry-id" id="index-Remainder-related-functions"></a>
<h3 class="section" id="Integer-and-Remainder-Related-Functions-1">5.10 Integer and Remainder Related Functions</h3>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005frint"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rint</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frint'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fceil"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_ceil</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fceil'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffloor"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_floor</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005ffloor'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fround"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_round</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fround'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005froundeven"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_roundeven</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005froundeven'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ftrunc"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_trunc</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005ftrunc'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op</var> rounded to an integer.
<code class="code">mpfr_rint</code> rounds to the nearest representable integer in the
given direction <var class="var">rnd</var>, and the other five functions behave in a
similar way with some fixed rounding mode:
</p><ul class="itemize mark-bullet">
<li><code class="code">mpfr_ceil</code>: to the next higher or equal representable integer
      (like <code class="code">mpfr_rint</code> with <code class="code">MPFR_RNDU</code>);
</li><li><code class="code">mpfr_floor</code> to the next lower or equal representable integer
      (like <code class="code">mpfr_rint</code> with <code class="code">MPFR_RNDD</code>);
</li><li><code class="code">mpfr_round</code> to the nearest representable integer,
      rounding halfway cases away from zero
      (as in the roundTiesToAway mode of IEEE&nbsp;754);
</li><li><code class="code">mpfr_roundeven</code> to the nearest representable integer,
      rounding halfway cases with the even-rounding rule
      (like <code class="code">mpfr_rint</code> with <code class="code">MPFR_RNDN</code>);
</li><li><code class="code">mpfr_trunc</code> to the next representable integer toward zero
      (like <code class="code">mpfr_rint</code> with <code class="code">MPFR_RNDZ</code>).
</li></ul>
<p>When <var class="var">op</var> is a zero or an infinity, set <var class="var">rop</var> to the same value
(with the same sign).
</p>
<p>The return value is zero when the result is exact, positive when it is
greater than the original value of <var class="var">op</var>, and negative when it is smaller.
More precisely, the return value is 0 when <var class="var">op</var> is an integer
representable in <var class="var">rop</var>, 1 or &minus;1 when <var class="var">op</var> is an integer
that is not representable in <var class="var">rop</var>, 2 or &minus;2 when <var class="var">op</var> is
not an integer.
</p>
<p>When <var class="var">op</var> is NaN, the NaN flag is set as usual. In the other cases,
the inexact flag is set when <var class="var">rop</var> differs from <var class="var">op</var>, following
the ISO C99 rule for the <code class="code">rint</code> function. If you want the behavior to
be more like IEEE&nbsp;754 / ISO TS&nbsp;18661-1, i.e., the usual behavior
where the round-to-integer function is regarded as any other mathematical
function, you should use one of the <code class="code">mpfr_rint_*</code> functions instead.
</p>
<p>Note that no double rounding is performed; for instance, 10.5 (1010.1 in
binary) is rounded by <code class="code">mpfr_rint</code> with rounding to nearest to 12 (1100
in binary) in 2-bit precision, because the two enclosing numbers representable
on two bits are 8 and 12, and the closest is 12.
(If one first rounded to an integer, one would round 10.5 to 10 with
even rounding, and then 10 would be rounded to 8 again with even rounding.)
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005frint_005fceil"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rint_ceil</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frint_005fceil'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005frint_005ffloor"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rint_floor</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frint_005ffloor'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005frint_005fround"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rint_round</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frint_005fround'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005frint_005froundeven"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rint_roundeven</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frint_005froundeven'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005frint_005ftrunc"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rint_trunc</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frint_005ftrunc'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op</var> rounded to an integer:
</p><ul class="itemize mark-bullet">
<li><code class="code">mpfr_rint_ceil</code>: to the next higher or equal integer;
</li><li><code class="code">mpfr_rint_floor</code>: to the next lower or equal integer;
</li><li><code class="code">mpfr_rint_round</code>: to the nearest integer,
      rounding halfway cases away from zero;
</li><li><code class="code">mpfr_rint_roundeven</code>: to the nearest integer,
      rounding halfway cases to the nearest even integer;
</li><li><code class="code">mpfr_rint_trunc</code> to the next integer toward zero.
</li></ul>
<p>If the result is not representable, it is rounded in the direction <var class="var">rnd</var>.
When <var class="var">op</var> is a zero or an infinity, set <var class="var">rop</var> to the same value
(with the same sign).
The return value is the ternary value associated with the considered
round-to-integer function (regarded in the same way as any other
mathematical function).
</p>
<p>Contrary to <code class="code">mpfr_rint</code>, those functions do perform a double rounding:
first <var class="var">op</var> is rounded to the nearest integer in the direction given by
the function name, then this nearest integer (if not representable) is
rounded in the given direction <var class="var">rnd</var>.  Thus these round-to-integer
functions behave more like the other mathematical functions, i.e., the
returned result is the correct rounding of the exact result of the function
in the real numbers.
</p>
<p>For example, <code class="code">mpfr_rint_round</code> with rounding to nearest and a precision
of two bits rounds 6.5 to 7 (halfway cases away from zero), then 7 is
rounded to 8 by the round-even rule, despite the fact that 6 is also
representable on two bits, and is closer to 6.5 than 8.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffrac"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_frac</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffrac'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the fractional part of <var class="var">op</var>, having the same sign as
<var class="var">op</var>, rounded in the direction <var class="var">rnd</var> (unlike in <code class="code">mpfr_rint</code>,
<var class="var">rnd</var> affects only how the exact fractional part is rounded, not how
the fractional part is generated).
When <var class="var">op</var> is an integer or an infinity, set <var class="var">rop</var> to zero with
the same sign as <var class="var">op</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmodf"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_modf</strong> <code class="def-code-arguments">(mpfr_t <var class="var">iop</var>, mpfr_t <var class="var">fop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmodf'> &para;</a></span></dt>
<dd><p>Set simultaneously <var class="var">iop</var> to the integral part of <var class="var">op</var> and <var class="var">fop</var> to
the fractional part of <var class="var">op</var>, rounded in the direction <var class="var">rnd</var> with the
corresponding precision of <var class="var">iop</var> and <var class="var">fop</var> (equivalent to
<code class="code">mpfr_trunc(<var class="var">iop</var>, <var class="var">op</var>, <var class="var">rnd</var>)</code> and
<code class="code">mpfr_frac(<var class="var">fop</var>, <var class="var">op</var>, <var class="var">rnd</var>)</code>). The variables <var class="var">iop</var> and
<var class="var">fop</var> must be different. Return 0 iff both results are exact (see
<code class="code">mpfr_sin_cos</code> for a more detailed description of the return value).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffmod"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fmod</strong> <code class="def-code-arguments">(mpfr_t <var class="var">r</var>, mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffmod'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffmod_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fmod_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">r</var>, mpfr_t <var class="var">x</var>, unsigned long int <var class="var">y</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffmod_005fui'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffmodquo"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fmodquo</strong> <code class="def-code-arguments">(mpfr_t <var class="var">r</var>, long int* <var class="var">q</var>, mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffmodquo'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fremainder"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_remainder</strong> <code class="def-code-arguments">(mpfr_t <var class="var">r</var>, mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fremainder'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fremquo"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_remquo</strong> <code class="def-code-arguments">(mpfr_t <var class="var">r</var>, long int* <var class="var">q</var>, mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fremquo'> &para;</a></span></dt>
<dd><p>Set <var class="var">r</var> to the value of <var class="var">x</var>&nbsp;&minus;&nbsp;<var class="var">n</var><var class="var">y</var><!-- /@w -->, rounded
according to the direction <var class="var">rnd</var>, where <var class="var">n</var> is the integer quotient
of <var class="var">x</var> divided by <var class="var">y</var>, defined as follows: <var class="var">n</var> is rounded
toward zero for <code class="code">mpfr_fmod</code>, <code class="code">mpfr_fmod_ui</code> and <code class="code">mpfr_fmodquo</code>,
and to the nearest integer (ties rounded to even) for <code class="code">mpfr_remainder</code>
and <code class="code">mpfr_remquo</code>.
</p>
<p>Special values are handled as described in Section&nbsp;F.9.7.1 of
the ISO C99 standard:
If <var class="var">x</var> is infinite or <var class="var">y</var> is zero, <var class="var">r</var> is NaN.
If <var class="var">y</var> is infinite and <var class="var">x</var> is finite, <var class="var">r</var> is <var class="var">x</var> rounded
to the precision of <var class="var">r</var>.
If <var class="var">r</var> is zero, it has the sign of <var class="var">x</var>.
The return value is the ternary value corresponding to <var class="var">r</var>.
</p>
<p>Additionally, <code class="code">mpfr_fmodquo</code> and <code class="code">mpfr_remquo</code> store
the low significant bits from the quotient <var class="var">n</var> in <var class="var">*q</var>
(more precisely the number of bits in a <code class="code">long int</code> minus one),
with the sign of <var class="var">x</var> divided by <var class="var">y</var>
(except if those low bits are all zero, in which case zero is returned).
If the result is NaN, the value of <var class="var">*q</var> is unspecified.
Note that <var class="var">x</var> may be so large in magnitude relative to <var class="var">y</var> that an
exact representation of the quotient is not practical.
The <code class="code">mpfr_remainder</code> and <code class="code">mpfr_remquo</code> functions are useful for
additive argument reduction.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005finteger_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_integer_p</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005finteger_005fp'> &para;</a></span></dt>
<dd><p>Return non-zero iff <var class="var">op</var> is an integer.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Rounding_002dRelated-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Miscellaneous-Functions" accesskey="n" rel="next">Miscellaneous Functions</a>, Previous: <a href="#Integer-and-Remainder-Related-Functions" accesskey="p" rel="prev">Integer and Remainder Related Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Rounding-mode-related-functions"></a>
<h3 class="section" id="Rounding_002dRelated-Functions-1">5.11 Rounding-Related Functions</h3>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fdefault_005frounding_005fmode"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_default_rounding_mode</strong> <code class="def-code-arguments">(mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fdefault_005frounding_005fmode'> &para;</a></span></dt>
<dd><p>Set the default rounding mode to <var class="var">rnd</var>.
The default rounding mode is to nearest initially.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fdefault_005frounding_005fmode"><span class="category-def">Function: </span><span><code class="def-type">mpfr_rnd_t</code> <strong class="def-name">mpfr_get_default_rounding_mode</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005fdefault_005frounding_005fmode'> &para;</a></span></dt>
<dd><p>Get the default rounding mode.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fprec_005fround"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_prec_round</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_prec_t <var class="var">prec</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fprec_005fround'> &para;</a></span></dt>
<dd><p>Round <var class="var">x</var> according to <var class="var">rnd</var> with precision <var class="var">prec</var>, which
must be an integer between <code class="code">MPFR_PREC_MIN</code> and <code class="code">MPFR_PREC_MAX</code>
(otherwise the behavior is undefined).
If <var class="var">prec</var> is greater than or equal to the precision of <var class="var">x</var>, then
new space is allocated for the significand, and it is filled with zeros.
Otherwise, the significand is rounded to precision <var class="var">prec</var> with the given
direction; no memory reallocation to free the unused limbs is done.
In both cases, the precision of <var class="var">x</var> is changed to <var class="var">prec</var>.
</p>
<p>Here is an example of how to use <code class="code">mpfr_prec_round</code> to implement
Newton&rsquo;s algorithm to compute the inverse of <var class="var">a</var>, assuming <var class="var">x</var> is
already an approximation to <var class="var">n</var> bits:
</p><div class="example">
<pre class="example-preformatted">mpfr_set_prec (t, 2 * n);
mpfr_set (t, a, MPFR_RNDN);         /* round a to 2n bits */
mpfr_mul (t, t, x, MPFR_RNDN);      /* t is correct to 2n bits */
mpfr_ui_sub (t, 1, t, MPFR_RNDN);   /* high n bits cancel with 1 */
mpfr_prec_round (t, n, MPFR_RNDN);  /* t is correct to n bits */
mpfr_mul (t, t, x, MPFR_RNDN);      /* t is correct to n bits */
mpfr_prec_round (x, 2 * n, MPFR_RNDN); /* exact */
mpfr_add (x, x, t, MPFR_RNDN);      /* x is correct to 2n bits */
</pre></div>
<p>Warning! You must not use this function if <var class="var">x</var> was initialized
with <code class="code">MPFR_DECL_INIT</code> or with <code class="code">mpfr_custom_init_set</code>
(see <a class="pxref" href="#Custom-Interface">Custom Interface</a>).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcan_005fround"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_can_round</strong> <code class="def-code-arguments">(mpfr_t <var class="var">b</var>, mpfr_exp_t <var class="var">err</var>, mpfr_rnd_t <var class="var">rnd1</var>, mpfr_rnd_t <var class="var">rnd2</var>, mpfr_prec_t <var class="var">prec</var>)</code><a class="copiable-link" href='#index-mpfr_005fcan_005fround'> &para;</a></span></dt>
<dd><p>Assuming <var class="var">b</var> is an approximation of an unknown number
<var class="var">x</var> in the direction <var class="var">rnd1</var> with error at most two to the power
EXP(<var class="var">b</var>)&nbsp;&minus;&nbsp;<var class="var">err</var><!-- /@w --> where EXP(<var class="var">b</var>)<!-- /@w -->
is the exponent of <var class="var">b</var>,
return a non-zero value if one is able to round correctly <var class="var">x</var> to
precision <var class="var">prec</var> with the direction <var class="var">rnd2</var> assuming an unbounded
exponent range, and 0 otherwise (including for NaN and Inf).
In other words, if the error on <var class="var">b</var> is bounded by two to the power
<var class="var">k</var>&nbsp;ulps, and <var class="var">b</var> has precision <var class="var">prec</var>,
you should give <var class="var">err</var>&nbsp;=&nbsp;<var class="var">prec</var>&nbsp;&minus;&nbsp;<var class="var">k</var><!-- /@w -->.
This function <strong class="strong">does not modify</strong> its arguments.
</p>
<p>If <var class="var">rnd1</var> is <code class="code">MPFR_RNDN</code> or <code class="code">MPFR_RNDF</code>,
the error is considered to be either
positive or negative, thus the possible range
is twice as large as with a directed rounding for <var class="var">rnd1</var> (with the
same value of <var class="var">err</var>).
</p>
<p>When <var class="var">rnd2</var> is <code class="code">MPFR_RNDF</code>, let <var class="var">rnd3</var> be the opposite direction
if <var class="var">rnd1</var> is a directed rounding, and <code class="code">MPFR_RNDN</code>
if <var class="var">rnd1</var> is <code class="code">MPFR_RNDN</code> or <code class="code">MPFR_RNDF</code>.
The returned value of <code class="code">mpfr_can_round (b, err, rnd1, MPFR_RNDF, prec)</code>
is non-zero iff after
the call <code class="code">mpfr_set (y, b, rnd3)</code> with <var class="var">y</var> of precision <var class="var">prec</var>,
<var class="var">y</var> is guaranteed to be a faithful rounding of <var class="var">x</var>.
</p>
<p>Note: The <a class="ref" href="constant.MPFR_Basics.html#ternary-value">ternary value</a> cannot be determined in general with this
function. However, if it is known that the exact value is not exactly
representable in precision <var class="var">prec</var>, then one can use the following
trick to determine the (non-zero) ternary value in any rounding mode
<var class="var">rnd2</var> (note that <code class="code">MPFR_RNDZ</code> below can be replaced by any
directed rounding mode):
</p><div class="example">
<pre class="example-preformatted">if (mpfr_can_round (b, err, MPFR_RNDN, MPFR_RNDZ,
                    prec + (rnd2 == MPFR_RNDN)))
  {
    /* round the approximation b to the result r of prec bits
       with rounding mode rnd2 and get the ternary value inex */
    inex = mpfr_set (r, b, rnd2);
  }
</pre></div>
<p>Indeed, if <var class="var">rnd2</var> is <code class="code">MPFR_RNDN</code>, this will check if one can
round to <var class="var">prec</var>&nbsp;+&nbsp;1<!-- /@w --> bits with a directed rounding:
if so, one can surely round to nearest to <var class="var">prec</var> bits,
and in addition one can determine the correct ternary value, which would not
be the case when <var class="var">b</var> is near from a value exactly representable on
<var class="var">prec</var> bits.
</p>
<p>A detailed example is available in the <samp class="file">examples</samp> subdirectory,
file <samp class="file">can_round.c</samp>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmin_005fprec"><span class="category-def">Function: </span><span><code class="def-type">mpfr_prec_t</code> <strong class="def-name">mpfr_min_prec</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fmin_005fprec'> &para;</a></span></dt>
<dd><p>Return the minimal number of bits required to store the significand of
<var class="var">x</var>, and 0 for special values, including 0.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fprint_005frnd_005fmode"><span class="category-def">Function: </span><span><code class="def-type">const char *</code> <strong class="def-name">mpfr_print_rnd_mode</strong> <code class="def-code-arguments">(mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fprint_005frnd_005fmode'> &para;</a></span></dt>
<dd><p>Return a string (<code class="code">&quot;MPFR_RNDN&quot;</code>, <code class="code">&quot;MPFR_RNDZ&quot;</code>, <code class="code">&quot;MPFR_RNDU&quot;</code>,
<code class="code">&quot;MPFR_RNDD&quot;</code>, <code class="code">&quot;MPFR_RNDA&quot;</code>, <code class="code">&quot;MPFR_RNDF&quot;</code>) corresponding to
the rounding mode <var class="var">rnd</var>, or a null pointer if <var class="var">rnd</var> is an invalid
rounding mode.
</p></dd></dl>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-mpfr_005fround_005fnearest_005faway"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_round_nearest_away</strong> <code class="def-code-arguments">(int (<var class="var">foo</var>)(mpfr_t, type1_t, ..., mpfr_rnd_t), mpfr_t <var class="var">rop</var>, type1_t <var class="var">op</var>, ...)</code><a class="copiable-link" href='#index-mpfr_005fround_005fnearest_005faway'> &para;</a></span></dt>
<dd><p>Given a function <var class="var">foo</var> and one or more values <var class="var">op</var> (which may be
a <code class="code">mpfr_t</code>, a <code class="code">long int</code>, a <code class="code">double</code>, etc.), put in <var class="var">rop</var>
the round-to-nearest-away rounding of <code class="code"><var class="var">foo</var>(<var class="var">op</var>,...)</code>.
This rounding is defined in the same way as round-to-nearest-even,
except in case of tie, where the value away from zero is returned.
The function <var class="var">foo</var> takes as input, from second to
penultimate argument(s), the argument list given after <var class="var">rop</var>,
a rounding mode as final argument,
puts in its first argument the value <code class="code"><var class="var">foo</var>(<var class="var">op</var>,...)</code> rounded
according to this rounding mode, and returns the corresponding ternary value
(which is expected to be correct, otherwise <code class="code">mpfr_round_nearest_away</code>
will not work as desired).
Due to implementation constraints, this function must not be called when
the minimal exponent <var class="var">emin</var> is the smallest possible one.
This macro has been made such that the compiler is able to detect
mismatch between the argument list <var class="var">op</var>
and the function prototype of <var class="var">foo</var>.
Multiple input arguments <var class="var">op</var> are supported only with C99 compilers.
Otherwise, for C90 compilers, only one such argument is supported.
</p>
<p>Note: this macro is experimental and its interface might change in future
versions.
</p><div class="example">
<pre class="example-preformatted">unsigned long ul;
mpfr_t f, r;
/* Code that inits and sets r, f, and ul, and if needed sets emin */
int i = mpfr_round_nearest_away (mpfr_add_ui, r, f, ul);
</pre></div>
</dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Miscellaneous-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Exception-Related-Functions" accesskey="n" rel="next">Exception Related Functions</a>, Previous: <a href="#Rounding_002dRelated-Functions" accesskey="p" rel="prev">Rounding-Related Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Miscellaneous-float-functions"></a>
<h3 class="section" id="Miscellaneous-Functions-1">5.12 Miscellaneous Functions</h3>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fnexttoward"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_nexttoward</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>)</code><a class="copiable-link" href='#index-mpfr_005fnexttoward'> &para;</a></span></dt>
<dd><p>If <var class="var">x</var> or <var class="var">y</var> is NaN, set <var class="var">x</var> to NaN; note that the NaN flag
is set as usual.
If <var class="var">x</var> and <var class="var">y</var> are equal, <var class="var">x</var> is unchanged.
Otherwise, if <var class="var">x</var> is different from <var class="var">y</var>, replace <var class="var">x</var> by the
next floating-point number (with the precision of <var class="var">x</var> and the current
exponent range) in the direction of <var class="var">y</var>
(the infinite values are seen as the smallest and largest floating-point
numbers). If the result is zero, it keeps the same sign. No underflow,
overflow, or inexact exception is raised.
</p>
<p>Note: Concerning the exceptions and the sign of 0, the behavior differs
from the ISO C <code class="code">nextafter</code> and <code class="code">nexttoward</code> functions. It is
similar to the nextUp and nextDown operations from IEEE 754 (introduced
in its 2008 revision).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fnextabove"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_nextabove</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fnextabove'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fnextbelow"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_nextbelow</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fnextbelow'> &para;</a></span></dt>
<dd><p>Equivalent to <code class="code">mpfr_nexttoward</code> where <var class="var">y</var> is +Inf
(resp. &minus;Inf).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmin"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_min</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmin'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmax"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_max</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmax'> &para;</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the minimum (resp. maximum)
of <var class="var">op1</var> and <var class="var">op2</var>. If <var class="var">op1</var>
and <var class="var">op2</var> are both NaN, then <var class="var">rop</var> is set to NaN. If <var class="var">op1</var>
or <var class="var">op2</var> is NaN, then <var class="var">rop</var> is set to the numeric value. If
<var class="var">op1</var> and <var class="var">op2</var> are zeros of different signs, then <var class="var">rop</var>
is set to &minus;0 (resp. +0).
As usual, the NaN flag is set only when the result is NaN, i.e.,
when both <var class="var">op1</var> and <var class="var">op2</var> are NaN.
</p>
<p>Note: These functions correspond to the minimumNumber and maximumNumber
operations of IEEE&nbsp;754-2019 for the result. But in MPFR, the NaN flag
is set only when <em class="emph">both</em> operands are NaN.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005furandomb"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_urandomb</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, gmp_randstate_t <var class="var">state</var>)</code><a class="copiable-link" href='#index-mpfr_005furandomb'> &para;</a></span></dt>
<dd><p>Generate a uniformly distributed random float in the interval
0&nbsp;&lt;=&nbsp;<var class="var">rop</var>&nbsp;&lt;&nbsp;1<!-- /@w -->. More precisely, the number can be seen as a
float with a random non-normalized significand and exponent 0, which is then
normalized (thus if <var class="var">e</var> denotes the exponent after normalization, then
the least &minus;<var class="var">e</var><!-- /@w --> significant bits of the significand are always
0).
</p>
<p>Return 0, unless the exponent is not in the current exponent range, in
which case <var class="var">rop</var> is set to NaN and a non-zero value is returned (this
should never happen in practice, except in very specific cases). The
second argument is a <code class="code">gmp_randstate_t</code> structure, which should be
created using the GMP <code class="code">gmp_randinit</code> function (see the GMP manual).
</p>
<p>Note: for a given version of MPFR, the returned value of <var class="var">rop</var> and the
new value of <var class="var">state</var> (which controls further random values) do not depend
on the machine word size.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005furandom"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_urandom</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, gmp_randstate_t <var class="var">state</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005furandom'> &para;</a></span></dt>
<dd><p>Generate a uniformly distributed random float.
The floating-point number <var class="var">rop</var> can be seen as if a random real number is
generated according to the continuous uniform distribution on the interval
[0, 1] and then rounded in the direction <var class="var">rnd</var>.
</p>
<p>The second argument is a <code class="code">gmp_randstate_t</code> structure, which should be
created using the GMP <code class="code">gmp_randinit</code> function (see the GMP manual).
</p>
<p>Note: the note for <code class="code">mpfr_urandomb</code> holds too. Moreover, the exact number
(the random value to be rounded) and the next random state do not depend on
the current exponent range and the rounding mode. However, they depend on
the target precision: from the same state of the random generator, if the
precision of the destination is changed, then the value may be completely
different (and the state of the random generator is different too).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fnrandom"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_nrandom</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop1</var>, gmp_randstate_t <var class="var">state</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fnrandom'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fgrandom"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_grandom</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop1</var>, mpfr_t <var class="var">rop2</var>, gmp_randstate_t <var class="var">state</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fgrandom'> &para;</a></span></dt>
<dd><p>Generate one (possibly two for <code class="code">mpfr_grandom</code>) random floating-point
number according to a standard normal Gaussian distribution (with mean zero
and variance one). For <code class="code">mpfr_grandom</code>, if <var class="var">rop2</var> is a null pointer,
then only one value is generated and stored in <var class="var">rop1</var>.
</p>
<p>The floating-point number <var class="var">rop1</var> (and <var class="var">rop2</var>) can be seen as if a
random real number were generated according to the standard normal Gaussian
distribution and then rounded in the direction <var class="var">rnd</var>.
</p>
<p>The <code class="code">gmp_randstate_t</code> argument should be
created using the GMP <code class="code">gmp_randinit</code> function (see the GMP manual).
</p>
<p>For <code class="code">mpfr_grandom</code>,
the combination of the ternary values is returned like with
<code class="code">mpfr_sin_cos</code>. If <var class="var">rop2</var> is a null pointer, the second ternary
value is assumed to be 0 (note that the encoding of the only ternary value
is not the same as the usual encoding for functions that return only one
result). Otherwise the ternary value of a random number is always non-zero.
</p>
<p>Note: the note for <code class="code">mpfr_urandomb</code> holds too. In addition, the exponent
range and the rounding mode might have a side effect on the next random state.
</p>
<p>Note: <code class="code">mpfr_nrandom</code> is much more efficient than <code class="code">mpfr_grandom</code>,
especially for large precision. Thus <code class="code">mpfr_grandom</code> is marked as
deprecated and will be removed in a future release.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ferandom"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_erandom</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop1</var>, gmp_randstate_t <var class="var">state</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ferandom'> &para;</a></span></dt>
<dd><p>Generate one random floating-point number according to an exponential
distribution, with mean one.
Other characteristics are identical to <code class="code">mpfr_nrandom</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fexp"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_get_exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fget_005fexp'> &para;</a></span></dt>
<dd><p>Return the exponent of <var class="var">x</var>, assuming that <var class="var">x</var> is a non-zero ordinary
number and the significand is considered in [1/2,1). For this function,
<var class="var">x</var> is allowed to be outside of the current range of acceptable values.
The behavior for NaN, infinity or zero is undefined.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fexp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_exp_t <var class="var">e</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fexp'> &para;</a></span></dt>
<dd><p>Set the exponent of <var class="var">x</var> to <var class="var">e</var> if <var class="var">x</var> is a non-zero ordinary
number and <var class="var">e</var> is in the current exponent range, and return 0;
otherwise, return a non-zero value (<var class="var">x</var> is not changed).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsignbit"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_signbit</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op</var>)</code><a class="copiable-link" href='#index-mpfr_005fsignbit'> &para;</a></span></dt>
<dd><p>Return a non-zero value iff <var class="var">op</var> has its sign bit set (i.e., if it is
negative, &minus;0, or a NaN whose representation has its sign bit set).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsetsign"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_setsign</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, int <var class="var">s</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsetsign'> &para;</a></span></dt>
<dd><p>Set the value of <var class="var">rop</var> from <var class="var">op</var>, rounded toward the given
direction <var class="var">rnd</var>, then set (resp. clear) its sign bit if <var class="var">s</var>
is non-zero (resp. zero), even when <var class="var">op</var> is a NaN.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcopysign"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_copysign</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcopysign'> &para;</a></span></dt>
<dd><p>Set the value of <var class="var">rop</var> from <var class="var">op1</var>, rounded toward the given
direction <var class="var">rnd</var>, then set its sign bit to that of <var class="var">op2</var> (even
when <var class="var">op1</var> or <var class="var">op2</var> is a NaN). This function is equivalent to
<code class="code">mpfr_setsign (<var class="var">rop</var>, <var class="var">op1</var>, mpfr_signbit (<var class="var">op2</var>), <var class="var">rnd</var>)</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fversion"><span class="category-def">Function: </span><span><code class="def-type">const char *</code> <strong class="def-name">mpfr_get_version</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005fversion'> &para;</a></span></dt>
<dd><p>Return the MPFR version, as a null-terminated string.
</p></dd></dl>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MPFR_005fVERSION"><span class="category-def">Macro: </span><span><strong class="def-name">MPFR_VERSION</strong><a class="copiable-link" href='#index-MPFR_005fVERSION'> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-MPFR_005fVERSION_005fMAJOR"><span class="category-def">Macro: </span><span><strong class="def-name">MPFR_VERSION_MAJOR</strong><a class="copiable-link" href='#index-MPFR_005fVERSION_005fMAJOR'> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-MPFR_005fVERSION_005fMINOR"><span class="category-def">Macro: </span><span><strong class="def-name">MPFR_VERSION_MINOR</strong><a class="copiable-link" href='#index-MPFR_005fVERSION_005fMINOR'> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-MPFR_005fVERSION_005fPATCHLEVEL"><span class="category-def">Macro: </span><span><strong class="def-name">MPFR_VERSION_PATCHLEVEL</strong><a class="copiable-link" href='#index-MPFR_005fVERSION_005fPATCHLEVEL'> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-MPFR_005fVERSION_005fSTRING"><span class="category-def">Macro: </span><span><strong class="def-name">MPFR_VERSION_STRING</strong><a class="copiable-link" href='#index-MPFR_005fVERSION_005fSTRING'> &para;</a></span></dt>
<dd><p><code class="code">MPFR_VERSION</code> is the version of MPFR as a preprocessing constant.
<code class="code">MPFR_VERSION_MAJOR</code>, <code class="code">MPFR_VERSION_MINOR</code> and
<code class="code">MPFR_VERSION_PATCHLEVEL</code> are respectively the major, minor and patch
level of MPFR version, as preprocessing constants.
<code class="code">MPFR_VERSION_STRING</code> is the version (with an optional suffix, used
in development and pre-release versions) as a string constant, which can
be compared to the result of <code class="code">mpfr_get_version</code> to check at run time
the header file and library used match:
</p><div class="example">
<pre class="example-preformatted">if (strcmp (mpfr_get_version (), MPFR_VERSION_STRING))
  fprintf (stderr, &quot;Warning: header and library do not match\n&quot;);
</pre></div>
<p>Note: Obtaining different strings is not necessarily an error, as
in general, a program compiled with some old MPFR version can be
dynamically linked with a newer MPFR library version (if allowed
by the library versioning system).
</p></dd></dl>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-MPFR_005fVERSION_005fNUM"><span class="category-def">Macro: </span><span><code class="def-type">long</code> <strong class="def-name">MPFR_VERSION_NUM</strong> <code class="def-code-arguments">(<var class="var">major</var>, <var class="var">minor</var>, <var class="var">patchlevel</var>)</code><a class="copiable-link" href='#index-MPFR_005fVERSION_005fNUM'> &para;</a></span></dt>
<dd><p>Create an integer in the same format as used by <code class="code">MPFR_VERSION</code> from the
given <var class="var">major</var>, <var class="var">minor</var> and <var class="var">patchlevel</var>.
Here is an example of how to check the MPFR version at compile time:
</p><div class="example">
<pre class="example-preformatted">#if (!defined(MPFR_VERSION) || (MPFR_VERSION &lt; MPFR_VERSION_NUM(3,0,0)))
# error &quot;Wrong MPFR version.&quot;
#endif
</pre></div>
</dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005fpatches"><span class="category-def">Function: </span><span><code class="def-type">const char *</code> <strong class="def-name">mpfr_get_patches</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005fpatches'> &para;</a></span></dt>
<dd><p>Return a null-terminated string containing the ids of the patches applied to
the MPFR library (contents of the <samp class="file">PATCHES</samp> file), separated by spaces.
Note: If the program has been compiled with an older MPFR version and is
dynamically linked with a new MPFR library version, the identifiers of the
patches applied to the old (compile-time) MPFR version are not available
(however, this information should not have much interest in general).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fbuildopt_005ftls_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_buildopt_tls_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fbuildopt_005ftls_005fp'> &para;</a></span></dt>
<dd><p>Return a non-zero value if MPFR was compiled as thread safe using
compiler-level Thread-Local Storage (that is, MPFR was built with the
&lsquo;<samp class="samp">--enable-thread-safe</samp>&rsquo; configure option, see <code class="code">INSTALL</code> file),
return zero otherwise.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fbuildopt_005ffloat128_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_buildopt_float128_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fbuildopt_005ffloat128_005fp'> &para;</a></span></dt>
<dd><p>Return a non-zero value if MPFR was compiled with &lsquo;<samp class="samp">_Float128</samp>&rsquo; support
(that is, MPFR was built with the &lsquo;<samp class="samp">--enable-float128</samp>&rsquo; configure option),
return zero otherwise.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fbuildopt_005fdecimal_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_buildopt_decimal_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fbuildopt_005fdecimal_005fp'> &para;</a></span></dt>
<dd><p>Return a non-zero value if MPFR was compiled with decimal float support (that
is, MPFR was built with the &lsquo;<samp class="samp">--enable-decimal-float</samp>&rsquo; configure option),
return zero otherwise.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fbuildopt_005fgmpinternals_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_buildopt_gmpinternals_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fbuildopt_005fgmpinternals_005fp'> &para;</a></span></dt>
<dd><p>Return a non-zero value if MPFR was compiled with GMP internals
(that is, MPFR was built with either &lsquo;<samp class="samp">--with-gmp-build</samp>&rsquo; or
&lsquo;<samp class="samp">--enable-gmp-internals</samp>&rsquo; configure option), return zero otherwise.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fbuildopt_005fsharedcache_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_buildopt_sharedcache_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fbuildopt_005fsharedcache_005fp'> &para;</a></span></dt>
<dd><p>Return a non-zero value if MPFR was compiled so that all threads share
the same cache for one MPFR constant, like <code class="code">mpfr_const_pi</code> or
<code class="code">mpfr_const_log2</code> (that is, MPFR was built with the
&lsquo;<samp class="samp">--enable-shared-cache</samp>&rsquo; configure option), return zero otherwise.
If the return value is non-zero, MPFR applications may need to be compiled
with the &lsquo;<samp class="samp">-pthread</samp>&rsquo; option.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fbuildopt_005ftune_005fcase"><span class="category-def">Function: </span><span><code class="def-type">const char *</code> <strong class="def-name">mpfr_buildopt_tune_case</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fbuildopt_005ftune_005fcase'> &para;</a></span></dt>
<dd><p>Return a string saying which thresholds file has been used at compile time.
This file is normally selected from the processor type.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Exception-Related-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Memory-Handling-Functions" accesskey="n" rel="next">Memory Handling Functions</a>, Previous: <a href="#Miscellaneous-Functions" accesskey="p" rel="prev">Miscellaneous Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Exception-related-functions"></a>
<h3 class="section" id="Exception-Related-Functions-1">5.13 Exception Related Functions</h3>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005femin"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_get_emin</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005femin'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005femax"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_get_emax</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005femax'> &para;</a></span></dt>
<dd><p>Return the (current) smallest and largest exponents allowed for a
floating-point variable. The smallest positive value of a floating-point
variable is one half times 2 raised to the
smallest exponent and the largest value has the form (1 &minus; epsilon) times 2 raised to the largest
exponent, where epsilon depends on the precision of the
considered variable.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005femin"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_emin</strong> <code class="def-code-arguments">(mpfr_exp_t <var class="var">exp</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005femin'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005femax"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_emax</strong> <code class="def-code-arguments">(mpfr_exp_t <var class="var">exp</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005femax'> &para;</a></span></dt>
<dd><p>Set the smallest and largest exponents allowed for a floating-point variable.
Return a non-zero value when <var class="var">exp</var> is not in the range accepted by the
implementation (in that case the smallest or largest exponent is not changed),
and zero otherwise.
</p>
<p>For the subsequent operations, it is the user&rsquo;s responsibility to check
that any floating-point value used as an input is in the new exponent range
(for example using <code class="code">mpfr_check_range</code>). If a floating-point value
outside the new exponent range is used as an input, the default behavior
is undefined, in the sense of the ISO C standard; the behavior may also be
explicitly documented, such as for <code class="code">mpfr_check_range</code>.
</p>
<p>Note: Caches may still have values outside the current exponent range.
This is not an issue as the user cannot use these caches directly via
the API (MPFR extends the exponent range internally when need be).
</p>
<p>If <var class="var">emin</var>&nbsp;&gt;&nbsp;<var class="var">emax</var><!-- /@w --> and a floating-point value needs to
be produced as output, the behavior is undefined (<code class="code">mpfr_set_emin</code>
and <code class="code">mpfr_set_emax</code> do not check this condition as it might occur
between successive calls to these two functions).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fget_005femin_005fmin"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_get_emin_min</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005femin_005fmin'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005femin_005fmax"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_get_emin_max</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005femin_005fmax'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005femax_005fmin"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_get_emax_min</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005femax_005fmin'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fget_005femax_005fmax"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_get_emax_max</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fget_005femax_005fmax'> &para;</a></span></dt>
<dd><p>Return the minimum and maximum of the exponents
allowed for <code class="code">mpfr_set_emin</code> and <code class="code">mpfr_set_emax</code> respectively.
These values are implementation dependent, thus a program using
<code class="code">mpfr_set_emax(mpfr_get_emax_max())</code>
or <code class="code">mpfr_set_emin(mpfr_get_emin_min())</code> may not be portable.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcheck_005frange"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_check_range</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, int <var class="var">t</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcheck_005frange'> &para;</a></span></dt>
<dd><p>This function assumes that <var class="var">x</var> is the correctly rounded value of some
real value <var class="var">y</var> in the direction <var class="var">rnd</var> and some extended exponent
range, and that <var class="var">t</var> is the corresponding <a class="ref" href="constant.MPFR_Basics.html#ternary-value">ternary value</a>.
For example, one performed <code class="code">t = mpfr_log (x, u, rnd)</code>, and <var class="var">y</var> is the
exact logarithm of <var class="var">u</var>.
Thus <var class="var">t</var> is negative if <var class="var">x</var> is smaller than <var class="var">y</var>,
positive if <var class="var">x</var> is larger than <var class="var">y</var>, and zero if <var class="var">x</var> equals <var class="var">y</var>.
This function modifies <var class="var">x</var> if needed
to be in the current range of acceptable values: It
generates an underflow or an overflow if the exponent of <var class="var">x</var> is
outside the current allowed range; the value of <var class="var">t</var> may be used
to avoid a double rounding. This function returns zero if the new value of
<var class="var">x</var> equals the exact one <var class="var">y</var>, a positive value if that new value
is larger than <var class="var">y</var>, and a negative value if it is smaller than <var class="var">y</var>.
Note that unlike most functions,
the new result <var class="var">x</var> is compared to the (unknown) exact one <var class="var">y</var>,
not the input value <var class="var">x</var>, i.e., the ternary value is propagated.
</p>
<p>Note: If <var class="var">x</var> is an infinity and <var class="var">t</var> is different from zero (i.e.,
if the rounded result is an inexact infinity), then the overflow flag is
set. This is useful because <code class="code">mpfr_check_range</code> is typically called
(at least in MPFR functions) after restoring the flags that could have
been set due to internal computations.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsubnormalize"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_subnormalize</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, int <var class="var">t</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsubnormalize'> &para;</a></span></dt>
<dd><p>This function rounds <var class="var">x</var> emulating subnormal number arithmetic:
if <var class="var">x</var> is outside the subnormal exponent range of the emulated
floating-point system, this function just propagates the
<a class="ref" href="constant.MPFR_Basics.html#ternary-value">ternary value</a> <var class="var">t</var>; otherwise, if EXP(<var class="var">x</var>)<!-- /@w -->
denotes the exponent of <var class="var">x</var>, it rounds <var class="var">x</var> to precision
EXP(<var class="var">x</var>)&minus;<var class="var">emin</var>+1<!-- /@w --> according to rounding mode <var class="var">rnd</var>
and previous ternary value <var class="var">t</var>, avoiding double rounding problems.
More precisely in the subnormal domain, denoting by e<!-- /@w --> the value of
<var class="var">emin</var>, <var class="var">x</var> is rounded in fixed-point arithmetic to an integer
multiple of two to the power e&nbsp;&minus;&nbsp;1<!-- /@w -->; as a consequence,
1.5 multiplied by two to the power e&nbsp;&minus;&nbsp;1<!-- /@w -->
when <var class="var">t</var> is zero is rounded to two to the power e with rounding
to nearest.
</p>
<p>The precision PREC(<var class="var">x</var>)<!-- /@w --> of <var class="var">x</var> is not modified by
this function. <var class="var">rnd</var> and <var class="var">t</var> must be the rounding mode
and the returned ternary value used when computing <var class="var">x</var>
(as in <code class="code">mpfr_check_range</code>). The subnormal exponent range is
from <var class="var">emin</var> to <var class="var">emin</var>+PREC(<var class="var">x</var>)&minus;1<!-- /@w -->.
If the result cannot be represented in the current exponent range of MPFR
(due to a too small <var class="var">emax</var>), the behavior is undefined.
Note that unlike most functions, the result is compared to the exact one,
not the input value <var class="var">x</var>, i.e., the ternary value is propagated.
</p>
<p>As usual, if the returned ternary value is non zero, the inexact flag is set.
Moreover, if a second rounding occurred (because the input <var class="var">x</var> was in the
subnormal range), the underflow flag is set.
</p>
<p>Warning! If you change <var class="var">emin</var> (with <code class="code">mpfr_set_emin</code>) just before
calling <code class="code">mpfr_subnormalize</code>, you need to make sure that the value is
in the current exponent range of MPFR. But it is better to change
<var class="var">emin</var> before any computation, if possible.
</p></dd></dl>
<p>This is an example of how to emulate binary64 IEEE&nbsp;754 arithmetic
(a.k.a. double precision) using MPFR:
</p>
<div class="example">
<pre class="example-preformatted">{
  mpfr_t xa, xb; int i; volatile double a, b;
  mpfr_set_default_prec (53);
  mpfr_set_emin (-1073); mpfr_set_emax (1024);
  mpfr_init (xa); mpfr_init (xb);
  b = 34.3; mpfr_set_d (xb, b, MPFR_RNDN);
  a = 0x1.1235P-1021; mpfr_set_d (xa, a, MPFR_RNDN);
  a /= b;
  i = mpfr_div (xa, xa, xb, MPFR_RNDN);
  i = mpfr_subnormalize (xa, i, MPFR_RNDN); /* new ternary value */
  mpfr_clear (xa); mpfr_clear (xb);
}
</pre></div>
<p>Note that <code class="code">mpfr_set_emin</code> and <code class="code">mpfr_set_emax</code> are called early
enough in order to make sure that all computed values are in the current
exponent range.
Warning! This emulates a double IEEE&nbsp;754 arithmetic with correct rounding
in the subnormal range, which may not be the case for your hardware.
</p>
<p>Below is another example showing how to emulate fixed-point arithmetic
in a specific case.
Here we compute the sine of the integers 1 to 17 with a result in a
fixed-point arithmetic rounded at two to the power &minus;42
(using the fact that the result is at most 1 in absolute value):
</p>
<div class="example">
<pre class="example-preformatted">{
  mpfr_t x; int i, inex;
  mpfr_set_emin (-41);
  mpfr_init2 (x, 42);
  for (i = 1; i &lt;= 17; i++)
    {
      mpfr_set_ui (x, i, MPFR_RNDN);
      inex = mpfr_sin (x, x, MPFR_RNDZ);
      mpfr_subnormalize (x, inex, MPFR_RNDZ);
      mpfr_dump (x);
    }
  mpfr_clear (x);
}
</pre></div>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fclear_005funderflow"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clear_underflow</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fclear_005funderflow'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fclear_005foverflow"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clear_overflow</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fclear_005foverflow'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fclear_005fdivby0"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clear_divby0</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fclear_005fdivby0'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fclear_005fnanflag"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clear_nanflag</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fclear_005fnanflag'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fclear_005finexflag"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clear_inexflag</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fclear_005finexflag'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fclear_005ferangeflag"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clear_erangeflag</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fclear_005ferangeflag'> &para;</a></span></dt>
<dd><p>Clear (lower) the underflow, overflow, divide-by-zero, invalid,
inexact and <em class="emph">erange</em> flags.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fclear_005fflags"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_clear_flags</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fclear_005fflags'> &para;</a></span></dt>
<dd><p>Clear (lower) all global flags (underflow, overflow, divide-by-zero, invalid,
inexact, <em class="emph">erange</em>). Note: a group of flags can be cleared by using
<code class="code">mpfr_flags_clear</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005funderflow"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_underflow</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fset_005funderflow'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005foverflow"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_overflow</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fset_005foverflow'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fdivby0"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_divby0</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fset_005fdivby0'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fnanflag"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_nanflag</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fset_005fnanflag'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005finexflag"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_inexflag</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fset_005finexflag'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005ferangeflag"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_erangeflag</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fset_005ferangeflag'> &para;</a></span></dt>
<dd><p>Set (raise) the underflow, overflow, divide-by-zero, invalid,
inexact and <em class="emph">erange</em> flags.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005funderflow_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_underflow_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005funderflow_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005foverflow_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_overflow_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005foverflow_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdivby0_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_divby0_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fdivby0_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fnanflag_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_nanflag_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fnanflag_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005finexflag_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_inexflag_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005finexflag_005fp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ferangeflag_005fp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_erangeflag_p</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005ferangeflag_005fp'> &para;</a></span></dt>
<dd><p>Return the corresponding (underflow, overflow, divide-by-zero, invalid,
inexact, <em class="emph">erange</em>) flag, which is non-zero iff the flag is set.
</p></dd></dl>
<p>The <code class="code">mpfr_flags_</code> functions below that take an argument <var class="var">mask</var>
can operate on any subset of the exception flags: a flag is part of this
subset (or group) if and only if the corresponding bit of the argument
<var class="var">mask</var> is set.  The <code class="code">MPFR_FLAGS_</code> macros will normally be used
to build this argument.  See <a class="xref" href="constant.MPFR_Basics.html#Exceptions">Exceptions</a>.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fflags_005fclear"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_flags_clear</strong> <code class="def-code-arguments">(mpfr_flags_t <var class="var">mask</var>)</code><a class="copiable-link" href='#index-mpfr_005fflags_005fclear'> &para;</a></span></dt>
<dd><p>Clear (lower) the group of flags specified by <var class="var">mask</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fflags_005fset"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_flags_set</strong> <code class="def-code-arguments">(mpfr_flags_t <var class="var">mask</var>)</code><a class="copiable-link" href='#index-mpfr_005fflags_005fset'> &para;</a></span></dt>
<dd><p>Set (raise) the group of flags specified by <var class="var">mask</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fflags_005ftest"><span class="category-def">Function: </span><span><code class="def-type">mpfr_flags_t</code> <strong class="def-name">mpfr_flags_test</strong> <code class="def-code-arguments">(mpfr_flags_t <var class="var">mask</var>)</code><a class="copiable-link" href='#index-mpfr_005fflags_005ftest'> &para;</a></span></dt>
<dd><p>Return the flags specified by <var class="var">mask</var>.  To test whether any flag from
<var class="var">mask</var> is set, compare the return value to 0.  You can also test
individual flags by AND&rsquo;ing the result with <code class="code">MPFR_FLAGS_</code> macros.
Example:
</p><div class="example">
<pre class="example-preformatted">mpfr_flags_t t = mpfr_flags_test (MPFR_FLAGS_UNDERFLOW|
                                  MPFR_FLAGS_OVERFLOW)
&hellip;
if (t)  /* underflow and/or overflow (unlikely) */
  {
    if (t &amp; MPFR_FLAGS_UNDERFLOW)  { /* handle underflow */ }
    if (t &amp; MPFR_FLAGS_OVERFLOW)   { /* handle overflow  */ }
  }
</pre></div>
</dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fflags_005fsave"><span class="category-def">Function: </span><span><code class="def-type">mpfr_flags_t</code> <strong class="def-name">mpfr_flags_save</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fflags_005fsave'> &para;</a></span></dt>
<dd><p>Return all the flags. It is equivalent to
<code class="code">mpfr_flags_test(MPFR_FLAGS_ALL)</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fflags_005frestore"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_flags_restore</strong> <code class="def-code-arguments">(mpfr_flags_t <var class="var">flags</var>, mpfr_flags_t <var class="var">mask</var>)</code><a class="copiable-link" href='#index-mpfr_005fflags_005frestore'> &para;</a></span></dt>
<dd><p>Restore the flags specified by <var class="var">mask</var> to their state represented
in <var class="var">flags</var>.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Memory-Handling-Functions">
<div class="nav-panel">
<p>
Next: <a href="#Compatibility-with-MPF" accesskey="n" rel="next">Compatibility With MPF</a>, Previous: <a href="#Exception-Related-Functions" accesskey="p" rel="prev">Exception Related Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Memory-handling-functions"></a>
<h3 class="section" id="Memory-Handling-Functions-1">5.14 Memory Handling Functions</h3>
<p>These are general functions concerning memory handling
(see <a class="pxref" href="constant.MPFR_Basics.html#Memory-Handling">Memory Handling</a>, for more information).
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffree_005fcache"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_free_cache</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005ffree_005fcache'> &para;</a></span></dt>
<dd><p>Free all caches and pools used by MPFR internally (those local to the
current thread and those shared by all threads).
You should call this function before terminating a thread, even if you did
not call <code class="code">mpfr_const_*</code> functions directly (they could have been called
internally).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffree_005fcache2"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_free_cache2</strong> <code class="def-code-arguments">(mpfr_free_cache_t <var class="var">way</var>)</code><a class="copiable-link" href='#index-mpfr_005ffree_005fcache2'> &para;</a></span></dt>
<dd><p>Free various caches and pools used by MPFR internally,
as specified by <var class="var">way</var>, which is a set of flags:
</p><ul class="itemize mark-bullet">
<li>those local to the current thread if flag <code class="code">MPFR_FREE_LOCAL_CACHE</code>
is set;
</li><li>those shared by all threads if flag <code class="code">MPFR_FREE_GLOBAL_CACHE</code>
is set.
</li></ul>
<p>The other bits of <var class="var">way</var> are currently ignored and are reserved for
future use; they should be zero.
</p>
<p>Note: <code class="code">mpfr_free_cache2 (MPFR_FREE_LOCAL_CACHE | MPFR_FREE_GLOBAL_CACHE)</code>
is currently equivalent to <code class="code">mpfr_free_cache()</code>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffree_005fpool"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_free_pool</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005ffree_005fpool'> &para;</a></span></dt>
<dd><p>Free the pools used by MPFR internally.
Note: This function is automatically called after the thread-local caches
are freed (with <code class="code">mpfr_free_cache</code> or <code class="code">mpfr_free_cache2</code>).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmp_005fmemory_005fcleanup"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mp_memory_cleanup</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href='#index-mpfr_005fmp_005fmemory_005fcleanup'> &para;</a></span></dt>
<dd><p>This function should be called before calling <code class="code">mp_set_memory_functions</code>.
See <a class="xref" href="constant.MPFR_Basics.html#Memory-Handling">Memory Handling</a>, for more information.
Zero is returned in case of success, non-zero in case of error.
Errors are currently not possible, but checking the return value
is recommended for future compatibility.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Compatibility-with-MPF">
<div class="nav-panel">
<p>
Next: <a href="#Custom-Interface" accesskey="n" rel="next">Custom Interface</a>, Previous: <a href="#Memory-Handling-Functions" accesskey="p" rel="prev">Memory Handling Functions</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Compatibility-with-MPF"></a>
<h3 class="section" id="Compatibility-With-MPF">5.15 Compatibility With MPF</h3>
<p>A header file <samp class="file">mpf2mpfr.h</samp> is included in the distribution of MPFR for
compatibility with the GNU MP class MPF.
By inserting the following two lines after the <code class="code">#include &lt;gmp.h&gt;</code> line,
</p><div class="example">
<pre class="example-preformatted">#include &lt;mpfr.h&gt;
#include &lt;mpf2mpfr.h&gt;
</pre></div>
<p>many programs written for MPF can be compiled directly against MPFR
without any changes.
All operations are then performed with the default MPFR rounding mode,
which can be reset with <code class="code">mpfr_set_default_rounding_mode</code>.
</p>
<p>Warning! There are some differences. In particular:
</p><ul class="itemize mark-bullet">
<li>The precision is different: MPFR rounds to the exact number of bits
(zeroing trailing bits in the internal representation). Users may need to
increase the precision of their variables.
</li><li>The exponent range is also different.
</li><li>The formatted output functions (<code class="code">gmp_printf</code>, etc.) will not work
for arguments of arbitrary-precision floating-point type (<code class="code">mpf_t</code>, which
<samp class="file">mpf2mpfr.h</samp> redefines as <code class="code">mpfr_t</code>).
</li><li>The output of <code class="code">mpf_out_str</code> has a format slightly different from
the one of <code class="code">mpfr_out_str</code> (concerning the position of the decimal-point
character, trailing zeros and the output of the value 0).
</li></ul>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fprec_005fraw"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_prec_raw</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_prec_t <var class="var">prec</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fprec_005fraw'> &para;</a></span></dt>
<dd><p>Reset the precision of <var class="var">x</var> to be <strong class="strong">exactly</strong> <var class="var">prec</var> bits.
The only difference with <code class="code">mpfr_set_prec</code> is that <var class="var">prec</var> is assumed to
be small enough so that the significand fits into the current allocated memory
space for <var class="var">x</var>. Otherwise the behavior is undefined.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005feq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_eq</strong> <code class="def-code-arguments">(mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, unsigned long int <var class="var">op3</var>)</code><a class="copiable-link" href='#index-mpfr_005feq'> &para;</a></span></dt>
<dd><p>Return non-zero if <var class="var">op1</var> and <var class="var">op2</var> are both non-zero ordinary
numbers with the same exponent and the same first <var class="var">op3</var> bits, both
zero, or both infinities of the same sign. Return zero otherwise.
This function is defined for compatibility with MPF, we do not recommend
to use it otherwise.
Do not use it either if
you want to know whether two numbers are close to each other; for instance,
1.011111 and 1.100000 are regarded as different for any value of
<var class="var">op3</var> larger than 1.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005freldiff"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_reldiff</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005freldiff'> &para;</a></span></dt>
<dd><p>Compute the relative difference between <var class="var">op1</var> and <var class="var">op2</var>
and store the result in <var class="var">rop</var>.
This function does not guarantee the correct rounding on the relative
difference; it just computes |<var class="var">op1</var>&nbsp;&minus;&nbsp;<var class="var">op2</var>|&nbsp;/&nbsp;<var class="var">op1</var><!-- /@w -->,
using the precision of <var class="var">rop</var> and the rounding mode <var class="var">rnd</var> for all
operations.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmul_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005f2exp'> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005f2exp'> &para;</a></span></dt>
<dd><p>These functions are identical to <code class="code">mpfr_mul_2ui</code> and <code class="code">mpfr_div_2ui</code>
respectively.
These functions are only kept for compatibility with MPF, one should
prefer <code class="code">mpfr_mul_2ui</code> and <code class="code">mpfr_div_2ui</code> otherwise.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Custom-Interface">
<div class="nav-panel">
<p>
Next: <a href="#Internals" accesskey="n" rel="next">Internals</a>, Previous: <a href="#Compatibility-with-MPF" accesskey="p" rel="prev">Compatibility With MPF</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Custom-interface"></a>
<h3 class="section" id="Custom-Interface-1">5.16 Custom Interface</h3>
<p>Some applications use a stack to handle the memory and their objects.
However, the MPFR memory design is not well suited for such a thing. So that
such applications are able to use MPFR, an auxiliary memory interface has
been created: the Custom Interface.
</p>
<p>The following interface allows one to use MPFR in two ways:
</p>
<ul class="itemize mark-bullet">
<li>Either directly store a floating-point number as a <code class="code">mpfr_t</code>
on the stack.
</li><li>Either store its own representation on the
stack and construct a new temporary <code class="code">mpfr_t</code> each time it is needed.
</li></ul>
<p>Nothing has to be done to destroy the floating-point
numbers except garbaging the used
memory: all the memory management (allocating, destroying, garbaging) is left
to the application.
</p>
<p>Each function in this interface is also implemented as a macro for
efficiency reasons: for example <code class="code">mpfr_custom_init (s, p)</code>
uses the macro, while <code class="code">(mpfr_custom_init) (s, p)</code> uses the function.
The <code class="code">mpfr_custom_init_set</code> macro is not usable in contexts where
an expression is expected, e.g., inside <code class="code">for(...)</code> or before a
comma operator.
</p>
<p>Note 1: MPFR functions may still initialize temporary floating-point numbers
using <code class="code">mpfr_init</code> and similar functions. See Custom Allocation (GNU MP).
</p>
<p>Note 2: MPFR functions may use the cached functions (<code class="code">mpfr_const_pi</code> for
example), even if they are not explicitly called. You have to call
<code class="code">mpfr_free_cache</code> each time you garbage the memory iff <code class="code">mpfr_init</code>,
through GMP Custom Allocation, allocates its memory on the application stack.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcustom_005fget_005fsize"><span class="category-def">Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">mpfr_custom_get_size</strong> <code class="def-code-arguments">(mpfr_prec_t <var class="var">prec</var>)</code><a class="copiable-link" href='#index-mpfr_005fcustom_005fget_005fsize'> &para;</a></span></dt>
<dd><p>Return the needed size in bytes to store the significand of a floating-point
number of precision <var class="var">prec</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcustom_005finit"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_custom_init</strong> <code class="def-code-arguments">(void *<var class="var">significand</var>, mpfr_prec_t <var class="var">prec</var>)</code><a class="copiable-link" href='#index-mpfr_005fcustom_005finit'> &para;</a></span></dt>
<dd><p>Initialize a significand of precision <var class="var">prec</var>, where
<var class="var">significand</var> must be an area of <code class="code">mpfr_custom_get_size (prec)</code> bytes
at least and be suitably aligned for an array of <code class="code">mp_limb_t</code> (GMP type,
see <a class="pxref" href="#Internals">Internals</a>).
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcustom_005finit_005fset"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_custom_init_set</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, int <var class="var">kind</var>, mpfr_exp_t <var class="var">exp</var>, mpfr_prec_t <var class="var">prec</var>, void *<var class="var">significand</var>)</code><a class="copiable-link" href='#index-mpfr_005fcustom_005finit_005fset'> &para;</a></span></dt>
<dd><p>Perform a dummy initialization of a <code class="code">mpfr_t</code> and set it to:
</p><ul class="itemize mark-bullet">
<li>if abs(<var class="var">kind</var>) = <code class="code">MPFR_NAN_KIND</code>, <var class="var">x</var> is set to NaN;
</li><li>if abs(<var class="var">kind</var>) = <code class="code">MPFR_INF_KIND</code>, <var class="var">x</var> is set to the
infinity of the same sign as <var class="var">kind</var>;
</li><li>if abs(<var class="var">kind</var>) = <code class="code">MPFR_ZERO_KIND</code>, <var class="var">x</var> is set to the
zero of the same sign as <var class="var">kind</var>;
</li><li>if abs(<var class="var">kind</var>) = <code class="code">MPFR_REGULAR_KIND</code>, <var class="var">x</var> is set to
the regular number whose sign is the one of <var class="var">kind</var>, and whose exponent
and significand are given by <var class="var">exp</var> and <var class="var">significand</var>.
</li></ul>
<p>In all cases, <var class="var">significand</var> will be used directly for further computing
involving <var class="var">x</var>. This function does not allocate anything.
A floating-point number initialized with this function cannot be resized using
<code class="code">mpfr_set_prec</code> or <code class="code">mpfr_prec_round</code>,
or cleared using <code class="code">mpfr_clear</code>!
The <var class="var">significand</var> must have been initialized with <code class="code">mpfr_custom_init</code>
using the same precision <var class="var">prec</var>.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcustom_005fget_005fkind"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_custom_get_kind</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fcustom_005fget_005fkind'> &para;</a></span></dt>
<dd><p>Return the current kind of a <code class="code">mpfr_t</code> as created by
<code class="code">mpfr_custom_init_set</code>.
The behavior of this function for any <code class="code">mpfr_t</code> not initialized
with <code class="code">mpfr_custom_init_set</code> is undefined.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcustom_005fget_005fsignificand"><span class="category-def">Function: </span><span><code class="def-type">void *</code> <strong class="def-name">mpfr_custom_get_significand</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fcustom_005fget_005fsignificand'> &para;</a></span></dt>
<dd><p>Return a pointer to the significand used by a <code class="code">mpfr_t</code> initialized with
<code class="code">mpfr_custom_init_set</code>.
The behavior of this function for any <code class="code">mpfr_t</code> not initialized
with <code class="code">mpfr_custom_init_set</code> is undefined.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcustom_005fget_005fexp"><span class="category-def">Function: </span><span><code class="def-type">mpfr_exp_t</code> <strong class="def-name">mpfr_custom_get_exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fcustom_005fget_005fexp'> &para;</a></span></dt>
<dd><p>Return the exponent of <var class="var">x</var>, assuming that <var class="var">x</var> is a non-zero ordinary
number and the significand is considered in [1/2,1).
But if <var class="var">x</var> is NaN, infinity or zero, contrary to <code class="code">mpfr_get_exp</code>
(where the behavior is undefined), the return value is here an unspecified,
valid value of the <code class="code">mpfr_exp_t</code> type.
The behavior of this function for any <code class="code">mpfr_t</code> not initialized
with <code class="code">mpfr_custom_init_set</code> is undefined.
</p></dd></dl>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcustom_005fmove"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_custom_move</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, void *<var class="var">new_position</var>)</code><a class="copiable-link" href='#index-mpfr_005fcustom_005fmove'> &para;</a></span></dt>
<dd><p>Inform MPFR that the significand of <var class="var">x</var> has moved due to a garbage collect
and update its new position to <code class="code">new_position</code>.
However, the application has to move the significand and the <code class="code">mpfr_t</code>
itself.
The behavior of this function for any <code class="code">mpfr_t</code> not initialized
with <code class="code">mpfr_custom_init_set</code> is undefined.
</p></dd></dl>
<hr>
</div>
<div class="section-level-extent" id="Internals">
<div class="nav-panel">
<p>
Previous: <a href="#Custom-Interface" accesskey="p" rel="prev">Custom Interface</a>, Up: <a href="#MPFR-Interface" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
<a class="index-entry-id" id="index-Internals"></a>
<h3 class="section" id="Internals-1">5.17 Internals</h3>
<a class="index-entry-id" id="index-Limb"></a>
<p>A <em class="dfn">limb</em> means the part of a multi-precision number that fits in a single
word. Usually a limb contains
32 or 64 bits.  The C data type for a limb is <code class="code">mp_limb_t</code>.
</p>
<p>The <code class="code">mpfr_t</code> type is internally defined as a one-element
array of a structure, and <code class="code">mpfr_ptr</code> is the C data type representing
a pointer to this structure.
The <code class="code">mpfr_t</code> type consists of four fields:
</p>
<ul class="itemize mark-bullet">
<li>The <code class="code">_mpfr_prec</code> field is used to store the precision of
the variable (in bits); this is not less than <code class="code">MPFR_PREC_MIN</code>.
</li><li>The <code class="code">_mpfr_sign</code> field is used to store the sign of the variable.
</li><li>The <code class="code">_mpfr_exp</code> field stores the exponent.
An exponent of 0 means a radix point just above the most significant
limb.  Non-zero values n<!-- /@w --> are a multiplier 2^n<!-- /@w --> relative to that
point.
A NaN, an infinity and a zero are indicated by special values of the exponent
field.
</li><li>Finally, the <code class="code">_mpfr_d</code> field is a pointer to the limbs, least
significant limbs stored first.
The number of limbs in use is controlled by <code class="code">_mpfr_prec</code>, namely
ceil(<code class="code">_mpfr_prec</code>/<code class="code">mp_bits_per_limb</code>).
Non-singular (i.e., different from NaN, infinity or zero)
values always have the most significant bit of the most
significant limb set to 1.  When the precision does not correspond to a
whole number of limbs, the excess bits at the low end of the data are zeros.
</li></ul>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="constant.API_Compatibility.html#API-Compatibility" accesskey="n" rel="next">API Compatibility</a>, Previous: <a href="constant.MPFR_Basics.html#MPFR-Basics" accesskey="p" rel="prev">MPFR Basics</a>, Up: <a href="index.html#start" accesskey="u" rel="up">GNU MPFR</a> &nbsp; [<a href="constant.Concept_Index.html#start" title="Index" rel="index">Index</a>]</p>
</div>
